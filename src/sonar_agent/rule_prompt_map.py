rule_prompt_map = {
    "RSPEC-818": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Literal suffixes should be upper case\nDescription: Why is this an issue?\nUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\nNoncompliant code example\n```java\nlong long1 = 1l; // Noncompliant\nfloat float1 = 1.0f; // Noncompliant\ndouble double1 = 1.0d; // Noncompliant\n```\nCompliant solution\n```java\nlong long1 = 1L;\nfloat float1 = 1.0F;\ndouble double1 = 1.0D;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7629": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: When a defaultFinisher is passed to a Gatherer factory, use the overload that does not take a finisher\nDescription: Why is this an issue?\nPassing an empty finisher to\nGatherer.of\nor to\nGatherer.ofSequential\nprovides no additional value and removing the\nfinisher clearly communicates that no finisher is applied.\nHow to fix it\nCall the overload of\nGatherer.of\nor\nGatherer.ofSequential\nthat does not take a finisher.\nCode examples\nNoncompliant code example\n```java\nGatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n  () -> new AtomicInteger(-1),\n  (state, number, downstream) -> {\n    if (state.get() < 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  },\n  Gatherer.defaultFinisher()); // Noncompliant: useless finisher\n```\nCompliant solution\n```java\nGatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n  () -> new AtomicInteger(-1),\n  (state, number, downstream) -> {\n    if (state.get() < 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  }); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7481": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Gatherer.ofSequential() should be used to build sequential gathers\nDescription: Why is this an issue?\nWhen a method uses a\nGatherer.of(\u2026\u200b)\nfactory and provides a combiner function that always throws an exception, this implicitly signals\nthat the gatherer is designed for sequential processing. The\njava.util.stream.Gatherer\nAPI provides\nGatherer.ofSequential(\u2026\u200b)\nfactories which clearly indicates that the gatherer is intended for sequential streams. Using such a factory\nimproves code clarity, makes the intended processing model explicit, and avoids the need for a dummy or throwing combiner.\nHow to fix it\nUse\nGatherer.ofSequential\ninstead of\nGatherer.of\n.\nCode examples\nNoncompliant code example\n```java\npublic static List<Integer> diffWithFirstPositive(List<Integer> list) {\n    Gatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.of(\n      () -> new AtomicInteger(-1),\n      (state, number, downstream) -> {\n        if (state.get() < 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      (_, _) -> {\n        throw new IllegalStateException();\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n```\nCompliant solution\n```java\npublic static List<Integer> diffWithFirstPositive(List<Integer> list) {\n    Gatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n      () -> new AtomicInteger(-1),\n      (state, number, downstream) -> {\n        if (state.get() < 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7479": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ClassBuilder.withMethodBody\" should be preferred to \"ClassBuilder.withMethod\"\nDescription: Why is this an issue?\nThe\nClassBuilder\nAPI provides multiple ways to declare a method and its body, including\nwithMethod\nand\nwithMethodBody\n. While they can be used in very similar ways,\nwithMethodBody\nreduces boilerplate code, lowers cognitive\ncomplexity and improves maintainability.\nExceptions\nThe rule will not raise on calls where the method under construction is abstract (eg: using the flag\nClassFile.ACC_ABSTRACT\n).\nHow to fix it\nReplace the invocation of\nwithMethod\nwith\nwithMethodBody\n.\nCode examples\nNoncompliant code example\n```java\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethod(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, methodBuilder -> { // Noncompliant\n            methodBuilder.withCode(codeBuilder ->\n                codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                    .ldc(\"Hello World\")\n                    .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                    .return_()\n            );\n        });\n}\n```\nCompliant solution\n```java\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethodBody(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, codeBuilder ->\n            codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                .ldc(\"Hello World\")\n                .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                .return_()\n        );\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7478": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"transformClass\" method should be used instead of \"build\" when transforming a class\nDescription: Why is this an issue?\nThe common pattern of taking a class-file entity, obtaining a corresponding builder, examining each element of the entity and possibly replacing it\nwith other elements can be expressed by transforms. Using the\ntransformClass\nmethod in that case instead of\nbuild\nremoves\nall that boilerplate and makes the intent clearer.\nHow to fix it\nUse the\nClassFile.transformClass\nmethod instead of\nClassFile.build\n.\nCode examples\nNoncompliant code example\n```java\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.build( // Noncompliant\n    classModel.thisClass().asSymbol(), classBuilder -> {\n        for (ClassElement classElement : classModel) {\n          if (!(classElement instanceof MethodModel methodModel &&\n              methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n\n          }\n        }\n    });\n  Files.write(path, newBytes);\n}\n```\nCompliant solution\n```java\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.transformClass(\n    classModel, (classBuilder, classElement) -> {\n      if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n          classBuilder.with(classElement);\n        }\n      });\n  Files.write(path, newBytes);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7477": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class name should be omitted when unchanged by class transform\nDescription: Why is this an issue?\nIn the classfile API introduced by Java 24, there are several versions of the\ntransformClass\nmethods. In particular if the name of the\ntransformed class is unchanged compared to the original class, then it is recommended to use the simplest version of the method that takes only 2\narguments. This makes the code shorter, clearer, and reduces chances for mistakes.\nHow to fix it\nRemove the class name argument of the\ntransformClass\ncall.\nCode examples\nNoncompliant code example\n```java\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      classModel.thisClass().asSymbol(), // Noncompliant\n      (classBuilder, classElement) -> {\n        if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n```\nCompliant solution\n```java\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      (classBuilder, classElement) -> {\n        if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7476": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comments should start with the appropriate number of slashes\nDescription: Why is this an issue?\nStarting in Java 23, comments beginning with three slashes\n///\nare interpreted as JavaDoc comments using Markdown syntax.\nIn Java 22 and earlier, comments starting with more than 2 slashes were treated as normal comments. Accidentally writing comments with three or\nmore slashes can lead to unintended JavaDoc being generated, when migrating to Java 23.\nWhat is the potential impact?\nComments starting with three or more slashes will increase the migration cost when upgrading to Java 23 or later. Moreover, IDE or other tools may\nhandle such comments as JavaDoc comments if they are not aware of the Java version.\nExceptions\n1. The rule does not raise issues on license headers at the start of files because they will not be considered as JavaDoc comments.\n2. The rule only raises issues in projects using Java 17 or above, because those projects will likely be migrated to Java 23 or later.\nHow to fix it\nIn versions of Java prior to 23, comments should not start with more than 2 slashes, and from Java 23 forward they should not start with more than\n3.\nCode examples\nNoncompliant code example\nThe following code will generate unintended JavaDoc comments if migrated to Java 23:\n```java\n/// Some comment for the developers\npublic abstract void foo();\n//// public void foo(String s){}\npublic void foo(){}\n```\nCompliant solution\n```java\n// Some comment for the developers\npublic abstract void foo();\n// public void foo(String s){}\npublic void foo(){}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7474": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Markdown, HTML and Javadoc tags should be consistent\nDescription: Why is this an issue?\nWith the introduction of Markdown support in Javadoc comments in Java 23, developers should prefer Markdown syntax over legacy HTML tags (e.g.,\n<b>\n,\n<i>\n,\n<code>\n,\n<ul>\n,\n<li>\n, etc.) and legacy Javadoc\ntags (e.g.\n{@link java.util.HashMap}\n,\n{@code Object}\n).\nMixing HTML and Markdown can lead to readability issues and inconsistencies in rendering across tools. Markdown is generally more readable, less\ncluttered and, should be preferred over HTML tags when possible.\nThis rule will raise an issue when an HTML tag or a legacy Javadoc tag inside a markdown comment could be replaced with a slimmer, and more\ncohesive, syntax.\nHow to fix it\nHere is a list of tags that should be replaced with markdown syntax:\n1. <p>should be replaced with 2 new lines\n2. <code>MyCode</code>,{@code MyCode}should be replaced with`MyCode`\n3. <i>italic text</i>,<em>should be replaced with*italic text*\n4. <b>bold text</b>,<strong>should be replaced with**bold text**\n5. <ul><li>list item</li></ul>,<ol><li>should be replaced with* list\n  item\n6. {@link some.java.Class}should be replaced with[some.java.Class]\n7. {@link #equals(Object) equals}should be replaced with[equals][#equals(Object)]\nCode examples\nNoncompliant code example\n```java\n/// This is a markdown Javadoc comment\n/// <b>ExampleClass</b> is a simple utility for <i>demonstration purposes</i>.\n/// <p>\n///     Use <code>ExampleClass.run()</code> to execute the example.\n/// </p>\n/// {@link some.java.Class} for more details\npublic class ExampleClass {\n}\n```\nCompliant solution\n```java\n/// This is a markdown Javadoc comment\n/// **ExampleClass** is a simple utility for *demonstration purposes*.\n///\n/// Use `ExampleClass.run()` to execute the example.\n/// [some.java.Class] for more details\npublic class ExampleClass {\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7467": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused exception parameter should use the unnamed variable pattern\nDescription: Why is this an issue?\nGood exception management is key to keeping a consistent application state in the face of errors and unexpected behaviors. However, in some cases,\nthe information carried by the exception is not as important as the exception bubbling up itself. In such cases, developers may want to explicitly\nindicate that they have no use for the exception parameter. Java 22 introduces the unnamed variable pattern\n_\nwhich allows developers to\nfree the catch clause from an unnecessary exception parameter name.\nHow to fix it\nReplace exception parameter name with unnamed variable pattern\n_\n.\nCode examples\nNoncompliant code example\n```java\nList<String> elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException nfe) { // Noncompliant\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException ioob) {  // Noncompliant\n  System.err.println(\"No such element\");\n}\n```\nCompliant solution\n```java\nList<String> elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException _) {\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException _) {\n  System.err.println(\"No such element\");\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7466": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnamed variable declarations should use the \"var\" identifier\nDescription: Why is this an issue?\nThe syntax of some Java constructs, such as enhanced for loops, requires that you declare a variable that you may have no use for. To solve this\nissue, Java 22 introduced an unnamed variable pattern,\n_\n. This feature removes the need to name variables that are syntactically required\nbut otherwise unused. Moreover, it clearly indicates the intent not to use the variable.\nTo further minimize clutter, unnamed variables should use the\nvar\npattern rather than explicit type declarations. In addition to\nminimizing clutter, removing the type makes the code easier to maintain. Indeed, if the type was to change in future, the code would remain the\nsame.\nExceptions\nThis rule does not apply to basic\nfor\nloops and local variable declarations in a block.\nHow to fix it\nReplace the local variable type with\nvar\n.\nCode examples\nNoncompliant code example\n```java\nfor (String _ : myIterable) { // Noncompliant\n  // ...\n}\n\n\ntry (Resource _ = new Resource()) { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\nfor (var _ : myIterable) {\n  // ....\n}\n\ntry (var _ = new Resource()) {\n  // ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7190": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods annotated with \"@BeforeTransaction\" or \"@AfterTransaction\" must respect the contract\nDescription: Why is this an issue?\nIn tests configured with Spring\u2019s\n@Transactional\nannotation, methods annotated with\n@BeforeTransaction\nor\n@AfterTransaction\nmust be void and have no arguments. These methods are executed before or after a transaction, respectively. Deviating\nfrom this contract by having a non-void return type or accepting arguments will cause Spring to throw a runtime error.\nHow to fix it\nEnsure that methods annotated with\n@BeforeTransaction\nor\n@AfterTransaction\nhave a void return type and do not accept any\narguments.\nCode examples\nNoncompliant code example\n```java\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public String setupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public int cleanupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Cleanup logic\n    }\n}\n```\nCompliant solution\n```java\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public void setupTransaction() {\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public void cleanupTransaction() {\n        // Cleanup logic\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7186": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods returning \"Page\" or \"Slice\" must take \"Pageable\" as an input parameter\nDescription: Why is this an issue?\nSpring Data Repository supports paging for queries, allowing you to return results in small, manageable chunks rather than retrieving an entire\nlarge result set.\nThe conventional approach to paginating data in Spring is to use the\nPageable\ninterface to control pagination and to store the query\nresults into a\nPage\nor\nSlice\n. If a query declaration in a\nSpring Data Repository\nreturns a\nPage\nor\nSlice\nwithout taking a\nPageable\nas an input, it raises a runtime exception.\nThis rule raises an issue on queries in a\nRepository\nthat return a\nPage\nor\nSlice\nwithout taking a\nPageable\nas an input.\nHow to fix it\nEnsure that query methods returning a\nPage\nor\nSlice\ninclude a\nPageable\nparameter in their method\nsignature.\nCode examples\nNoncompliant code example\n```java\ninterface ItemRepository extends JpaRepository<Item, Long> {\n    Page<Item> findItems(); //non compliant, no Pageable parameter\n}\n```\nCompliant solution\n```java\ninterface ItemRepository extends JpaRepository<Item, Long> {\n    Page<Item> findItems(Pageable pageable);\n}\n```\nDocumentation\n1. Spring -JPA Query Methods\n2. Spring -Defining Query\n  Methods\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7180": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Cache*\" annotations should only be applied on concrete classes\nDescription: Why is this an issue?\nAnnotating interfaces or interface methods with\n@Cache*\nannotations is not recommended by the official Spring documentation:\n```java\nSpring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Cache* annotations, as opposed to annotating interfaces. You certainly can place an @Cache* annotation on an interface (or an interface method), but this works only if you use the proxy mode (mode=\"proxy\"). If you use the weaving-based aspect (mode=\"aspectj\"), the caching settings are not recognized on interface-level declarations by the weaving infrastructure.\n```\nAlso, when a method is annotated as cacheable inside an interface, if two different implementations of that method exist, the first one to be\ninvoked will populate the cache. Subsequent calls will always return the cached value, even if it\u2019s the other implementation being called.\nWhat is the potential impact?\n1. Confusing Code: Developers may mistakenly believe that caching is in effect, leading to confusion and incorrect assumptions\n  about application performance.\n2. Unreliable Code: Annotating interface methods as@Cacheablehides the cache name from the implementing classes,\n  making it hard to detect where a conflict of names might occur, causing unexpected results at runtime.\nThis rule raises an issue when an interface or an interface method is annotated with a\n@Cache*\nannotation.\nHow to fix it\nMove\n@Cache*\nannotation from interface or interface method to the concrete class.\nCode examples\nNoncompliant code example\n```java\npublic interface ExampleService {\n\n    @Cacheable(\"exampleCache\") // Noncompliant: interface method is annotated with @Cacheable\n    String getData(String id);\n}\n```\nIn the following example, if our application has two different rest APIs to query the most popular animal in two different zoos, the first zoo to\nbe queried will populate the cache.\nCalls to a different API to query the other zoo will produce the same cached output, invalidating our application\u2019s business logic.\n```java\npublic interface Zoo {\n    @Cacheable(\"popAnimal\") //non compliant, interface method is annotated with @Cacheable\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n```\nCompliant solution\n```java\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n\n    @Cacheable(\"exampleCache\")\n    @Override\n    public String getData(String id) {\n        // Implementation here\n    }\n}\n```\nWith the following solution, we are granted that the two implementations will have separate caches.\n```java\npublic interface Zoo {\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    @Cacheable(\"sanDiegoPopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    @Cacheable(\"romePopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7178": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Injecting data into static fields is not supported by Spring\nDescription: Why is this an issue?\nSpring dependency injection framework does not support injecting data into static fields. When @Value, @Inject, or @Autowired are applied to static\nfields, they are ignored.\nWhat is the potential impact?\n1. Null Values: Uninitialized static fields annotated with @Value, @Inject, or @Autowired will not be initialized by Spring,\n  potentially causing NullPointerException at runtime.\n2. Confusing Code: The presence of injection annotations on static fields can mislead developers into believing that the fields\n  will be populated by Spring.\nThis rule raises an issue when a static field is annotated with @Value, @Inject, or @Autowired.\nHow to fix it\nEither use an instance field instead of a static field or remove the @Value, @Inject, or @Autowired annotation and initialize the field.\nCode examples\nNoncompliant code example\n```java\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private static SomeDependency dependency; // non compliant, @Value will be ignored and no value will be injected\n    // ...\n}\n```\nCompliant solution\n```java\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private final SomeDependency dependency;\n    // ...\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-7158": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"String.isEmpty()\" should be used to test for emptiness\nDescription: Why is this an issue?\nCalling\nString.isEmpty()\nclearly communicates the code\u2019s intention, which is to test if the string is empty. Using\nString.length() == 0\nis less direct and makes the code less readable. This preference for\nisEmpty()\nextends to all\nCharSequence\nobjects, including\nStringBuilder\nand\nStringBuffer\n.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\nif (\"string\".length() == 0) { /* \u2026 */ } // Noncompliant\n\nif (\"string\".length() > 0) { /* \u2026 */ } // Noncompliant\n```\n```java\nStringBuilder sb = new StringBuilder();\n...\nif (sb.length() == 0) { /* \u2026 */ } // Noncompliant\n```\nCompliant solution\n```java\nif (\"string\".isEmpty()){ /* \u2026 */ }\n\nif (!\"string\".isEmpty()){ /* \u2026 */ }\n```\n```java\nStringBuilder sb = new StringBuilder();\n...\nif (sb.isEmpty()) { /* \u2026 */ }\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6804": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Value\" annotation should inject property or SpEL expression\nDescription: This rule reports when the Spring\n@Value\nannotation injects a simple value that does not contain an expression.\nWhy is this an issue?\nThe purpose of the\n@Value\nannotation in\norg.springframework.beans.factory.annotation\nis to inject a value into a field or\nmethod based on the Spring context after it has been established.\nIf the annotation does not include an expression (either Spring Expression Language or a property injection), the injected value is a simple\nconstant that does not depend on the Spring context, making the annotation replaceable with a standard field initialization statement.\nThis not only implies the redundant use of\n@Value\n, but could also indicate an error where the expression indicators (\n#\n,\n$\n) were omitted by mistake.\nExceptions\nThis rule does not raise an issue if\n@Value\nis applied to a method or method argument, because the annotation has the side effect that\nthe method is called.\nHow to fix it\n1. If a property is to be injected, use${propertyName}instead ofpropertyName.\n2. If a SpEL expression is to be evaluated, use#{expression}instead ofexpression.\n3. If you intend to initialize a field with a simple value or with an expression that does not depend on the Spring context, use a standard field\n  initialization statement.\nCode examples\nNoncompliant code example\n```java\n@Value(\"catalog.name\") // Noncompliant, this will not inject the property\nString catalog;\n```\nCompliant solution\n```java\n@Value(\"${catalog.name}\") // Compliant\nString catalog;\n```\nNoncompliant code example\n```java\n@Value(\"book.topics[0]\") // Noncompliant, this will not evaluate the expression\nTopic topic;\n```\nCompliant solution\n```java\n@Value(\"#{book.topics[0]}\") // Compliant\nTopic topic;\n```\nNoncompliant code example\n```java\n@Value(\"Hello, world!\") // Noncompliant, this use of @Value is redundant\nString greeting;\n```\nCompliant solution\n```java\nString greeting = \"Hello, world!\"; // Compliant\n```\nDocumentation\n1. Spring\n  Framework API - Annotation Interface Value\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6353": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regular expression quantifiers and character classes should be used concisely\nDescription: Why is this an issue?\nA regular expression is a sequence of characters that specifies a match pattern in text. Among the most important concepts are:\n1. Character classes: defines a set of characters, any one of which can occur in an input string for a match to succeed.\n2. Quantifiers: used to specify how many instances of a character, group, or character class must be present in the input for a match.\n3. Wildcard (.): matches all characters except line terminators (also matches them if thesflag is set).\nMany of these features include shortcuts of widely used expressions, so there is more than one way to construct a regular expression to achieve the\nsame results. For example, to match a two-digit number, one could write\n[0-9]{2,2}\nor\n\\d{2}\n. The latter is not only shorter\nbut easier to read and thus to maintain.\nThis rule recommends replacing some quantifiers and character classes with more concise equivalents:\n1. \\dfor[0-9]and\\Dfor[^0-9]\n2. \\wfor[A-Za-z0-9_]and\\Wfor[^A-Za-z0-9_]\n3. .for character classes matching everything (e.g.[\\w\\W],[\\d\\D], or[\\s\\S]withsflag)\n4. x?forx{0,1},x*forx{0,},x+forx{1,},x{N}forx{N,N}\n```java\n\"[0-9]\"        // Noncompliant - same as \"\\\\d\"\n\"[^0-9]\"       // Noncompliant - same as \"\\\\D\"\n\"[A-Za-z0-9_]\" // Noncompliant - same as \"\\\\w\"\n\"[\\\\w\\\\W]\"     // Noncompliant - same as \".\"\n\"a{0,}\"        // Noncompliant - same as \"a*\"\n```\nUse the more concise version to make the regex expression more readable.\n```java\n\"\\\\d\"\n\"\\\\D\"\n\"\\\\w\"\n\".\"\n\"a*\"\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6262": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: AWS region should not be set with a hardcoded String\nDescription: Why is this an issue?\nWhen explicitly setting the region on an AWS Client, you should always prefer providing the value from the Enum\nRegions\ninstead of a hardcoded String.\nThis will allow you to transparently support any change in the API and avoid mistakes.\nThis rule reports an issue when a hardcoded string is used instead of an available enum value.\nNoncompliant code example\n```java\nAmazonS3ClientBuilder.standard().withRegion(\"eu_west_1\").build();\n```\nCompliant solution\n```java\nAmazonS3ClientBuilder.standard().withRegion(Regions.EU_WEST_1).build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6246": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas should not invoke other lambdas synchronously\nDescription: Why is this an issue?\nInvoking other Lambdas synchronously from a Lambda is a scalability anti-pattern. Lambdas have a maximum execution time before they timeout (15\nminutes as of May 2021). Having to wait for another Lambda to finish its execution could lead to a timeout.\nA better solution is to generate\u00a0events that can be consumed asynchronously by other Lambdas.\nNoncompliant code example\nWith AWS SDKv1\n```java\nInvokeRequest invokeRequest = new InvokeRequest()\n         .withFunctionName(\"myFunction\");\n\nAWSLambda awsLambda = AWSLambdaClientBuilder.standard()\n\t\t.withCredentials(new ProfileCredentialsProvider())\n\t\t.withRegion(Regions.US_WEST_2).build();\n\nawsLambda.invoke(invokeRequest); // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6244": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Consumer Builders should be used\nDescription: Why is this an issue?\nSome API, like the AWS SDK, heavily rely on the builder pattern to create different data structures. Despite all the benefits, this pattern can\nbecome really verbose, especially when dealing with nested structures. In order to reach a more concise code, \"Consumer Builders\", also called\n\"Consumer Interface\" are often introduced.\nThe idea is to overload the methods taking others structures in a Builder with a Consumer of Builder instead. This enables to use a lambda instead\nof nesting another Builder, resulting in more concise and readable code.\nThis rule reports an issue when the Consumer Builder methods could be used instead of the classical ones.\nNoncompliant code example\n```java\nSendEmailRequest.builder()\n  .destination(Destination.builder()\n    .toAddresses(\"to-email@domain.com\")\n    .bccAddresses(\"bcc-email@domain.com\")\n    .build())\n.build();\n```\nCompliant solution\n```java\nSendEmailRequest.builder()\n  .destination(d -> d.toAddresses(\"to-email@domain.com\").bccAddresses(\"bcc-email@domain.com\"))\n  .build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6219": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: 'serialVersionUID' field should not be set to '0L' in records\nDescription: Why is this an issue?\nIn Records serialization is not done the same way as for ordinary serializable or externalizable classes. Records serialization does not rely on\nthe\nserialVersionUID\nfield, because the requirement to have this field equal is waived for record classes. By default, all records will\nhave this field equal to\n0L\nand there is no need to specify this field with\n0L\nvalue and it is possible to specify it with\nsome custom value to support serialization/deserialization involving ordinary classes.\nThis rule raises an issue when there is a\nprivate static final long serialVersionUID\nfield which is set to\n0L\nin a Record\nclass.\nNoncompliant code example\n```java\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 0L; // Noncompliant\n}\n```\nCompliant solution\n```java\nrecord Person(String name, int age) implements Serializable {} // Compliant\n\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 42L; // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6217": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Permitted types of a sealed class should be omitted if they are declared in the same file\nDescription: Why is this an issue?\nsealed\nclasses were introduced in Java 17. This feature is very useful if there is a need to define a strict hierarchy and restrict\nthe possibility of extending classes. In order to mention all the allowed subclasses, there is a keyword\npermits\n, which should be\nfollowed by subclasses' names.\nThis notation is quite useful if subclasses of a given\nsealed\nclass can be found in different files, packages, or even modules. In\ncase when all subclasses are declared in the same file there is no need to mention the explicitly and\npermits\npart of a declaration can\nbe omitted.\nThis rule reports an issue if all subclasses of a\nsealed\nclass are declared in the same file as their superclass.\nNoncompliant code example\n```java\nsealed class A permits B, C, D, E {} // Noncompliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n```\nCompliant solution\n```java\nsealed class A {} // Compliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6205": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Switch arrow labels should not use redundant keywords\nDescription: Why is this an issue?\nIn Switch Expressions, an arrow label consisting of a block with a single\nyield\ncan be simplified to directly return the value,\nresulting in cleaner code.\nSimilarly, for Switch Statements and arrow labels, a\nbreak\nin a block is always redundant and should not be used. Furthermore, if the\nresulting block contains only one statement, the curly braces of that block can also be omitted.\nThis rule reports an issue when a case of a Switch Expression contains a block with a single\nyield\nor when a Switch Statement contains\na block with a\nbreak\n.\nNoncompliant code example\n```java\nint i = switch (mode) {\n  case \"a\" -> {        // Noncompliant: Remove the redundant block and yield.\n    yield 1;\n  }\n  default -> {         // Noncompliant: Remove the redundant block and yield.\n    yield 2;\n  }\n};\n\nswitch (mode) {\n  case \"a\" -> {        // Noncompliant: Remove the redundant block and break.\n    result = 1;\n    break;\n  }\n  default -> {         // Noncompliant: Remove the redundant break.\n    doSomethingElse();\n    result = 2;\n    break;\n  }\n}\n```\nCompliant solution\n```java\nint i = switch (mode) {\n  case \"a\" -> 1;\n  default -> 2;\n};\n\nswitch (mode) {\n  case \"a\" -> result = 1;\n  default -> {\n   doSomethingElse();\n   result = 2;\n }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6203": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Text blocks should not be used in complex expressions\nDescription: Why is this an issue?\nIn Java 15 Text Blocks are official and can be used just like an ordinary String. However, when they are used to represent a big chunk of text,\nthey should not be used directly in complex expressions, as it decreases the readability. In this case, it is better to extract the text block into a\nvariable or a field.\nThis rule reports an issue when a text block longer than a number of lines given as a parameter is directly used within a lambda expression.\nNoncompliant code example\n```java\nlistOfString.stream()\n  .map(str -> !\"\"\"\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n      <parent>\n        <groupId>com.mycompany.app</groupId>\n        <artifactId>my-app</artifactId>\n        <version>1</version>\n      </parent>\n\n      <groupId>com.mycompany.app</groupId>\n      <artifactId>my-module</artifactId>\n      <version>1</version>\n    </project>\n    \"\"\".equals(str));\n```\nCompliant solution\n```java\nString myTextBlock = \"\"\"\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n      <parent>\n        <groupId>com.mycompany.app</groupId>\n        <artifactId>my-app</artifactId>\n        <version>1</version>\n      </parent>\n\n      <groupId>com.mycompany.app</groupId>\n      <artifactId>my-module</artifactId>\n      <version>1</version>\n    </project>\n    \"\"\";\n\nlistOfString.stream()\n  .map(str -> !myTextBlock.equals(str));\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6201": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Pattern Matching for \"instanceof\" operator should be used instead of simple \"instanceof\" + cast\nDescription: Why is this an issue?\nIn Java 16, the feature \"Pattern matching for instanceof\" is finalized and can\u00a0be used in production. Previously developers needed to do 3\noperations in order to do this: check the variable type, cast it and assign the casted value to the new variable. This approach is quite verbose and\ncan be replaced with pattern matching for\ninstanceof\n, doing these 3 actions (check, cast and assign) in one expression.\nThis rule raises an issue when an\ninstanceof\ncheck followed by a cast and an assignment could be replaced by pattern matching.\nNoncompliant code example\n```java\nint f(Object o) {\n  if (o instanceof String) {\u00a0 // Noncompliant\n    String string = (String) o;\n    return string.length();\n  }\n  return 0;\n}\n```\nCompliant solution\n```java\nint f(Object o) {\n\u00a0 if (o instanceof String string) {\u00a0 // Compliant\n\u00a0 \u00a0 return string.length();\n\u00a0 }\n\u00a0 return 0;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-6068": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Call to Mockito method \"verify\", \"when\" or \"given\" should be simplified\nDescription: Why is this an issue?\nMockito provides\nargument matchers\nfor flexibly stubbing or verifying method calls.\nMockito.verify()\n,\nMockito.when()\n,\nStubber.when()\nand\nBDDMockito.given()\neach have overloads\nwith and without argument matchers.\nHowever, the default matching behavior (i.e. without argument matchers) uses\nequals()\n. If only the matcher\norg.mockito.ArgumentMatchers.eq()\nis used, the call is equivalent to the call without matchers, i.e. the\neq()\nis not\nnecessary and can be omitted. The resulting code is shorter and easier to read.\nNoncompliant code example\n```java\n@Test\npublic void myTest() {\n  given(foo.bar(eq(v1), eq(v2), eq(v3))).willReturn(null);   // Noncompliant\n  when(foo.baz(eq(v4), eq(v5))).thenReturn(\"foo\");   // Noncompliant\n  doThrow(new RuntimeException()).when(foo).quux(eq(42));    // Noncompliant\n  verify(foo).bar(eq(v1), eq(v2), eq(v3));   // Noncompliant\n}\n```\nCompliant solution\n```java\n@Test\npublic void myTest() {\n  given(foo.bar(v1, v2, v3)).willReturn(null);\n  when(foo.baz(v4, v5)).thenReturn(\"foo\");\n  doThrow(new RuntimeException()).when(foo).quux(42);\n  verify(foo).bar(v1, v2, v3);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5867": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unicode-aware versions of character classes should be preferred\nDescription: Why is this an issue?\nWhen using POSIX classes like\n\\p{Alpha}\nwithout the\nUNICODE_CHARACTER_CLASS\nflag or when using hard-coded character\nclasses like\n\"[a-zA-Z]\"\n, letters outside of the ASCII range, such as umlauts, accented letters or letter from non-Latin languages, won\u2019t\nbe matched. This may cause code to incorrectly handle input containing such letters.\nTo correctly handle non-ASCII input, it is recommended to use Unicode classes like\n\\p{IsAlphabetic}\n. When using POSIX classes, Unicode\nsupport should be enabled by either passing\nPattern.UNICODE_CHARACTER_CLASS\nas a flag to\nPattern.compile\nor by using\n(?U)\ninside the regex.\nNoncompliant code example\n```java\nPattern.compile(\"[a-zA-Z]\");\nPattern.compile(\"\\\\p{Alpha}\");\n```\nCompliant solution\n```java\nPattern.compile(\"\\\\p{IsAlphabetic}\"); // matches all letters from all languages\nPattern.compile(\"\\\\p{IsLatin}\"); // matches latin letters, including umlauts and other non-ASCII variations\nPattern.compile(\"\\\\p{Alpha}\", Pattern.UNICODE_CHARACTER_CLASS);\nPattern.compile(\"(?U)\\\\p{Alpha}\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5857": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Character classes should be preferred over reluctant quantifiers in regular expressions\nDescription: Why is this an issue?\nUsing reluctant quantifiers (also known as lazy or non-greedy quantifiers) in patterns can often lead to needless backtracking, making the regex\nneedlessly inefficient and potentially vulnerable to\ncatastrophic backtracking\n.\nParticularly when using\n.*?\nor\n.+?\nto match anything up to some terminating character, it is usually a better idea to\ninstead use a greedily or possessively quantified negated character class containing the terminating character. For example\n<.+?>\nshould be replaced with\n<[^>]++>\n.\nNoncompliant code example\n```java\n<.+?>\n\".*?\"\n```\nCompliant solution\n```java\n<[^>]++>\n\"[^\"]*+\"\n```\nor\n```java\n<[^>]+>\n\"[^\"]*\"\n```\nExceptions\nThis rule only applies in cases where the reluctant quantifier can easily be replaced with a negated character class. That means the repetition has\nto be terminated by a single character or character class. Patterns such as the following, where the alternatives without reluctant quantifiers are\nmore complicated, are therefore not subject to this rule:\n```java\n<!--.*?-->\n/\\*.*?\\*/\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5853": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Consecutive AssertJ \"assertThat\" statements should be chained\nDescription: Why is this an issue?\nAssertJ assertions methods targeting the same object can be chained instead of using multiple\nassertThat\n. It avoids duplication and\nincreases the clarity of the code.\nThis rule raises an issue when multiples\nassertThat\ntarget the same tested value.\nNoncompliant code example\n```java\nassertThat(someList).hasSize(3);\nassertThat(someList).contains(\"something\");\n```\nCompliant solution\n```java\nassertThat(someList)\n  .hasSize(3)\n  .contains(\"something\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5838": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Chained AssertJ assertions should be simplified to the corresponding dedicated assertion\nDescription: Why is this an issue?\nAssertJ contains many assertions methods specific to common types. Both versions will test the same things, but the dedicated one will provide a\nbetter error message, simplifying the debugging process.\nThis rule reports an issue when an assertion can be simplified to a dedicated one.\nThe array below gives a non-exhaustive list of assertion reported by the rule. Code behaving similarly, or with a negation will also be\nreported.\nOriginal\nDedicated\nRelated to Object\nassertThat(getObject()).isEqualTo(null)\nassertThat(getObject()).isNull()\nassertThat(getBoolean()).isEqualTo(true)\nassertThat(getBoolean()).isTrue()\nassertThat(getBoolean()).isEqualTo(false)\nassertThat(getBoolean()).isFalse()\nassertThat(x.equals(y)).isTrue()\nassertThat(x).isEqualTo(y)\nassertThat(x == y).isTrue()\nassertThat(x).isSameAs(y)\nassertThat(x == null).isTrue()\nassertThat(x).isNull()\nassertThat(x.toString()).isEqualTo(y)\nassertThat(x).hasToString(y)\nassertThat(x.hashCode()).isEqualTo(y.hashCode())\nassertThat(x).hasSameHashCodeAs(y)\nassertThat(getObject() instanceof MyClass).isTrue()\nassertThat(getObject()).isInstanceOf(MyClass.class)\nRelated to\nComparable\nassertThat(x.compareTo(y)).isZero()\nassertThat(x).isEqualByComparingTo(y)\nassertThat(x >= y).isTrue()\nassertThat(x).isGreaterThanOrEqualTo(y)\nassertThat(x > y).isTrue()\nassertThat(x).isGreaterThan(y)\nassertThat(x <= y).isTrue()\nassertThat(x).isLessThanOrEqualTo(y)\nassertThat(x < y).isTrue()\nassertThat(x).isLessThan(y)\nRelated to\nString\nassertThat(getString().isEmpty()).isTrue()\nassertThat(getString()).isEmpty()\nassertThat(getString()).hasSize(0)\nassertThat(getString()).isEmpty()\nassertThat(getString().equals(expected)).isTrue()\nassertThat(getString()).isEqualTo(expected)\nassertThat(getString().equalsIgnoreCase(expected)).isTrue()\nassertThat(getString()).isEqualToIgnoringCase(expected)\nassertThat(getString().contains(expected)).isTrue()\nassertThat(getString()).contains(expected)\nassertThat(getString().startsWith(expected)).isTrue()\nassertThat(getString()).startsWith(expected)\nassertThat(getString().endsWith(expected)).isTrue()\nassertThat(getString()).endsWith(expected)\nassertThat(getString().matches(expected)).isTrue()\nassertThat(getString()).matches(expected)\nassertThat(getString().trim()).isEmpty()\nassertThat(getString()).isBlank()\nassertThat(getString().length()).isEqualTo(length)\nassertThat(getString()).hasSize(length)\nassertThat(getString().length()).hasSize(expected.length())\nassertThat(getString()).hasSameSizeAs(expected)\nRelated to\nFile\nassertThat(getFile()).hasSize(0)\nassertThat(getFile()).isEmpty()\nassertThat(getFile().length()).isZero()\nassertThat(getFile()).isEmpty()\nassertThat(getFile().length()).isEqualTo(length)\nassertThat(getFile()).hasSize(length)\nassertThat(getFile().canRead()).isTrue()\nassertThat(getFile()).canRead()\nassertThat(getFile().canWrite()).isTrue()\nassertThat(getFile()).canWrite()\nassertThat(getFile().exists()).isTrue()\nassertThat(getFile()).exists()\nassertThat(getFile().getName()).isEqualTo(name)\nassertThat(getFile()).hasName(name)\nassertThat(getFile().getParent()).isEqualTo(pathname)\nassertThat(getFile()).hasParent(pathname)\nassertThat(getFile().getParentFile()).isNull()\nassertThat(getFile()).hasNoParent()\nassertThat(getFile().isAbsolute()).isTrue()\nassertThat(getFile()).isAbsolute()\nassertThat(getFile().isAbsolute()).isFalse()\nassertThat(getFile()).isRelative()\nassertThat(getFile().isDirectory()).isTrue()\nassertThat(getFile()).isDirectory()\nassertThat(getFile().isFile()).isTrue()\nassertThat(getFile()).isFile()\nassertThat(getFile().list()).isEmpty()\nassertThat(getFile()).isEmptyDirectory()\nRelated to\nPath\nassertThat(getPath().startsWith(path)).isTrue()\nassertThat(getPath()).startsWithRaw(path)\nassertThat(getPath().endsWith(path)).isTrue()\nassertThat(getPath()).endsWithRaw(path)\nassertThat(getPath().getParent()).isEqualTo(name)\nassertThat(getPath()).hasParentRaw(name)\nassertThat(getPath().getParent()).isNull()\nassertThat(getPath()).hasNoParentRaw()\nassertThat(getPath().isAbsolute()).isTrue()\nassertThat(getPath()).isAbsolute()\nassertThat(getPath().isAbsolute()).isFalse()\nassertThat(getPath()).isRelative()\nRelated to\nArray\nassertThat(getArray().length).isZero()\nassertThat(getArray()).isEmpty()\nassertThat(getArray().length).isEqualTo(length)\nassertThat(getArray()).hasSize(length)\nassertThat(getArray().length).isEqualTo(anotherArray.length)\nassertThat(getArray()).hasSameSizeAs(anotherArray)\nassertThat(getArray().length).isLessThanOrEqualTo(expression)\nassertThat(getArray()).hasSizeLessThanOrEqualTo(expression)\nassertThat(getArray().length).isLessThan(expression)\nassertThat(getArray()).hasSizeLessThan(expression)\nassertThat(getArray().length).isGreaterThan(expression)\nassertThat(getArray()).hasSizeGreaterThan(expression)\nassertThat(getArray().length).isGreaterThanOrEqualTo(expression)\nassertThat(getArray()).hasSizeGreaterThanOrEqualTo(expression)\nRelated to\nCollection\nassertThat(getCollection().isEmpty()).isTrue()\nassertThat(getCollection()).isEmpty()\nassertThat(getCollection().size()).isZero()\nassertThat(getCollection()).isEmpty()\nassertThat(getCollection().contains(something)).isTrue()\nassertThat(getCollection()).contains(something)\nassertThat(getCollection().containsAll(otherCollection)).isTrue()\nassertThat(getCollection()).containsAll(otherCollection)\nRelated to\nMap\nassertThat(getMap().size()).isEqualTo(otherMap().size()\nassertThat(getMap()).hasSameSizeAs(otherMap())\nassertThat(getMap().containsKey(key)).isTrue()\nassertThat(getMap()).containsKey(key)\nassertThat(getMap().keySet()).contains(key)\nassertThat(getMap()).containsKey(key)\nassertThat(getMap().keySet()).containsOnlyKey(key)\nassertThat(getMap()).containsOnlyKey(key)\nassertThat(getMap().containsValue(value)).isTrue()\nassertThat(getMap()).containsValue(value)\nassertThat(getMap().values()).contains(value)\nassertThat(getMap()).containsValue(value)\nassertThat(getMap().get(key)).isEqualTo(value)\nassertThat(getMap()).containsEntry(key, value)\nRelated to\nOptional\nassertThat(getOptional().isPresent()).isTrue()\nassertThat(getOptional()).isPresent()\nassertThat(getOptional().get()).isEqualTo(something)\nassertThat(getOptional()).contains(something)\nassertThat(getOptional().get()).isSameAs(something)\nassertThat(getOptional()).containsSame(something)\nNoncompliant code example\n```java\nassertThat(getObject()).isEqualTo(null); // Noncompliant\nassertThat(getObject()).isNotEqualTo(null); // Noncompliant - not listed above but also supported\n\nassertThat(getString().trim()).isEmpty();\nassertThat(getFile().canRead()).isTrue();\nassertThat(getPath().getParent()).isNull();\n```\nCompliant solution\n```java\nassertThat(getObject()).isNull();\nassertThat(getObject()).isNotNull();\n\nassertThat(getString()).isBlank();\nassertThat(getFile()).canRead();\nassertThat(getPath()).hasNoParentRaw();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5777": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception testing via JUnit @Test annotation should be avoided\nDescription: Why is this an issue?\nWhen testing exception via\n@Test\nannotation, having additional assertions inside that test method can be problematic because any code\nafter the raised exception will not be executed. It will prevent you to test the state of the program after the raised exception and, at worst, make\nyou\u00a0misleadingly think that it is executed.\nYou should consider moving any assertions into a separate test method where possible, or using\norg.junit.Assert.assertThrows\ninstead.\nAlternatively, you could use\ntry-catch idiom\nfor JUnit\nversion < 4.13 or if your project does not support lambdas.\nNoncompliant code example\n```java\n@Test(expected = IndexOutOfBoundsException.class)\npublic void testShouldFail() {\n  get();\n  // This test pass since execution will never get past this line.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n```\nCompliant solution\n1. For JUnit >= 4.13, useorg.junit.Assert.assertThrows:\n```java\n// This test correctly fails.\n@Test\npublic void testToString() {\n    Object obj = get();\n    Assert.assertThrows(IndexOutOfBoundsException.class, () -> obj.toString());\n    Assert.assertEquals(0, 1);\n}\n```\n1. For JUnit < 4.13, use thetry-catch idiom:\n```java\n@Test\npublic void testShouldFail() {\n    Object obj = get();\n    try {\n        obj.toString();\n        Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n    } catch (IndexOutOfBoundsException e) {}\n    Assert.assertEquals(0, 1); // Correctly fails.\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5665": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Escape sequences should not be used in text blocks\nDescription: Why is this an issue?\nThe use of escape sequences is mostly unnecessary in text blocks.\nNoncompliant code example\n\\n\ncan be replaced by simply introducing the newline,\n\\\"\\\"\\\"\nit is sufficient to escape only the first qoute.\n```java\nString textBlock = \"\"\"\n        \\\"\\\"\\\" this \\nis\n        text  block!\n        !!!!\n      \"\"\";\n```\nCompliant solution\n```java\nString textBlock = \"\"\"\n        \\\"\"\" this\n        is\n        text  block!\n        !!!!\n      \"\"\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5663": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Simple string literal should be used for single line strings\nDescription: Why is this an issue?\nIf a string fits on a single line, without concatenation and escaped newlines, you should probably continue to use a string literal.\nNoncompliant code example\n```java\nString question = \"\"\"\n              What's the point, really?\"\"\";\n```\nCompliant solution\n```java\nString question = \"What's the point, really?\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5411": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Avoid using boxed \"Boolean\" types directly in boolean expressions\nDescription: Why is this an issue?\nWhen boxed type\njava.lang.Boolean\nis used as an expression to determine the control flow (as described in\nJava Language Specification \u00a74.2.5 The\nboolean\nType and\nboolean Values\n) it will throw a\nNullPointerException\nif the value is\nnull\n(as defined in\nJava Language Specification \u00a75.1.8 Unboxing Conversion\n).\nIt is safer to avoid such conversion altogether and handle the\nnull\nvalue explicitly.\nNote, however, that no issues will be raised for Booleans that have already been null-checked or are marked\n@NonNull/@NotNull\n.\nNoncompliant code example\n```java\nBoolean b = getBoolean();\nif (b) {  // Noncompliant, it will throw NPE when b == null\n  foo();\n} else {\n  bar();\n}\n```\nCompliant solution\n```java\nBoolean b = getBoolean();\nif (Boolean.TRUE.equals(b)) {\n  foo();\n} else {\n  bar();  // will be invoked for both b == false and b == null\n}\n\n\nBoolean b = getBoolean();\nif(b != null){\n  String test = b ? \"test\" : \"\";\n}\n```\nExceptions\nThe issue is not raised if the expression is annotated\n@NonNull\n/\n@NotNull\n. This is useful if a boxed type is an\ninstantiation of a generic type parameter and cannot be avoided.\n```java\nList<Boolean> list = new ArrayList<>();\nlist.add(true);\nlist.add(false);\nlist.forEach((@NonNull Boolean value) -> {\n  // Compliant\n  if(value) {\n    System.out.println(\"yes\");\n  }\n});\n\n@NonNull Boolean someMethod() { /* ... */ }\n\n// Compliant\nif(someMethod()) { /* ... */ }\n\n@NonNull Boolean boxedNonNull = Boolean.TRUE;\n\n// Compliant\nif(boxedNonNull) { /* ... */ }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-5194": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use Java 14 \"switch\" expression\nDescription: Why is this an issue?\nMany existing switch statements are essentially simulations of switch expressions, where each arm either assigns to a common target variable or\nreturns a value. Expressing this as a statement is roundabout, repetitive, and error-prone.\nJava 14 added support for switch expressions, which provide more succinct and less error-prone version of switch.\nNoncompliant code example\n```java\nvoid day_of_week(DoW day) {\n    int numLetters;\n    switch (day) {  // Noncompliant\n      case MONDAY:\n      case FRIDAY:\n      case SUNDAY:\n        numLetters = 6;\n        break;\n      case TUESDAY:\n        numLetters = 7;\n        break;\n      case THURSDAY:\n      case SATURDAY:\n        numLetters = 8;\n        break;\n      case WEDNESDAY:\n        numLetters = 9;\n        break;\n      default:\n        throw new IllegalStateException(\"Wat: \" + day);\n    }\n}\n\nint return_switch(int x) {\n    switch (x) { // Noncompliant\n      case 1:\n        return 1;\n      case 2:\n        return 2;\n      default:\n        throw new IllegalStateException();\n    }\n}\n```\nCompliant solution\n```java\nint numLetters = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -> 6;\n    case TUESDAY                -> 7;\n    case THURSDAY, SATURDAY     -> 8;\n    case WEDNESDAY              -> 9;\n};\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4977": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Type parameters should not shadow other type parameters\nDescription: Why is this an issue?\nShadowing makes it impossible to use the type parameter from the outer scope. Also, it can be confusing to distinguish which type parameter is\nbeing used.\nThis rule raises an issue when a type parameter from an inner scope uses the same name as one in an outer scope.\nNoncompliant code example\n```java\npublic class TypeParameterHidesAnotherType<T> {\n\n    public class Inner<T> { // Noncompliant\n      //...\n    }\n\n    private <T> T method() { // Noncompliant\n      return null;\n    }\n\n  }\n```\nCompliant solution\n```java\npublic class NoTypeParameterHiding<T> {\n\n    public class Inner<S> { // Compliant\n      List<S> listOfS;\n    }\n\n    private <V> V method() { // Compliant\n      return null;\n    }\n\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4968": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The upper bound of type variables and wildcards should not be \"final\" \nDescription: Why is this an issue?\nWhen a type variable or a wildcard declares an upper bound that is\nfinal\n, the parametrization is not generic at all because it accepts\none and only one type at runtime: the one that is\nfinal\n. Instead of using\nGenerics\n, it\u2019s simpler to directly use the\nconcrete\nfinal\nclass.\nNoncompliant code example\n```java\npublic static <T extends String> T getMyString() { // Noncompliant; String is a \"final\" class and so can't be extended\n [...]\n}\n```\nCompliant solution\n```java\npublic static String getMyString() { // Compliant\n  [...]\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4929": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"read(byte[],int,int)\" should be overridden\nDescription: Why is this an issue?\nWhen directly subclassing\njava.io.InputStream\nor\njava.io.FilterInputStream\n, the only requirement is that you implement\nthe method\nread()\n. However most uses for such streams don\u2019t read a single byte at a time and the default implementation for\nread(byte[],int,int)\nwill call\nread(int)\nfor every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\nread(byte[],int,int)\n.\nThis rule raises an issue when a direct subclass of\njava.io.InputStream\nor\njava.io.FilterInputStream\ndoesn\u2019t provide an\noverride of\nread(byte[],int,int)\n.\nNoncompliant code example\n```java\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n}\n```\nCompliant solution\n```java\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    return fin.read(b, off, len);\n  }\n}\n```\nExceptions\nThis rule doesn\u2019t raise an issue when the class is declared\nabstract\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4926": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"serialVersionUID\" should not be declared blindly\nDescription: Why is this an issue?\nProviding a\nserialVersionUID\nfield on\nSerializable\nclasses is strongly recommended by the\nSerializable\ndocumentation but blindly following that recommendation can be harmful.\nserialVersionUID\nvalue is stored with the serialized data and this field is verified when deserializing the data to ensure that the\ncode reading the data is compatible with the serialized data. In case of failure, it means the serialized data and the code are not in sync and this\nfine because you know what\u2019s wrong.\nWhen the\nserialVersionUID\nis generated by an IDE or blindly hard-coded, there is a high probability that one will forget to update the\nserialVersionUID\nvalue when the\nSerializable\nclass is later enriched with additional fields. As a consequence, old\nserialized data will incorrectly be considered compatible with the newer version of the code creating situations which are hard to debug.\nTherefore, defining\nserialVersionUID\nshould be done with care. This rule raises an issue on each\nserialVersionUID\nfield\ndeclared on classes implementing\nSerializable\nto be sure the presence and the value of the\nserialVersionUID\nfield is\nchallenged and validated by the team.\nNoncompliant code example\n```java\npublic class Foo implements Serializable {\n  private static final long serialVersionUID = 1;\n}\n\npublic class BarException extends RuntimeException {\n  private static final long serialVersionUID = 8582433437601788991L;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4838": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An iteration on a Collection should be performed on the type handled by the Collection\nDescription: Why is this an issue?\nWhen iterating over an\nIterable\nwith a\nfor\nloop, the iteration variable could have the same type as the type returned by\nthe iterator (the item type of the\nIterable\n). This rule reports when a supertype of the item type is used for the variable instead, but\nthe variable is then explicitly downcast in the loop body.\nUsing explicit type casts instead of leveraging the language\u2019s type system is a bad practice. It disables static type checking by the compiler for\nthe cast expressions, but potential errors will throw a\nClassCastException\nduring runtime instead.\nHow to fix it\nCode examples\nNoncompliant code example\nWhen declaring the iteration variable, use the item type for it instead of a supertype. Remove the explicit downcasts in the loop body.\n```java\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n```\nCompliant solution\n```java\nfor (Person person : getPersons()) { // Compliant\n  person.getAddress();\n}\n```\nNoncompliant code example\nAlternatively, use the\nvar\nkeyword to automatically infer the variable type (since Java 10).\n```java\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n```\nCompliant solution\n```java\nfor (var person : getPersons()) { // Compliant\n  person.getAddress();\n}\n```\nCompliant solution\nThe implicit upcast in the loop header is not reported when there is no downcast in the loop body.\n```java\nfor (Object item : getPersons()) { // Compliant\n  System.out.println(item);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4719": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"StandardCharsets\" constants should be preferred\nDescription: Why is this an issue?\nJDK7 introduced the class\njava.nio.charset.StandardCharsets\n. It provides constants for all charsets that are guaranteed to be\navailable on every implementation of the Java platform.\n1. ISO_8859_1\n2. US_ASCII\n3. UTF_16\n4. UTF_16BE\n5. UTF_16LE\n6. UTF_8\nThese constants should be preferred to:\n1. the use of a String such as \"UTF-8\" which has the drawback of requiring thecatch/throwof anUnsupportedEncodingExceptionthat will never actually happen\n2. the use of Guava\u2019sCharsetsclass, which has been obsolete since JDK7\nNoncompliant code example\n```java\ntry {\n  byte[] bytes = string.getBytes(\"UTF-8\"); // Noncompliant; use a String instead of StandardCharsets.UTF_8\n} catch (UnsupportedEncodingException e) {\n  throw new AssertionError(e);\n}\n// ...\nbyte[] bytes = string.getBytes(Charsets.UTF_8); // Noncompliant; Guava way obsolete since JDK7\n```\nCompliant solution\n```java\nbyte[] bytes = string.getBytes(StandardCharsets.UTF_8)\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4682": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@CheckForNull\" or \"@Nullable\" should not be used on primitive types\nDescription: Why is this an issue?\nBy definition, primitive types are not Objects and so they cannot be\nnull\n. Adding\n@CheckForNull\nor\n@Nullable\non primitive types is redundant and may lead to misunderstandings.\nThis rule raises an issue when\n@CheckForNull\nor\n@Nullable\nis set on a method returning a primitive type: byte, short,\nint, long, float, double, boolean, char.\nNoncompliant code example\n```java\n@CheckForNull\nboolean isFoo() {\n ...\n}\n```\nCompliant solution\n```java\nboolean isFoo() {\n ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4488": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Composed \"@RequestMapping\" variants should be preferred\nDescription: Why is this an issue?\nSpring framework 4.3 introduced variants of the\n@RequestMapping\nannotation to better represent the semantics of the annotated methods.\nThe use of\n@GetMapping\n,\n@PostMapping\n,\n@PutMapping\n,\n@PatchMapping\nand\n@DeleteMapping\nshould be preferred to the use of the raw\n@RequestMapping(method = RequestMethod.XYZ)\n.\nNoncompliant code example\n```java\n@RequestMapping(path = \"/greeting\", method = RequestMethod.GET) // Noncompliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n```\nCompliant solution\n```java\n@GetMapping(path = \"/greeting\") // Compliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4349": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"write(byte[],int,int)\" should be overridden\nDescription: Why is this an issue?\nWhen directly subclassing\njava.io.OutputStream\nor\njava.io.FilterOutputStream\n, the only requirement is that you implement\nthe method\nwrite(int)\n. However most uses for such streams don\u2019t write a single byte at a time and the default implementation for\nwrite(byte[],int,int)\nwill call\nwrite(int)\nfor every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\nwrite(byte[],int,int)\n.\nThis rule raises an issue when a direct subclass of\njava.io.OutputStream\nor\njava.io.FilterOutputStream\ndoesn\u2019t provide an\noverride of\nwrite(byte[],int,int)\n.\nNoncompliant code example\n```java\npublic class MyStream extends OutputStream { // Noncompliant\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n```\nCompliant solution\n```java\npublic class MyStream extends OutputStream {\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        fout.write(b, off, len);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n```\nExceptions\nThis rule doesn\u2019t raise an issue when the class is declared\nabstract\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4276": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Functional Interfaces should be as specialised as possible\nDescription: Why is this an issue?\nThe\njava.util.function\npackage provides a large array of functional interface definitions for use in lambda expressions and method\nreferences. In general it is recommended to use the more specialised form to avoid auto-boxing. For instance\nIntFunction<Foo>\nshould be preferred over\nFunction<Integer, Foo>\n.\nThis rule raises an issue when any of the following substitution is possible:\nCurrent Interface\nPreferred Interface\nFunction<Integer, R>\nIntFunction<R>\nFunction<Long, R>\nLongFunction<R>\nFunction<Double, R>\nDoubleFunction<R>\nFunction<Double,Integer>\nDoubleToIntFunction\nFunction<Double,Long>\nDoubleToLongFunction\nFunction<Long,Double>\nLongToDoubleFunction\nFunction<Long,Integer>\nLongToIntFunction\nFunction<R,Integer>\nToIntFunction<R>\nFunction<R,Long>\nToLongFunction<R>\nFunction<R,Double>\nToDoubleFunction<R>\nFunction<T,T>\nUnaryOperator<T>\nBiFunction<T,T,T>\nBinaryOperator<T>\nConsumer<Integer>\nIntConsumer\nConsumer<Double>\nDoubleConsumer\nConsumer<Long>\nLongConsumer\nBiConsumer<T,Integer>\nObjIntConsumer<T>\nBiConsumer<T,Long>\nObjLongConsumer<T>\nBiConsumer<T,Double>\nObjDoubleConsumer<T>\nPredicate<Integer>\nIntPredicate\nPredicate<Double>\nDoublePredicate\nPredicate<Long>\nLongPredicate\nSupplier<Integer>\nIntSupplier\nSupplier<Double>\nDoubleSupplier\nSupplier<Long>\nLongSupplier\nSupplier<Boolean>\nBooleanSupplier\nUnaryOperator<Integer>\nIntUnaryOperator\nUnaryOperator<Double>\nDoubleUnaryOperator\nUnaryOperator<Long>\nLongUnaryOperator\nBinaryOperator<Integer>\nIntBinaryOperator\nBinaryOperator<Long>\nLongBinaryOperator\nBinaryOperator<Double>\nDoubleBinaryOperator\nFunction<T, Boolean>\nPredicate<T>\nBiFunction<T,U,Boolean>\nBiPredicate<T,U>\nNoncompliant code example\n```java\npublic class Foo implements Supplier<Integer> {  // Noncompliant\n    @Override\n    public Integer get() {\n      // ...\n    }\n}\n```\nCompliant solution\n```java\npublic class Foo implements IntSupplier {\n\n  @Override\n  public int getAsInt() {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4266": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream.collect()\" calls should not be redundant\nDescription: Why is this an issue?\nWhen using the\nStream\nAPI, call chains should be simplified as much as possible to improve readability and maintainability.\nThis rule raises an issue when one of the following substitution can be made:\nOriginal\nPreferred\nstream.collect(counting())\nstream.count()\nstream.collect(maxBy(comparator))\nstream.max(comparator)\nstream.collect(minBy(comparator))\nstream.min(comparator)\nstream.collect(mapping(mapper))\nstream.map(mapper).collect()\nstream.collect(reducing(...))\nstream.reduce(...)\nstream.collect(summingInt(mapper))\nstream.mapToInt(mapper).sum()\nstream.collect(summingLong(mapper))\nstream.mapToLong(mapper).sum()\nstream.collect(summingDouble(mapper))\nstream.mapToDouble(mapper).sum()\nNoncompliant code example\n```java\nint count = stream.collect(counting());  // Noncompliant\n```\nCompliant solution\n```java\nint count = stream.count();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4201": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Null checks should not be used with \"instanceof\"\nDescription: Why is this an issue?\nThere\u2019s no need to null test in conjunction with an\ninstanceof\ntest.\nnull\nis not an\ninstanceof\nanything, so\na null check is redundant.\nNoncompliant code example\n```java\nif (x != null && x instanceof MyClass) { ... }  // Noncompliant\n\nif (x == null || ! x instanceof MyClass) { ... } // Noncompliant\n```\nCompliant solution\n```java\nif (x instanceof MyClass) { ... }\n\nif (! x instanceof MyClass) { ... }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4174": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local constants should follow naming conventions for constants\nDescription: Why is this an issue?\nShared coding conventions allow teams to collaborate efficiently. This rule checks that all local,\nfinal\n, initialized, primitive\nvariables, have names that match a provided regular expression.\nNoncompliant code example\nWith the default regular expression\n^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\n:\n```java\npublic void doSomething() {\n  final int local = 42;\n  ...\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  final int LOCAL = 42;\n  ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4087": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"close()\" calls should not be redundant\nDescription: Why is this an issue?\nJava 7\u2019s try-with-resources structure automatically handles closing the resources that the\ntry\nitself opens. Thus, adding an explicit\nclose()\ncall is redundant and potentially confusing.\nNoncompliant code example\n```java\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n  writer.close();  // Noncompliant\n}\n```\nCompliant solution\n```java\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4065": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ThreadLocal.withInitial\" should be preferred\nDescription: Why is this an issue?\nJava 8 introduced\nThreadLocal.withInitial\nwhich is a simpler alternative to creating an anonymous inner class to initialise a\nThreadLocal\ninstance.\nThis rule raises an issue when a\nThreadLocal\nanonymous inner class can be replaced by a call to\nThreadLocal.withInitial\n.\nNoncompliant code example\n```java\nThreadLocal<List<String>> myThreadLocal =\n    new ThreadLocal<List<String>>() { // Noncompliant\n        @Override\n        protected List<String> initialValue() {\n            return new ArrayList<String>();\n        }\n    };\n```\nCompliant solution\n```java\nThreadLocal<List<String>> myThreadLocal = ThreadLocal.withInitial(ArrayList::new);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4034": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream\" call chains should be simplified when possible\nDescription: Why is this an issue?\nWhen using the\nStream\nAPI, call chains should be simplified as much as possible. Not only does it make the code easier to read, it\nalso avoid creating unnecessary temporary objects.\nThis rule raises an issue when one of the following substitution is possible:\nOriginal\nPreferred\nstream.filter(predicate).findFirst().isPresent()\nstream.anyMatch(predicate)\nstream.filter(predicate).findAny().isPresent()\nstream.anyMatch(predicate)\n!stream.anyMatch(predicate)\nstream.noneMatch(predicate)\n!stream.anyMatch(x -> !(...))\nstream.allMatch(...)\nstream.map(mapper).anyMatch(Boolean::booleanValue)\nstream.anyMatch(predicate)\nNoncompliant code example\n```java\nboolean hasRed = widgets.stream().filter(w -> w.getColor() == RED).findFirst().isPresent(); // Noncompliant\n```\nCompliant solution\n```java\nboolean hasRed = widgets.stream().anyMatch(w -> w.getColor() == RED);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-4032": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Packages containing only \"package-info.java\" should be removed\nDescription: Why is this an issue?\nThere is no reason to have a package that is empty except for \"package-info.java\". Such packages merely clutter a project, taking up space but\nadding no value.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3878": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arrays should not be created for varargs parameters\nDescription: Why is this an issue?\nThere\u2019s no point in creating an array solely for the purpose of passing it as a varargs (\n...\n) argument; varargs\nis\nan array.\nSimply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where\nObject ...\nis expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects?\nNoncompliant code example\n```java\npublic void callTheThing() {\n  //...\n  doTheThing(new String[] { \"s1\", \"s2\"});  // Noncompliant: unnecessary\n  doTheThing(new String[12]);  // Compliant\n  doTheOtherThing(new String[8]);  // Noncompliant: ambiguous\n  // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n```\nCompliant solution\n```java\npublic void callTheThing() {\n  //...\n  doTheThing(\"s1\", \"s2\");\n  doTheThing(new String[12]);\n  doTheOtherThing((Object[]) new String[8]);\n   // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3658": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unit tests should throw exceptions\nDescription: Why is this an issue?\nWhen the code under test in a unit test throws an exception, the test itself fails. Therefore, there is no need to surround the tested code with a\ntry\n-\ncatch\nstructure to detect failure. Instead, you can simply move the exception type to the method signature.\nThis rule raises an issue when there is a fail assertion inside a\ncatch\nblock.\nSupported frameworks:\n1. JUnit3\n2. JUnit4\n3. JUnit5\n4. Fest assert\n5. AssertJ\nNoncompliant code example\n```java\n@Test\npublic void testMethod() {\n  try {\n            // Some code\n  } catch (MyException e) {\n    Assert.fail(e.getMessage());  // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\n@Test\npublic void testMethod() throws MyException {\n    // Some code\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3626": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Jump statements should not be redundant\nDescription: Why is this an issue?\nJump statements such as\nreturn\nand\ncontinue\nlet you change the default flow of program execution, but jump statements\nthat direct the control flow to the original direction are just a waste of keystrokes.\nNoncompliant code example\n```java\npublic void foo() {\n  while (condition1) {\n    if (condition2) {\n      continue; // Noncompliant\n    } else {\n      doTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n```\nCompliant solution\n```java\npublic void foo() {\n  while (condition1) {\n    if (!condition2) {\n      doTheThing();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3578": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test methods should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test method name does not match the provided\nregular expression.\nNoncompliant code example\nWith the default value:\n^test[A-Z][a-zA-Z0-9]*$\n```java\n@Test\npublic void foo() {  // Noncompliant\n  //...\n}\n```\nCompliant solution\n```java\n@Test\npublic void testFoo() {\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3577": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test classes should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test class name does not match the provided\nregular expression.\nNoncompliant code example\nWith the default value:\n^((Test|IT)[a-zA-Z0-9_]+|[A-Z][a-zA-Z0-9_]*(Test|Tests|TestCase|IT|ITCase))$\n```java\nclass Foo {  // Noncompliant\n  @Test\n  void check() {  }\n}\n\nclass Bar {  // Noncompliant\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n```\nCompliant solution\n```java\nclass FooTest {\n  @Test\n  void check() {  }\n}\n\nclass BarIT {\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3437": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Value-based objects should not be serialized\nDescription: Why is this an issue?\nAccording to the documentation,\nA program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly\n  via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization\u2026\u200b\nFor example (credit to Brian Goetz), imagine Foo is a value-based class:\n```java\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = new Foo(0);\n```\nSerialization promises that on deserialization of arr, elements 0 and 1 will not be aliased. Similarly, in:\n```java\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = arr[0];\n```\nSerialization promises that on deserialization of\narr\n, elements 0 and 1\nwill\nbe aliased.\nWhile these promises are coincidentally fulfilled in current implementations of Java, that is not guaranteed in the future, particularly when true\nvalue types are introduced in the language.\nThis rule raises an issue when a\nSerializable\nclass defines a non-transient, non-static field field whose type is a known serializable\nvalue-based class. Known serializable value-based classes are: all the classes in the\njava.time\npackage except\nClock\n; the\ndate classes for alternate calendars:\nHijrahDate\n,\nJapaneseDate\n,\nMinguoDate\n,\nThaiBuddhistDate\n.\nNoncompliant code example\n```java\nclass MyClass implements Serializable {\n  private HijrahDate date;  // Noncompliant; mark this transient\n  // ...\n}\n```\nCompliant solution\n```java\nclass MyClass implements Serializable {\n  private transient HijrahDate date;\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3416": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loggers should be named for their enclosing classes\nDescription: Why is this an issue?\nIt is convention to name each class\u2019s logger for the class itself. Doing so allows you to set up clear, communicative logger configuration. Naming\nloggers by some other convention confuses configuration, and using the same class name for multiple class loggers prevents the granular configuration\nof each class' logger. Some libraries, such as SLF4J warn about this, but not all do.\nThis rule raises an issue when a logger is not named for its enclosing class.\nNoncompliant code example\n```java\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(WrongClass.class);  // Noncompliant; multiple classes using same logger\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(MyClass.class);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3400": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not return constants\nDescription: Why is this an issue?\nThere\u2019s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.\nThis rule raises an issue if on methods that contain only one statement: the\nreturn\nof a constant value.\nNoncompliant code example\n```java\nint getBestNumber() {\n  return 12;  // Noncompliant\n}\n```\nCompliant solution\n```java\nstatic final int BEST_NUMBER = 12;\n```\nExceptions\nThe following types of method are ignored:\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3398": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"private\" methods called only by inner classes should be moved to those classes\nDescription: Why is this an issue?\nWhen a\nprivate\nmethod is only invoked by an inner class, there\u2019s no reason not to move it into that class. It will still have the same\naccess to the outer class' members, but the outer class will be clearer and less cluttered.\nNoncompliant code example\n```java\npublic class Outie {\n  private int i=0;\n\n  private void increment() {  // Noncompliant\n    i++;\n  }\n\n  public class Innie {\n    public void doTheThing() {\n      Outie.this.increment();\n    }\n  }\n}\n```\nCompliant solution\n```java\npublic class Outie {\n  private int i=0;\n\n  public class Innie {\n    public void doTheThing() {\n      increment();\n    }\n\n    private void increment() {\n      Outie.this.i++;\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3254": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Default annotation parameter values should not be passed as arguments\nDescription: Why is this an issue?\nSpecifying the default value for an annotation parameter is redundant. Such values should be omitted in the interests of readability.\nNoncompliant code example\n```java\n@MyAnnotation(arg = \"def\")  // Noncompliant\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n```\nCompliant solution\n```java\n@MyAnnotation\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3242": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Method parameters should be declared with base types\nDescription: Why is this an issue?\nFor maximum reusability, methods should accept parameters with as little specialization as possible. So unless specific features from a child class\nare required by a method, a type higher up the class hierarchy should be used instead.\nNoncompliant code example\n```java\npublic void printSize(ArrayList<Object> list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(List<Object> list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n```\nCompliant solution\n```java\npublic void printSize(Collection<?> list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(Iterable<?> list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n```\nExceptions\nParameters in non-public methods are not checked, because such methods are not intended to be generally reusable.\njava.lang.String\nparameters are excluded, because String is immutable and can not be always substituted for more generic type. Parameters used in any other context\nthan method invocation or enhanced for loop are also excluded.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3066": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"enum\" fields should not be publicly mutable\nDescription: Why is this an issue?\nenum\ns are generally thought of as constant, but an\nenum\nwith a\npublic\nfield or\npublic\nsetter is\nnon-constant. Ideally fields in an\nenum\nare\nprivate\nand set in the constructor, but if that\u2019s not possible, their visibility\nshould be reduced as much as possible.\nNoncompliant code example\n```java\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  public int countryCount;  // Noncompliant\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n\n  public void setLandMass(int landMass) {  // Noncompliant\n    this.landMass = landMass;\n  }\n```\nCompliant solution\n```java\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  private int countryCount;\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3052": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Fields should not be initialized to default values\nDescription: Why is this an issue?\nThe compiler automatically initializes class fields to their default values before setting them with any initialization values, so there is no need\nto explicitly set a field to its default value. Further, under the logic that cleaner code is better code, it\u2019s considered poor style to do so.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  int count = 0;  // Noncompliant\n  // ...\n\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  int count;\n  // ...\n\n}\n```\nExceptions\nfinal\nfields are ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3047": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Multiple loops over the same set should be combined\nDescription: Why is this an issue?\nWhen a method loops multiple over the same set of data, whether it\u2019s a list or a set of numbers, it is highly likely that the method could be made\nmore efficient by combining the loops into a single set of iterations.\nNoncompliant code example\n```java\npublic void doSomethingToAList(List<String> strings) {\n  for (String str : strings) {\n    doStep1(str);\n  }\n  for (String str : strings) {  // Noncompliant\n    doStep2(str);\n  }\n}\n```\nCompliant solution\n```java\npublic void doSomethingToAList(List<String> strings) {\n  for (String str : strings) {\n    doStep1(str);\n    doStep2(str);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3038": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract methods should not be redundant\nDescription: Why is this an issue?\nThere\u2019s no point in redundantly defining an\nabstract\nmethod with the same signature as a method in an\ninterface\nthat the\nclass\nimplements\n. Any concrete child classes will have to implement the method either way.\nNoncompliant code example\n```java\npublic interface Reportable {\n  String getReport();\n}\n\npublic abstract class AbstractRuleReport implements Reportable{\n  public abstract String getReport();  // Noncompliant\n\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3033": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \".isEmpty\" should be used to test for the emptiness of StringBuffers/Builders\nDescription: Why is this an issue?\nIt is inefficient to build a\nString\nfrom a\nStringBuilder\nor\nStringBuffer\njust to check if it\u2019s empty.\nInstead, directly use the\n.isEmpty\nmethod.\nNoncompliant code example\n```java\nStringBuilder sb = new StringBuilder();\n// ...\nif (\"\".equals(sb.toString()) { // Noncompliant\n  // ...\n}\nif (sb.toString().isEmpty()) { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\nStringBuilder sb = new StringBuilder();\n// ...\nif (sb.isEmpty()) {\n  // ...\n}\nif (sb.isEmpty()) {\n  // ...\n}\n```\nBenchmarks\nMethod\nstringBuilderSize\nRuntime\nAverage time\nError margin\nisEmpty\n10\nTemurin 21\n6.57 ns/op\n\u00b10.38 ns/op\nisEmpty\n100\nTemurin 21\n6.68 ns/op\n\u00b10.10 ns/op\nisEmpty\n1000\nTemurin 21\n6.80 ns/op\n\u00b10.12 ns/op\nlength\n10\nTemurin 21\n6.83 ns/op\n\u00b10.12 ns/op\nlength\n100\nTemurin 21\n6.66 ns/op\n\u00b10.11 ns/op\nlength\n1000\nTemurin 21\n6.67 ns/op\n\u00b10.07 ns/op\ntoStringEquals\n10\nTemurin 21\n13.92 ns/op\n\u00b10.18 ns/op\ntoStringEquals\n100\nTemurin 21\n59.09 ns/op\n\u00b10.53 ns/op\ntoStringEquals\n1000\nTemurin 21\n465.79 ns/op\n\u00b15.86 ns/op\ntoStringIsEmpty\n10\nTemurin 21\n13.83 ns/op\n\u00b10.23 ns/op\ntoStringIsEmpty\n100\nTemurin 21\n60.06 ns/op\n\u00b13.42 ns/op\ntoStringIsEmpty\n1000\nTemurin 21\n484.58 ns/op\n\u00b14.24 ns/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@Param({\"10\", \"100\", \"1000\"})\nint stringBuilderSize;\n\n\nprivate StringBuilder sb;\n\n@Setup(Level.Iteration)\npublic void setup() {\n  sb = new StringBuilder();\n  IntStream.range(0, stringBuilderSize).forEach(i -> sb.append(\"word\"));\n}\n\n@Benchmark\npublic StringBuilder toStringEquals() {\n  if (\"\".equals((sb.toString()))) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder toStringIsEmpty() {\n  if (sb.toString().isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder length() {\n  if (sb.length() == 0) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder isEmpty() {\n  if (sb.isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3024": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arguments to \"append\" should not be concatenated\nDescription: Why is this an issue?\nThe use of a\nStringBuilder\nor\nStringBuffer\nmakes\nString\nassembly more efficient than plain concatenation\nwhen you perform a large number of appends. Using\nString\nconcatenation within\nStringBuilder.append\ndefeats the purpose of\nthe\nStringBuilder\n. If you concatenate only a few strings, use direct\nString\nconcatenation. Otherwise, replace\nString\nconcatenation with calls to\nappend\n.\nThis rule applies to String concatenations performed repeatedly, inside loops. In such scenarios, the performance penalty associated with\ninefficient StringBuilder.append usage can multiply significantly.\nNoncompliant code example\n```java\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \" + name); // Noncompliant\n}\n```\nCompliant solution\n```java\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \").append(name);\n}\n```\nBenchmarks\nMethod\nRuntime\nAverage time\nError margin\nappend\nTemurin 21\n14.26 ns/op\n\u00b10.50 ns/op\nconcat\nTemurin 21\n17.77 ns/op\n\u00b10.66 ns/op\nconcatWithinBuilder\nTemurin 21\n31.42 ns/op\n\u00b11.80 ns/op\nThe results were generated by running the following snippet with\njmh\n:\n```java\nprivate String name1 = \"John\";\nprivate String name2 = \"Jane\";\n\n@Benchmark\npublic String concat() {\n  return name1 + \", \" + name2;\n}\n\n@Benchmark\npublic String concatWithinBuilder() {\n  return new StringBuilder()\n    .append(name1 + \", \" + name2)\n    .toString();\n}\n\n@Benchmark\npublic String append() {\n  return new StringBuilder()\n    .append(name1)\n    .append(\", \")\n    .append(name2)\n    .toString();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3012": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arrays and lists should not be copied using loops\nDescription: Why is this an issue?\nThe JDK provides a set of built-in methods to copy the contents of an array into another array. Using a loop to perform the same operation is less\nclear, more verbose and should be avoided.\nExceptions\nThe rule detects only the most idiomatic patterns, it will not consider loops with non-trivial control flow. For example, loops that copy array\nelements conditionally are ignored.\nHow to fix it\nYou can use:\n1. Arrays.copyOfto copy an entire array into another array\n2. System.arraycopyto copy only a subset of an array into another array\n3. Arrays.asListto create a new list with the contents of the array\n4. Collections.addAllto add the elements of a collection into another collection\nNote that\nArrays.asList\nreturns a fixed-size\nList\n, so further steps are required if a non-fixed-size\nList\nis\nneeded.\nCode examples\nNoncompliant code example\n```java\npublic void copyArray(String[] source){\n  String[] array = new String[source.length];\n  for (int i = 0; i < source.length; i++) {\n    array[i] = source[i]; // Noncompliant\n  }\n}\n\npublic void copyList(List<String> source) {\n  List<String> list = new ArrayList<>();\n  for (String s : source) {\n    list.add(s); // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic void copyArray(String[] source){\n  String[] array = Arrays.copyOf(source, source.length);\n}\n\npublic void copyList(List<String> source) {\n  List<String> list = new ArrayList<>();\n  Collections.addAll(list, source);\n}\n```\n```java\npublic void makeCopiesConditional(int[] source) {\n  int[] dest = new int[source.length];\n  for (int i = 0; i < source.length; i++) {\n    if (source[i] > 10) {\n      dest[i] = source[i];  // Compliant, since the array elements are conditionally copied to the dest array\n    }\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-3008": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Static non-final field names should comply with a naming convention\nDescription: Why is this an issue?\nThe Java Language Specification defines a set of rules called naming conventions that apply to Java programs. These conventions provide\nrecommendations for naming packages, classes, methods, and variables.\nBy following shared naming conventions, teams can collaborate more efficiently.\nThis rule checks that static non-final field names match a provided regular expression.\nNoncompliant code example\nThe default regular expression applied by the rule is\n^[a-z][a-zA-Z0-9]*$\n:\n```java\npublic class MyClass {\n   private static String foo_bar; // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n   private static String fooBar;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2974": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes without \"public\" constructors should be \"final\"\nDescription: Why is this an issue?\nClasses with only\nprivate\nconstructors should be marked\nfinal\nto prevent any mistaken extension attempts.\nNoncompliant code example\n```java\npublic class PrivateConstructorClass {  // Noncompliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n```\nCompliant solution\n```java\npublic final class PrivateConstructorClass {  // Compliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2959": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnecessary semicolons should be omitted\nDescription: Why is this an issue?\nUnder the reasoning that cleaner code is better code, the semicolon at the end of a try-with-resources construct should be omitted because it can\nbe omitted.\nNoncompliant code example\n```java\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);  // ignored; this one's required\n      Reader r = new InputStreamReader(b);)   // Noncompliant\n{\n   //do stuff\n}\n```\nCompliant solution\n```java\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);\n      Reader r = new InputStreamReader(b))\n{\n   //do stuff\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2924": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit rules should be used\nDescription: Why is this an issue?\nJUnit rules are predefined classes that extend the behavior of JUnit tests, allowing to add new functionalities, such as managing resources,\nmodifying test behavior, and handling exceptions.\nUnused JUnit rules can lead to confusion when reading the test code, making tests harder to understand and maintain. Having unused rules can also\nslow down the test suite, as JUnit has to process the rules even though they are not being used. Some\nTestRule\nclasses have the desired\neffect without being directly referenced by a test, while others do not. There\u2019s no reason to leave them cluttering the file if they\u2019re not in\nuse.\nThe rule raises an issue when in a\nTest\nclass, there is no method referencing a declared\nTestRule\nof the following\ntypes:\n1. TemporaryFolderandTestNamein JUnit\n2. TempDirandTestInfoin JUnit 5\nHow to fix it\nRemove the unused\nTestRule\nfield that is expected to be referenced inside a test method.\nCode examples\nNoncompliant code example\n```java\npublic class ProjectDefinitionTest {\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();  // Noncompliant\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n```\nCompliant solution\n```java\npublic class ProjectDefinitionTest {\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n```\nDocumentation\n1. Junit API - Rule\n2. Junit - Rules\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2786": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nested \"enum\"s should not be declared static\nDescription: Why is this an issue?\nIn Java, an enum is a special data type that allows you to define a set of constants. Nested enum types, also known as inner enum types, are enum\ntypes that are defined within another class or interface.\nNested enum types are implicitly static, so there is no need to declare them\nstatic\nexplicitly.\nNoncompliant code example\n```java\npublic class Flower {\n  static enum Color { // Noncompliant; static is redundant here\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n```\nCompliant solution\n```java\npublic class Flower {\n  enum Color { // Compliant\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2737": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"catch\" clauses should do more than rethrow\nDescription: Why is this an issue?\nA\ncatch\nclause that only rethrows the caught exception has the same effect as omitting the\ncatch\naltogether and letting\nit bubble up automatically.\n```java\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    throw e;\n  }\n  return content;\n}\n```\nSuch clauses should either be removed or populated with the appropriate logic.\n```java\npublic String readFile(File f) throws IOException {\n  return readFromDisk(f);\n}\n```\nor\n```java\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    logger.LogError(e);\n    throw e;\n  }\n  return content;\n}\n```\nIn the case of try-with-resources, the try should remain even without a catch clause, to keep the resource management\n```java\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  } catch (IOException e) { // Noncompliant\n  throw e;\n}\n```\nbecomes\n```java\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2701": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Literal boolean values and nulls should not be used in assertions\nDescription: Why is this an issue?\nThere\u2019s no reason to use literal boolean values or nulls in assertions. Instead of using them with\nassertEquals\n,\nassertNotEquals\nand similar methods, you should be using\nassertTrue\n,\nassertFalse\n,\nassertNull\nor\nassertNotNull\ninstead (or\nisNull\netc. when using Fest). Using them with assertions unrelated to equality (such as\nassertNull\n) is most likely a bug.\nSupported frameworks:\n1. JUnit3\n2. JUnit4\n3. JUnit5\n4. Fest assert\nNoncompliant code example\n```java\nAssert.assertTrue(true);  // Noncompliant\nassertThat(null).isNull(); // Noncompliant\n\nassertEquals(true, something()); // Noncompliant\nassertNotEquals(null, something()); // Noncompliant\n```\nCompliant solution\n```java\nassertTrue(something());\nassertNotNull(something());\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2698": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test assertions should include messages\nDescription: Why is this an issue?\nAdding messages to JUnit, FEST and AssertJ assertions is an investment in your future productivity. Spend a few seconds writing them now, and\nyou\u2019ll save a lot of time on the other end when either the tests fail and you need to quickly diagnose the problem, or when you need to maintain the\ntests and the assertion messages work as a sort of documentation.\nNoncompliant code example\n```java\nassertEquals(4, list.size());  // Noncompliant\n\ntry {\n  fail();  // Noncompliant\n} catch (Exception e) {\n  assertThat(list.get(0)).isEqualTo(\"pear\");  // Noncompliant\n}\n```\nCompliant solution\n```java\nassertEquals(\"There should have been 4 Fruits in the list\", 4, list.size());\n\ntry {\n  fail(\"And exception is expected here\");\n} catch (Exception e) {\n  assertThat(list.get(0)).as(\"check first element\").overridingErrorMessage(\"The first element should be a pear, not a %s\", list.get(0)).isEqualTo(\"pear\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2386": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Mutable fields should not be \"public static\"\nDescription: Why is this an issue?\nThere is no good reason to have a mutable object as the\npublic\n(by default),\nstatic\nmember of an\ninterface\n.\nSuch variables should be moved into classes and their visibility lowered.\nSimilarly, mutable\nstatic\nmembers of classes and enumerations which are accessed directly, rather than through getters and setters,\nshould be protected to the degree possible. That can be done by reducing visibility or making the field\nfinal\nif appropriate.\nNote that making a mutable field, such as an array,\nfinal\nwill keep the variable from being reassigned, but doing so has no effect on\nthe mutability of the internal state of the array (i.e. it doesn\u2019t accomplish the goal).\nThis rule raises issues for\npublic static\narray,\nCollection\n,\nDate\n, and\nawt.Point\nmembers.\nNoncompliant code example\n```java\npublic interface MyInterface {\n  public static String [] strings; // Noncompliant\n}\n\npublic class A {\n  public static String [] strings1 = {\"first\",\"second\"};  // Noncompliant\n  public static String [] strings2 = {\"first\",\"second\"};  // Noncompliant\n  public static List<String> strings3 = new ArrayList<>();  // Noncompliant\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2384": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Private mutable members should not be stored or returned directly\nDescription: Why is this an issue?\nMutable objects are those whose state can be changed. For instance, an array is mutable, but a String is not. Private mutable class members should\nnever be returned to a caller or accepted and stored directly. Doing so leaves you vulnerable to unexpected changes in your class state.\nInstead use an unmodifiable\nCollection\n(via\nCollections.unmodifiableCollection\n,\nCollections.unmodifiableList\n, \u2026\u200b) or make a copy of the mutable object, and store or return the copy instead.\nThis rule checks that private arrays, collections and Dates are not stored or returned directly.\nExceptions\nThe rule violation is not reported for mutable values stored in private methods if no non-private methods directly passes a mutable parameter to\nthem.\nSimilarly, rule violations are not reported for mutable values returned by a private getter if that getter\u2019s value is not directly exposed by a\nnon-private method.\nNoncompliant code example\n```java\nclass A {\n  private String[] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return strings; // Noncompliant\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings;  // Noncompliant\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"yellow\", \"second\"};\n  }\n}\n```\nCompliant solution\n```java\nclass A {\n  private String [] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return getStringsInternal().clone();\n  }\n\n  private String[] getStringsInternal() {\n    return strings;\n  }\n\n  private void setStringsInternal(String[] strings) {\n    this.strings = strings;\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings.clone();\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"first\", \"second\"};\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2333": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant modifiers should not be used\nDescription: Why is this an issue?\nThe methods declared in an\ninterface\nare\npublic\nand\nabstract\nby default. Any variables are automatically\npublic static final\n. Finally,\nclass\nand\ninterface\nare automatically\npublic static\n. There is no\nneed to explicitly declare them so.\nSince annotations are implicitly interfaces, the same holds true for them as well.\nSimilarly, the\nfinal\nmodifier is redundant on any method of a\nfinal\nclass,\nprivate\nis redundant on the\nconstructor of an\nEnum\n, and\nstatic\nis redundant for\ninterface\nnested into a\nclass\nor\nenum\n.\nNoncompliant code example\n```java\npublic interface Vehicle {\n\n  public void go(int speed, Direction direction);  // Noncompliant\n```\nCompliant solution\n```java\npublic interface Vehicle {\n\n  void go(int speed, Direction direction);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2325": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"private\" and \"final\" methods that don't access instance data should be \"static\"\nDescription: Why is this an issue?\nNon-overridable methods (\nprivate\nor\nfinal\n) that don\u2019t access instance data can be\nstatic\nto prevent any\nmisunderstanding about the contract of the method.\nNoncompliant code example\n```java\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private String getMagicWord() { // Noncompliant\n    return magicWord;\n  }\n\n  private void setMagicWord(String value) { // Noncompliant\n    magicWord = value;\n  }\n\n}\n```\nCompliant solution\n```java\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private static String getMagicWord() {\n    return magicWord;\n  }\n\n  private static void setMagicWord(String value) {\n    magicWord = value;\n  }\n\n}\n```\nExceptions\nWhen\njava.io.Serializable\nis implemented the following three methods are excluded by the rule:\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2309": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should not be empty\nDescription: Why is this an issue?\nFiles with no lines of code clutter a project and should be removed.\nNoncompliant code example\n```java\n//package org.foo;\n//\n//public class Bar {}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2293": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The diamond operator (\"<>\") should be used\nDescription: Why is this an issue?\nJava uses angular brackets (\n<\nand\n>\n) to provide a specific type (the \"type argument\") to a generic type. For\ninstance,\nList\nis a generic type, so a list containing strings can be declared with\nList<String>\n.\nPrior to Java 7, the type argument had to be provided explicitly for every occurrence where generics were used. This often caused redundancy, as\nthe type argument would have to be provided both when a field is declared and initialized.\nJava 7 introduced the diamond operator (\n<>\n) to reduce the code\u2019s verbosity in some situations. The type argument between the\nangular brackets should be omitted if the compiler can infer it.\nSince the diamond operator was only introduced in Java 7, this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis\nlower than\n7\n.\nHow to fix it\nThe type argument should be omitted in the initialization if it is already present in the declaration of a field or variable.\nFor instance, a field with type\nList<String>\ncan be initialized with\nArrayList<>()\n, as the compiler will\ninfer that\nArrayList<String>()\nis the actually desired call.\nCode examples\nNoncompliant code example\n```java\nList<String> strings = new ArrayList<String>();                       // Noncompliant, the compiler can infer the type argument of the constructor invocation\nMap<String,List<Integer>> map = new HashMap<String,List<Integer>>();  // Noncompliant, the compiler can also infer complex type arguments\n```\nCompliant solution\n```java\nList<String> strings = new ArrayList<>();        // Compliant, the compiler will infer the type argument\nMap<String,List<Integer>> map = new HashMap<>(); // Compliant, the compiler will infer the type argument\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2250": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Collection methods with O(n) performance should be used carefully\nDescription: Why is this an issue?\nThe time complexity of method calls on collections is not always obvious. For instance, for most collections the\nsize()\nmethod takes\nconstant time, but the time required to execute\nConcurrentLinkedQueue.size()\nis O(n), i.e. directly proportional to the number of\nelements in the collection. When the collection is large, this could therefore be an expensive operation.\nThis rule raises an issue when the following O(n) methods are called outside of constructors on class fields:\n1. ArrayListcontainsremove\n2. contains\n3. remove\n4. LinkedListgetcontains\n5. get\n6. contains\n7. ConcurrentLinkedQueuesizecontains\n8. size\n9. contains\n10. ConcurrentLinkedDequesizecontains\n11. size\n12. contains\n13. CopyOnWriteArrayListaddcontainsremove\n14. add\n15. contains\n16. remove\n17. CopyOnWriteArraySetaddcontainsremove\n18. add\n19. contains\n20. remove\nNoncompliant code example\n```java\nConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();\n//...\nlog.info(\"Queue contains \" + queue.size() + \" elements\");  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2221": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Exception\" should not be caught when not required by called methods\nDescription: Why is this an issue?\nCatching\nException\nseems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\nboth checked and runtime exceptions, thereby casting too broad a net. Indeed, was it really the intention of developers to also catch runtime\nexceptions? To prevent any misunderstanding, if both checked and runtime exceptions are really expected to be caught, they should be explicitly listed\nin the\ncatch\nclause.\nThis rule raises an issue if\nException\nis caught when it is not explicitly thrown by a method in the\ntry\nblock.\nNoncompliant code example\n```java\ntry {\n  // do something that might throw an UnsupportedDataTypeException or UnsupportedEncodingException\n} catch (Exception e) { // Noncompliant\n  // log exception ...\n}\n```\nCompliant solution\n```java\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException|RuntimeException e) {\n  // log exception ...\n}\n```\nor if runtime exceptions should not be caught:\n```java\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException e) {\n  // log exception ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2203": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"collect\" should be used with \"Streams\" instead of \"list::add\"\nDescription: Why is this an issue?\nWhile you can use either\nforEach(list::add)\nor\ncollect\nwith a\nStream\n,\ncollect\nis by far the\nbetter choice because it\u2019s automatically thread-safe and parallellizable.\nNoncompliant code example\n```java\nList<String> bookNames = new ArrayList<>();\nbooks.stream().filter(book -> book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .forEach(bookNames::add);  // Noncompliant\n```\nCompliant solution\n```java\nList<String> bookNames = books.stream().filter(book -> book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .collect(Collectors.toList());\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2196": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Switches should be used for sequences of simple \"String\" tests\nDescription: Why is this an issue?\nSince Java 7,\nString\ns can be used as\nswitch\narguments. So when a single\nString\nis tested against three or\nmore values in an\nif\n/\nelse if\nstructure, it should be converted to a switch instead for greater readability.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\nif (\"red\".equals(choice)) {  // Noncompliant\n  dispenseRed();\n} else if (\"blue\".equals(choice)) {\n  dispenseBlue();\n} else if (\"yellow\".equals(choice)) {\n  dispenseYellow();\n} else {\n  promptUser();\n}\n```\nCompliant solution\n```java\nswitch(choice) {\n  case \"Red\":\n    dispenseRed();\n    break;\n  case \"Blue\":\n    dispenseBlue():\n    break;\n  case \"Yellow\":\n    dispenseYellow();\n    break;\n  default:\n    promptUser();\n    break;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2160": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Subclasses that add fields to classes that override \"equals\" should also override \"equals\"\nDescription: This rule raises an issue when a subclass of a class that overrides\nObject.equals\nintroduces new fields but does not also override the\nObject.equals\nmethod.\nWhy is this an issue?\nWhen a class overrides\nObject.equals\n, this indicates that the class not just considers object identity as equal (the default\nimplementation of\nObject.equals\n) but implements another logic for what is considered equal in the context of this class. Usually (but not\nnecessarily), the semantics of\nequals\nin this case is that two objects are equal when their state is equal field by field.\nBecause of this, adding new fields to a subclass of a class that overrides\nObject.equals\nbut not updating the implementation of\nequals\nin the subclass is most likely an error.\nHow to fix it\nConsider the following example:\n```java\nclass Foo {\n\n  final int a;\n\n  @Override\n  public boolean equals(Object other) {\n    if (other == null) return false;\n    if (getClass() != other.getClass()) return false;\n    return a == ((Foo) other).a;\n  }\n}\n```\n```java\nclass Bar extends Foo { // Noncompliant, `equals` ignores the value of `b`\n  final int b;\n}\n```\nOverride the\nequals\nmethod in the subclass to incorporate the new fields into the comparison:\n```java\nclass Bar extends Foo { // Compliant, `equals` now also considers `b`\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    if (!super.equals(other)) return false;\n    return b == ((Bar) other).b;\n  }\n}\n```\nIn case the new fields should not be part of the comparison because they are, for example, auxiliary variables not contributing to the object value\n(), still override the method to make the point clear that this was not just forgotten:\n```java\nclass Bar extends Foo { // Compliant, we do explicitly not want to take `b` into account\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    return super.equals(other);\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2156": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"final\" classes should not have \"protected\" members\nDescription: Why is this an issue?\nThe difference between\nprivate\nand\nprotected\nvisibility is that child classes can see and use\nprotected\nmembers, but they cannot see\nprivate\nones. Since a\nfinal\nclass will have no children, marking the members of a\nfinal\nclass\nprotected\nis confusingly pointless.\nNote that the\nprotected\nmembers of a class can also be seen and used by other classes that are placed within the same package, this\ncould lead to accidental, unintended access to otherwise private members.\nNoncompliant code example\n```java\npublic final class MyFinalClass {\n\n  protected String name = \"Fred\";  // Noncompliant\n  protected void setName(String name) {  // Noncompliant\n    // ...\n  }\n```\nCompliant solution\n```java\npublic final class MyFinalClass {\n\n  private String name = \"Fred\";\n  public void setName(String name) {\n    // ...\n  }\n```\nExceptions\nMembers annotated with\n@VisibleForTesting\nannotation are ignored, as it indicates that visibility has been purposely relaxed to\nmake the code testable.\n```java\npublic final class MyFinalClass {\n  @VisibleForTesting\n  protected Logger logger; // Compliant\n\n  @VisibleForTesting\n  protected int calculateSomethingComplex(String input) { // Compliant\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2148": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Underscores should be used to make large numbers readable\nDescription: Why is this an issue?\nBeginning with Java 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this\nmanner has no semantic meaning, but makes it easier for maintainers to understand the code.\nThe number of digits to the left of a decimal point needed to trigger this rule varies by base.\nBase\nMinimum digits\nbinary\n9\noctal\n9\ndecimal\n6\nhexadecimal\n9\nIt is only the presence of underscores, not their spacing that is scrutinized by this rule.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\nint i = 10000000;  // Noncompliant; is this 10 million or 100 million?\nint  j = 0b01101001010011011110010101011110;  // Noncompliant\nlong l = 0x7fffffffffffffffL;  // Noncompliant\n```\nCompliant solution\n```java\nint i = 10_000_000;\nint  j = 0b01101001_01001101_11100101_01011110;\nlong l = 0x7fff_ffff_ffff_ffffL;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2147": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Catches should be combined\nDescription: Why is this an issue?\nSince Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiple\ncatch\nblocks have the same code, they\nshould be combined for better readability.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\ncatch (IOException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (SQLException e) {  // Noncompliant\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {  // Compliant; block contents are different\n  doCleanup();\n  throw e;\n}\n```\nCompliant solution\n```java\ncatch (IOException|SQLException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {\n  doCleanup();\n  throw e;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2140": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods of \"Random\" that return floating point values should not be used in random integer generation\nDescription: Why is this an issue?\nGenerating random floating point values to cast them into integers is inefficient. A random bounded integer value can be generated with a single\nproper method call. Use\nnextInt\nto make the code more efficient and the intent clearer.\nNoncompliant code example\n```java\nRandom r = new Random();\nint rand = (int) (r.nextDouble() * 50);  // Noncompliant way to get a pseudo-random value between 0 and 50\nint rand2 = (int) r.nextFloat(); // Noncompliant; will always be 0;\n```\nCompliant solution\n```java\nRandom r = new Random();\nint rand = r.nextInt(50);  // returns pseudo-random value between 0 and 50\nint rand2 = 0;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2130": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Parsing should be used to convert \"Strings\" to primitives\nDescription: Why is this an issue?\nRather than creating a boxed primitive from a\nString\nto extract the primitive value, use the relevant\nparse\nmethod\ninstead. Using\nparse\nmakes the code more efficient and the intent of the developer clearer.\nNoncompliant code example\n```java\nString myNum = \"42.0\";\nfloat myFloat = new Float(myNum);  // Noncompliant\nfloat myFloatValue = (new Float(myNum)).floatValue();  // Noncompliant\nint myInteger = Integer.valueOf(myNum); // Noncompliant\nint myIntegerValue = Integer.valueOf(myNum).intValue(); // Noncompliant\n```\nCompliant solution\n```java\nString myNum = \"42.0\";\nfloat f = Float.parseFloat(myNum);\nint myInteger = Integer.parseInt(myNum);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2094": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not be empty\nDescription: Why is this an issue?\nThere is no good excuse for an empty class. If it\u2019s being used simply as a common extension point, it should be replaced with an\ninterface\n. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be\neliminated.\nNoncompliant code example\n```java\npublic class Nothing {  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic interface Nothing {\n}\n```\nExceptions\nEmpty classes can be used as marker types (for Spring for instance), therefore empty classes that are annotated will be ignored.\n```java\n@Configuration\n@EnableWebMvc\npublic final class ApplicationConfiguration {\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2065": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Fields in non-serializable classes should not be \"transient\"\nDescription: Why is this an issue?\nFields marked as\ntransient\nin a\nSerializable\nclass will be ignored during serialization and consequently not written out\nto a file (or stream).\nThis can be useful in situations such as where the content of a field can be recomputed from other fields. To reduce the output size, this field\ncan be marked as\ntransient\nand recomputed when a given object is deserialized.\nSince\ntransient\nis very specific to classes that implement\nSerializable\n, it is superfluous in classes that do not.\nThis rule raises an issue when a field is marked as\ntransient\n, even though the containing class does not implement\nSerializable\n.\nHow to fix it\nAsk yourself whether this class should be serializable. If yes, ensure it implements\nSerializable\nand provides any additional logic\nrequired to serialize and deserialize an instance of this type. Otherwise, remove the\ntransient\nmodifier from this field.\nCode examples\nNoncompliant code example\n```java\nclass Vegetable {\n  private transient Season ripe; // Noncompliant, the \"Vegetable\" class does not implement \"Serializable\" but the field is marked as \"transient\"\n  // ...\n}\n```\nCompliant solution\n```java\nclass Vegetable {\n  private Season ripe; // Compliant, the field is not marked as \"transient\"\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2059": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Serializable\" inner classes of \"Serializable\" classes should be static\nDescription: Why is this an issue?\nSerializing a non-\nstatic\ninner class will result in an attempt at serializing the outer class as well. If the outer class is actually\nserializable, then the serialization will succeed but possibly write out far more data than was intended.\nMaking the inner class\nstatic\n(i.e. \"nested\") avoids this problem, therefore inner classes should be\nstatic\nif possible.\nHowever, you should be aware that there are semantic differences between an inner class and a nested one:\n1. an inner class can only be instantiated within the context of an instance of the outer class.\n2. a nested (static) class can be instantiated independently of the outer class.\nNoncompliant code example\n```java\npublic class Raspberry implements Serializable {\n  // ...\n\n  public class Drupelet implements Serializable {  // Noncompliant; output may be too large\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic class Raspberry implements Serializable {\n  // ...\n\n  public static class Drupelet implements Serializable {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-2039": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Member variable visibility should be specified\nDescription: Why is this an issue?\nFailing to explicitly declare the visibility of a member variable could result it in having a visibility you don\u2019t expect, and potentially leave it\nopen to unexpected modification by other classes.\nThe default access level modifier may be intentional; in that case, this rule can report false positives.\nNoncompliant code example\n```java\nclass Ball {\n  String color = \"red\";  // Noncompliant\n}\nenum A {\n  B;\n  int a;  // Noncompliant\n}\n```\nCompliant solution\n```java\nclass Ball {\n  private String color = \"red\";  // Compliant\n}\nenum A {\n  B;\n  private int a;  // Compliant\n}\n```\nExceptions\n1. Members with comments containing the wordmodifierare ignored, as it indicates the modifier is intentionally omitted.\n2. Members annotated with the@VisibleForTestingannotation are ignored, as it indicates that visibility has been purposely relaxed\n  to make the code testable.\n```java\nclass Cone {\n  @VisibleForTesting\n  Logger logger; // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1943": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes and methods that rely on the default system encoding should not be used\nDescription: Why is this an issue?\nUsing classes and methods that rely on the default system encoding can result in code that works fine in its \"home\" environment. But that code may\nbreak for customers who use different encodings in ways that are extremely difficult to diagnose and nearly, if not completely, impossible to\nreproduce when it\u2019s time to fix them.\nThis rule detects uses of the following classes and methods:\n1. FileReader\n2. FileWriter\n3. String constructors with abyte[]argument but noCharsetargumentString(byte[] bytes)String(byte[] bytes, int offset, int length)\n4. String(byte[] bytes)\n5. String(byte[] bytes, int offset, int length)\n6. String.getBytes()\n7. String.getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)\n8. InputStreamReader(InputStream in)\n9. OutputStreamWriter(OutputStream out)\n10. ByteArrayOutputStream.toString()\n11. SomeFormatterconstructorsFormatter(String fileName)Formatter(File file)Formatter(OutputStream os)\n12. Formatter(String fileName)\n13. Formatter(File file)\n14. Formatter(OutputStream os)\n15. SomeScannerconstructorsScanner(File source)Scanner(Path source)Scanner(InputStream source)\n16. Scanner(File source)\n17. Scanner(Path source)\n18. Scanner(InputStream source)\n19. SomePrintStreamconstructorsPrintStream(File file)PrintStream(OutputStream out)PrintStream(OutputStream out, boolean autoFlush)PrintStream(String fileName)\n20. PrintStream(File file)\n21. PrintStream(OutputStream out)\n22. PrintStream(OutputStream out, boolean autoFlush)\n23. PrintStream(String fileName)\n24. SomePrintWriterconstructorsPrintWriter(File file)PrintWriter(OutputStream out)PrintWriter(OutputStream out, boolean autoFlush)PrintWriter(String fileName)\n25. PrintWriter(File file)\n26. PrintWriter(OutputStream out)\n27. PrintWriter(OutputStream out, boolean autoFlush)\n28. PrintWriter(String fileName)\n29. methods from Apache commons-io library which accept an encoding argument when that argument is null, and overloads of those methods that omit\n  the encoding argumentIOUtils.copy(InputStream, Writer)IOUtils.copy(Reader, OutputStream)IOUtils.readLines(InputStream)IOUtils.toByteArray(Reader)IOUtils.toByteArray(String)IOUtils.toCharArray(InputStream)IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))IOUtils.toString(byte[])IOUtils.toString(URI)IOUtils.toString(URL)IOUtils.write(char[], OutputStream)IOUtils.write(CharSequence, OutputStream)IOUtils.writeLines(Collection, String, OutputStream)FileUtils.readFileToString(File)FileUtils.readLines(File)FileUtils.write(File, CharSequence)FileUtils.write(File, CharSequence, boolean)FileUtils.writeStringToFile(File, String)\n30. IOUtils.copy(InputStream, Writer)\n31. IOUtils.copy(Reader, OutputStream)\n32. IOUtils.readLines(InputStream)\n33. IOUtils.toByteArray(Reader)\n34. IOUtils.toByteArray(String)\n35. IOUtils.toCharArray(InputStream)\n36. IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))\n37. IOUtils.toString(byte[])\n38. IOUtils.toString(URI)\n39. IOUtils.toString(URL)\n40. IOUtils.write(char[], OutputStream)\n41. IOUtils.write(CharSequence, OutputStream)\n42. IOUtils.writeLines(Collection, String, OutputStream)\n43. FileUtils.readFileToString(File)\n44. FileUtils.readLines(File)\n45. FileUtils.write(File, CharSequence)\n46. FileUtils.write(File, CharSequence, boolean)\n47. FileUtils.writeStringToFile(File, String)\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1942": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Simple class names should be used\nDescription: Why is this an issue?\nJava\u2019s\nimport\nmechanism allows the use of simple class names. Therefore, using a class' fully qualified name in a file that\nimport\ns the class is redundant and confusing.\nNoncompliant code example\n```java\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\njava.util.List<String> myList;  // Noncompliant\njava.sql.Timestamp tStamp; // Noncompliant\n```\nCompliant solution\n```java\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\nList<String> myList;\nTimestamp tStamp;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1941": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Variables should not be declared before they are relevant\nDescription: Why is this an issue?\nFor the sake of clarity, variables should be declared as close to where they\u2019re used as possible. This is particularly true when considering\nmethods that contain early returns and the potential to throw exceptions. In these cases, it is not only pointless, but also confusing to declare a\nvariable that may never be used because conditions for an early return are met first.\nNoncompliant code example\n```java\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n  MyClass foo = new MyClass(a);  // Noncompliant; not used before early return\n\n  if (difference < 0) {\n    return false;\n  }\n\n  // ...\n\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n```\nCompliant solution\n```java\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n\n  if (difference < 0) {\n    return false;\n  }\n\n  // ...\n\n  MyClass foo = new MyClass(a);\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1940": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Boolean checks should not be inverted\nDescription: Why is this an issue?\nIt is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.\nNoncompliant code example\n```java\nif ( !(a == 2)) { ...}  // Noncompliant\nboolean b = !(i < 10);  // Noncompliant\n```\nCompliant solution\n```java\nif (a != 2) { ...}\nboolean b = (i >= 10);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1939": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Extensions and implementations should not be redundant\nDescription: Why is this an issue?\nAll classes extend\nObject\nimplicitly. Doing so explicitly is redundant.\nFurther, declaring the implementation of an interface\nand\none if its parents is also redundant. If you implement the interface, you also\nimplicitly implement its parents and there\u2019s no need to do so explicitly.\nNoncompliant code example\n```java\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo\n    extends Object // Noncompliant\n    implements MyFace, MyOtherFace {  // Noncompliant\n  //...\n}\n```\nCompliant solution\n```java\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo implements MyOtherFace {\n  //...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1905": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant casts should not be used\nDescription: Why is this an issue?\nCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\nHowever, there are instances where casting expressions are not needed. These include situations like:\n1. casting a variable to its own type\n2. casting a subclass to a parent class (in the case of polymorphism)\n3. the programming language is capable of automatically converting the given type to another\nThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\nAs a result, it\u2019s generally advised to avoid unnecessary casting expressions. Instead, rely on the language\u2019s type system to ensure type safety and\ncode clarity.\nExceptions\nCasting may be required to distinguish the method to call in the case of overloading:\n```java\nclass A {}\nclass B extends A{}\nclass C {\n  void fun(A a){}\n  void fun(B b){}\n\n  void foo() {\n    B b = new B();\n    fun(b);\n    fun((A) b); // Compliant, required to call the first method so cast is not redundant.\n  }\n}\n```\nHow to fix it\nTo fix your code remove the unnecessary casting expression.\nCode examples\nNoncompliant code example\n```java\nclass Example {\n    public void example(List<String> list) {\n        for (String item: (List<String>) list) {  // Noncompliant, Remove this unnecessary cast to \"List\".\n          //...\n        }\n    }\n}\n```\nCompliant solution\n```java\nclass Example {\n    public void example() {\n        for (String foo : getFoos()) {\n          //...\n        }\n    }\n\n    public List<String> getFoos() {\n        return List.of(\"foo1\", \"foo2\");\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1874": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Deprecated\" code should not be used\nDescription: Why is this an issue?\nCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\nDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\nDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\nCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\n```java\n/**\n * @deprecated  As of release 1.3, replaced by {@link #Foo}\n */\n@Deprecated\npublic class Fum { ... }\n\npublic class Foo {\n  /**\n   * @deprecated  As of release 1.7, replaced by {@link #newMethod()}\n   */\n  @Deprecated\n  public void oldMethod() { ... }\n\n  public void newMethod() { ... }\n}\n\npublic class Bar extends Foo {\n  public void oldMethod() { ... } // Noncompliant; don't override a deprecated method\n}\n\npublic class Baz extends Fum {  // Noncompliant; Fum is deprecated\n  public void myMethod() {\n    Foo foo = new Foo();\n    foo.oldMethod();  // Noncompliant; oldMethod method is deprecated\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1858": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"toString()\" should never be called on a String object\nDescription: Why is this an issue?\nInvoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. This redundant\nconstruction may be optimized by the compiler, but will be confusing in the meantime.\nNoncompliant code example\n```java\nString message = \"hello world\";\nSystem.out.println(message.toString()); // Noncompliant;\n```\nCompliant solution\n```java\nString message = \"hello world\";\nSystem.out.println(message);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1710": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Annotation repetitions should not be wrapped\nDescription: Why is this an issue?\nBefore Java 8, a container annotation was required as wrapper to use multiple instances of the same annotation. As of Java 8, this is no longer\nnecessary. Instead, these annotations should be used directly without a wrapper, resulting in cleaner and more readable code.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\nas repeating annotations were\nintroduced in Java 8.\nCode examples\nNoncompliant code example\n```java\n@SomeAnnotations({  // Noncompliant, wrapper annotations are not necessary in Java 8+\n  @SomeAnnotation(..a..),\n  @SomeAnnotation(..b..),\n  @SomeAnnotation(..c..),\n})\npublic class SomeClass {\n  ...\n}\n```\nCompliant solution\n```java\n@SomeAnnotation(..a..)\n@SomeAnnotation(..b..)\n@SomeAnnotation(..c..)\npublic class SomeClass {\n  ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1698": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"==\" and \"!=\" should not be used when \"equals\" is overridden\nDescription: Why is this an issue?\nIt is equivalent to use the equality\n==\noperator and the\nequals\nmethod to compare two objects if the\nequals\nmethod inherited from\nObject\nhas not been overridden. In this case both checks compare the object references.\nBut as soon as\nequals\nis overridden, two objects not having the same reference but having the same value can be equal. This rule spots\nsuspicious uses of\n==\nand\n!=\noperators on objects whose\nequals\nmethods are overridden.\nNoncompliant code example\n```java\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\n```\nCompliant solution\n```java\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null && firstName.equals(lastName)) { ... };\n```\nExceptions\nComparing two instances of the\nClass\nobject will not raise an issue:\n```java\nClass c;\nif(c == Integer.class) { // No issue raised\n}\n```\nComparing\nEnum\nwill not raise an issue:\n```java\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // it's recommended to activate S4551 to enforce comparison of Enums using ==\n}\n```\nComparing with\nfinal\nreference will not raise an issue:\n```java\nprivate static final Type DEFAULT = new Type();\n\nvoid foo(Type other) {\n  if (other == DEFAULT) { // Compliant\n  //...\n  }\n}\n```\nComparing with\nthis\nwill not raise an issue:\n```java\npublic boolean equals(Object other) {\n    if (this == other) {  // Compliant\n      return false;\n    }\n }\n```\nComparing with\njava.lang.String\nand boxed types\njava.lang.Integer\n, \u2026\u200b will not raise an issue.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1694": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An abstract class should have both abstract and concrete methods\nDescription: Why is this an issue?\nThe purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.\nA class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a concrete class (i.e. remove the\nabstract\nkeyword) with a private constructor.\nA class with only abstract methods and no inheritable behavior should be converted to an interface.\nNoncompliant code example\n```java\npublic abstract class Animal {  // Noncompliant; should be an interface\n  abstract void move();\n  abstract void feed();\n}\n\npublic abstract class Color {  // Noncompliant; should be concrete with a private constructor\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int getRed() {\n    return red;\n  }\n}\n```\nCompliant solution\n```java\npublic interface Animal {\n  void move();\n  void feed();\n}\n\npublic class Color {\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  private Color () {}\n\n  public int getRed() {\n    return red;\n  }\n}\n\npublic abstract class Lamp {\n\n  private boolean switchLamp=false;\n\n  public abstract void glow();\n\n  public void flipSwitch() {\n    switchLamp = !switchLamp;\n    if (switchLamp) {\n      glow();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1659": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Multiple variables should not be declared on the same line\nDescription: Why is this an issue?\nDeclaring multiple variables on one line is difficult to read.\nNoncompliant code example\n```java\nclass MyClass {\n\n  private int a, b;\n\n  public void method(){\n    int c; int d;\n  }\n}\n```\nCompliant solution\n```java\nclass MyClass {\n\n  private int a;\n  private int b;\n\n  public void method(){\n    int c;\n    int d;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1643": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Strings should not be concatenated using '+' in a loop\nDescription: Why is this an issue?\nStrings are immutable objects, so concatenation doesn\u2019t simply add the new String to the end of the existing string. Instead, in each loop\niteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted\nback to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is\npreferred.\nNoncompliant code example\n```java\nString str = \"\";\nfor (int i = 0; i < arrayOfStrings.length ; ++i) {\n  str = str + arrayOfStrings[i];\n}\n```\nCompliant solution\n```java\nStringBuilder bld = new StringBuilder();\n  for (int i = 0; i < arrayOfStrings.length; ++i) {\n    bld.append(arrayOfStrings[i]);\n  }\n  String str = bld.toString();\n```\nBenchmarks\nMethod\nsize\nRuntime\nAverage time\nError margin\nplus\n100\nTemurin 21\n4.19 \u00b5s/op\n\u00b10.34 \u00b5s/op\nplus\n1000\nTemurin 21\n377.08 \u00b5s/op\n\u00b117.36 \u00b5s/op\nplus\n10000\nTemurin 21\n40221.49 \u00b5s/op\n\u00b11342.76 \u00b5s/op\nplus\n100000\nTemurin 21\n5286840.53 \u00b5s/op\n\u00b1185796.75 \u00b5s/op\nstringBuilder\n100\nTemurin 21\n0.97 \u00b5s/op\n\u00b10.03 \u00b5s/op\nstringBuilder\n1000\nTemurin 21\n10.25 \u00b5s/op\n\u00b11.64 \u00b5s/op\nstringBuilder\n10000\nTemurin 21\n93.27 \u00b5s/op\n\u00b116.05 \u00b5s/op\nstringBuilder\n100000\nTemurin 21\n1019.91 \u00b5s/op\n\u00b169.58 \u00b5s/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@Param({\"100\", \"1000\", \"10000\", \"100000\"})\nint size;\nprivate String word = \"append\";\n\n@Benchmark\npublic String plus() {\n  String str = \"\";\n  for (int i = 0; i < size; i++) {\n    str = str + word;\n  }\n  return str;\n}\n\n@Benchmark\npublic String stringBuilder() {\n  StringBuilder builder = new StringBuilder();\n  for (int i = 0; i < size; i++) {\n    builder.append(word);\n  }\n  return builder.toString();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1641": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Sets with elements that are enum values should be replaced with EnumSet\nDescription: Why is this an issue?\nWhen all the elements in a Set are values from the same enum, the Set can be replaced with an EnumSet, which can be much more efficient than other\nsets because the underlying data structure is a simple bitmap.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set<COLOR> warm = new HashSet<COLOR>();\n    warm.add(COLOR.RED);\n    warm.add(COLOR.ORANGE);\n  }\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set<COLOR> warm = EnumSet.of(COLOR.RED, COLOR.ORANGE);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1640": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Maps with keys that are enum values should use the EnumMap implementation\nDescription: Why is this an issue?\nIf all the keys in a\nMap\nare values from a single enum, it is recommended to use an\nEnumMap\nas the specific\nimplementation. An\nEnumMap\n, which has the advantage of knowing all possible keys in advance, is more efficient compared to other\nimplementations, as it can use a simple array as its underlying data structure.\nNoncompliant code example\n```java\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap<Color, String> colorMap = new HashMap<>(); // Noncompliant\n```\nCompliant solution\n```java\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap<Color, String> colorMap = new EnumMap<>(Color.class); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1612": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas should be replaced with method references\nDescription: Why is this an issue?\nMethod or constructor references are more readable than lambda expressions in many situations, and may therefore be preferred.\nHowever, method references are sometimes less concise than lambdas. In such cases, it might be preferrable to keep the lambda expression for better\nreadability. Therefore, this rule only raises issues on lambda expressions where the replacement method reference is shorter.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n, as lambda expressions were\nintroduced in Java 8.\nHow to fix it\nRefer to the called method by its reference instead of wrapping it in a lambda expression.\nFor instance:\n1. nullchecks can be replaced with references toObjects::isNullandObjects::nonNull\n2. Casts can be replaced withSomeClass.class::cast\n3. instanceofcan be replaced withSomeClass.class::isInstance\nCode examples\nNoncompliant code example\n```java\nclass A {\n  void process(List<A> list) {\n    list.stream()\n      .filter(myListValue -> myListValue instanceof B)     // Noncompliant\n      .map(listValueToMap -> (B) listValueToMap)           // Noncompliant\n      .map(bValueToMap -> bValueToMap.<String>getObject()) // Noncompliant\n      .forEach(o -> System.out.println(o));                // Noncompliant\n  }\n}\n\nclass B extends A {\n  <T> T getObject() {\n    return null;\n  }\n}\n```\nCompliant solution\n```java\nclass A {\n  void process(List<A> list) {\n    list.stream()\n      .filter(B.class::isInstance)   // Compliant\n      .map(B.class::cast)            // Compliant\n      .map(B::<String>getObject)     // Compliant\n      .forEach(System.out::println); // Compliant\n  }\n}\n\nclass B extends A {\n  <T> T getObject() {\n    return null;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1611": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Parentheses should be removed from a single lambda parameter when its type is inferred\nDescription: Why is this an issue?\nLambda expressions with only one argument with an inferred type (i.e., no explicit type declaration) can be written without parentheses around that\nsingle parameter. This syntax is simpler, more compact and readable than using parentheses and is therefore preferred.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n, as lambda expressions were\nintroduced in Java 8.\nNoncompliant code example\n```java\n(x) -> x * 2\n```\nCompliant solution\n```java\nx -> x * 2\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1610": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract classes without fields should be converted to interfaces\nDescription: This rule is deprecated, and will eventually be removed.\nWhy is this an issue?\nWith Java 8\u2019s \"default method\" feature, any abstract class without direct or inherited field should be converted into an interface. However, this\nchange may not be appropriate in libraries or other applications where the class is intended to be used as an API.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n.\nNoncompliant code example\n```java\npublic abstract class Car {\n  public abstract void start(Environment c);\n\n  public void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n```\nCompliant solution\n```java\npublic interface Car {\n  public void start(Environment c);\n\n  public default void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1602": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas containing only one statement should not nest this statement in a block\nDescription: This rule raises an issue when a lambda expression uses block notation while expression notation could be used.\nWhy is this an issue?\nThe right-hand side of a lambda expression can be written in two ways:\nExpression notation: the right-hand side is as an expression, such as in\n(a, b) \u2192 a + b\nBlock notation: the right-hand side is a conventional function body with a code block and an optional return statement, such as in\n(a, b)\n  \u2192 {return a + b;}\nBy convention, expression notation is preferred over block notation. Block notation must be used when the function implementation requires more\nthan one statement. However, when the code block consists of only one statement (which may or may not be a\nreturn\nstatement), it can be\nrewritten using expression notation.\nThis convention exists because expression notation has a cleaner, more concise, functional programming style and is regarded as more readable.\nHow to fix it\n1. If the code block consists only of areturnstatement, replace the code block with the argument expression from thereturnstatement.\n2. If the code block consists of a single statement that is not areturnstatement, replace the code block with that statement.\nCode examples\nNoncompliant code example\n```java\n(a, b) -> { return a + b; } // Noncompliant, replace code block with expression\n```\nCompliant solution\n```java\n(a, b) -> a + b             // Compliant\n```\nNoncompliant code example\n```java\nx -> {System.out.println(x+1);} // Noncompliant, replace code block with statement\n```\nCompliant solution\n```java\nx -> System.out.println(x+1)    // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1596": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Collections.EMPTY_LIST\", \"EMPTY_MAP\", and \"EMPTY_SET\" should not be used\nDescription: This rule raises an issue when the\nCollections.EMPTY_*\nfields are used instead of the\nCollections.empty*()\nmethods.\nWhy is this an issue?\nGeneric types (types with type parameters) have been introduced into Java with language version 1.5. If type parameters are specified for a class\nor method, it is still possible to ignore them to keep backward compatibility with older code, which is called the\nraw type\nof the class or\ninterface.\nUsing raw type expressions is highly discouraged because the compiler cannot perform static type checking on them. This means that the compiler\nwill not report typing errors about them at compile time, but a\nClassCastException\nwill be thrown during runtime.\nIn Java 1.5, generics were also added to the Java collections API, and the data structures in\njava.util\n, such as\nList\n,\nSet\n, or\nMap\n, now feature type parameters.\nCollections.EMPTY_LIST\n,\nCollections.EMPTY_SET\n, and\nCollections.EMPTY_MAP\nare relics from before generics, and they return raw lists, sets, or maps, with the limitations mentioned\nabove.\nHow to fix it\nUse:\n1. Collections.emptyList()instead ofCollections.EMPTY_LIST\n2. Collections.emptySet()instead ofCollections.EMPTY_SET\n3. Collections.emptyMap()instead ofCollections.EMPTY_MAP\nIn addition, there are variants of\nCollections.empty*()\navailable also for other collection interfaces, such as\nCollections.emptyIterator()\n,\nCollections.emptyNavigableMap()\n,\nCollections.emptySortedSet()\n.\nCode examples\nNoncompliant code example\n```java\nList<String> collection1 = Collections.EMPTY_LIST;     // Noncompliant, raw List\nSet<Float> collection2 = Collections.EMPTY_SET;        // Noncompliant, raw Set\nMap<Int, String> collection3 = Collections.EMPTY_MAP;  // Noncompliant, raw Map\n```\nCompliant solution\n```java\nList<String> collection1 = Collections.emptyList();    // Compliant, List<String>\nSet<Float> collection2 = Collections.emptySet();       // Compliant, Set<Float>\nMap<Int, String> collection3 = Collections.emptyMap(); // Compliant, Map<Int, String>\n```\nDocumentation\n1. Oracle - Java\u2122 Platform, Standard Edition 8 API Specification,\n  Class Collections\n2. Oracle - The Java\u2122 Tutorials - Raw Types\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1488": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local variables should not be declared and then immediately returned or thrown\nDescription: Why is this an issue?\nDeclaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. This\npractice can make the code harder to read and understand, as it introduces an extra step that doesn\u2019t add any value. Instead of declaring a variable\nand then immediately returning or throwing it, it is generally better to return or throw the value directly. This makes the code cleaner, simpler, and\neasier to understand.\nHow to fix it\nDeclaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. To fix\nthe issue, return or throw the value directly.\nCode examples\nNoncompliant code example\n```java\npublic long computeDurationInMilliseconds() {\n  long duration = (((hours * 60) + minutes) * 60 + seconds) * 1000;\n  return duration;\n}\n```\nCompliant solution\n```java\npublic long computeDurationInMilliseconds() {\n  return (((hours * 60) + minutes) * 60 + seconds) * 1000;\n}\n```\nNoncompliant code example\n```java\npublic void doSomething() {\n  RuntimeException myException = new RuntimeException();\n  throw myException;\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  throw new RuntimeException();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1481": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused local variables should be removed\nDescription: Why is this an issue?\nAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\nWhat is the potential impact?\nHaving unused local variables in your code can lead to several issues:\n1. Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which\n  can distract from the main logic of the code.\n2. Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead\n  to confusion and misinterpretation of the code\u2019s intent.\n3. Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you\n  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected.\n4. Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they\n  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs.\n5. Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,\n  unused variables take up memory space, leading to inefficient use of resources.\nIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\nHow to fix it\nThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation, you just need to remove\nit.\nJava 22 introduces the unnamed variable pattern\n_\n. When a variable declared within a pattern match, an enhanced for loop, or a try\nwith resource is unused, you should replace its name with the unnamed variable pattern to clearly indicate the intent not to use the variable.\nCode examples\nNoncompliant code example\n```java\npublic int numberOfMinutes(int hours) {\n  int seconds = 0;   // Noncompliant: \"seconds\" is unused\n  return hours * 60;\n}\n```\n```java\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, int age) -> name; // Noncompliant: \"age\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic String type(Person p) {\n  return switch (p) {\n    case User user -> \"user\"; // Noncompliant:  \"user\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic int age(Person p) {\n  if (p instanceof User(String name, int age)) { // Noncompliant:  \"name\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    return age;\n  }\n}\n```\n```java\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var el : elements) { // Noncompliant:  \"el\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    count++;\n  }\n  return count;\n}\n```\n```java\npublic void foo() {\n  try (var file = Files.createTempFile(directory, \"temp\", \".txt\")) { // Noncompliant:  \"file\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    System.out.println(\"file created\");\n  }\n}\n```\nCompliant solution\n```java\npublic int numberOfMinutes(int hours) {\n  return hours * 60;\n}\n```\n```java\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, _) -> name; // Compliant\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic String type(Person p) {\n  return switch (p) {\n    case User _ -> \"user\"; // Compliant\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic int age(Person p) {\n  if (p instanceof User(String _, int age)) { // Compliant\n    return age;\n  }\n}\n```\n```java\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var _ : elements) { // Compliant\n    count++;\n  }\n  return count;\n}\n```\n```java\npublic void foo() {\n  try (var _ = Files.createTempFile(directory, \"temp\", \".txt\")) { // Compliant\n    System.out.println(\"file created\");\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1450": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Private fields only used as local variables in methods should become local variables\nDescription: Why is this an issue?\nWhen the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class\ninformation. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.\nNoncompliant code example\n```java\npublic class Foo {\n  private int a;\n  private int b;\n\n  public void doSomething(int y) {\n    a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n    ...\n  }\n\n  public void doSomethingElse(int y) {\n    b = y + 3;\n    ...\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo {\n\n  public void doSomething(int y) {\n    int a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n  }\n\n  public void doSomethingElse(int y) {\n    int b = y + 3;\n    ...\n  }\n}\n```\nExceptions\nThis rule doesn\u2019t raise any issue on annotated field.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1449": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: String operations should not rely on the default system locale\nDescription: Why is this an issue?\nFailure to specify a locale when calling the methods\ntoLowerCase()\n,\ntoUpperCase()\nor\nformat()\non\nString\nobjects means the system default encoding will be used, possibly creating problems with international characters or number\nrepresentations. For instance with the Turkish language, when converting the small letter 'i' to upper case, the result is capital letter 'I' with a\ndot over it.\nCase conversion without a locale may work fine in its \"home\" environment, but break in ways that are extremely difficult to diagnose for customers\nwho use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it\u2019s time to fix them. For locale-sensitive\nstrings, the correct locale should always be used, but\nLocale.ROOT\ncan be used for case-insensitive ones.\nNoncompliant code example\n```java\nmyString.toLowerCase()\n```\nCompliant solution\n```java\nmyString.toLowerCase(Locale.TR)\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1444": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"public static\" fields should be constant\nDescription: Why is this an issue?\nThere is no good reason to declare a field \"public\" and \"static\" without also declaring it \"final\". Most of the time this is a kludge to share a\nstate among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to\nnull\n.\nNoncompliant code example\n```java\npublic class Greeter {\n  public static Foo foo = new Foo();\n  ...\n}\n```\nCompliant solution\n```java\npublic class Greeter {\n  public static final Foo FOO = new Foo();\n  ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-139": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comments should not be located at the end of lines of code\nDescription: Why is this an issue?\nThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\nNoncompliant code example\n```java\nint a1 = b + c; // This is a trailing comment that can be very very long\n```\nCompliant solution\n```java\n// This very long comment is better placed before the line of code\nint a2 = b + c;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-135": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loops should not contain more than a single \"break\" or \"continue\" statement\nDescription: Why is this an issue?\nThe use of\nbreak\nand\ncontinue\nstatements increases the complexity of the control flow and makes it harder to understand\nthe program logic. In order to keep a good program structure, they should not be applied more than once per loop.\nThis rule reports an issue when there is more than one\nbreak\nor\ncontinue\nstatement in a loop. The code should be\nrefactored to increase readability if there is more than one.\nNoncompliant code example\n```java\nfor (int i = 1; i <= 10; i++) {     // Noncompliant; two \"continue\" statements\n  if (i % 2 == 0) {\n    continue;\n  }\n\n  if (i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n```\nCompliant solution\n```java\nfor (int i = 1; i <= 10; i++) {\n  if (i % 2 == 0 || i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n```\nDocumentation\n1. Oracle - Labeled Statements\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1319": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Declarations should use Java collection interfaces such as \"List\" rather than specific implementation classes such as \"LinkedList\"\nDescription: This rule raises an issue when a collection implementation class from\njava.util.*\nis used:\n1. as a return type of apublicmethod.\n2. as an argument type of apublicmethod.\n3. as the type of apublicfield.\nWhy is this an issue?\nThe Java Collections API offers a well-structured hierarchy of interfaces designed to hide collection implementation details. For the various\ncollection data structures like lists, sets, and maps, specific interfaces (\njava.util.List\n,\njava.util.Set\n,\njava.util.Map\n) cover the essential features.\nWhen passing collections as method parameters, return values, or when exposing fields, it is generally recommended to use these interfaces instead\nof the implementing classes. The implementing classes, such as\njava.util.LinkedList\n,\njava.util.ArrayList\n, and\njava.util.HasMap\n, should only be used for collection instantiation. They provide finer control over the performance characteristics of\nthose structures, and developers choose them depending on their use case.\nFor example, if fast random element access is essential,\njava.util.ArrayList\nshould be instantiated. If inserting elements at a random\nposition into a list is crucial, a\njava.util.LinkedList\nshould be preferred. However, this is an implementation detail your API should\nnot expose.\nCode examples\nNoncompliant code example\n```java\npublic class Employees {\n  public final HashSet<Employee> employees   // Noncompliant, field type should be \"Set\"\n    = new HashSet<Employee>();\n\n  public HashSet<Employee> getEmployees() {  // Noncompliant, return type should be \"Set\"\n    return employees;\n  }\n}\n```\nCompliant solution\n```java\npublic class Employees {\n  public final Set<Employee> employees       // Compliant\n    = new HashSet<Employee>();\n\n  public Set<Employee> getEmployees() {      // Compliant\n    return employees;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1315": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"CHECKSTYLE:OFF\" suppression comments\nDescription: Why is this an issue?\nThis rule allows you to track the use of the Checkstyle suppression comment mechanism.\nNoncompliant code example\n```java\n// CHECKSTYLE:OFF\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1312": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loggers should be \"private static final\" and should share a naming convention\nDescription: Why is this an issue?\nRegardless of the logging framework in use (logback, log4j, commons-logging, java.util.logging, \u2026\u200b), loggers should be:\n1. private: never be accessible outside of its parent class. If another class needs to log something, it should instantiate its own\n  logger.\n2. static: not be dependent on an instance of a class (an object). When logging something, contextual information can of course be\n  provided in the messages but the logger should be created at class level to prevent creating a logger along with each object.\n3. final: be created once and only once per class.\nNoncompliant code example\nWith a default regular expression of\nLOG(?:GER)?\n:\n```java\npublic Logger logger = LoggerFactory.getLogger(Foo.class);  // Noncompliant\n```\nCompliant solution\n```java\nprivate static final Logger LOGGER = LoggerFactory.getLogger(Foo.class);\n```\nExceptions\nVariables of type\norg.apache.maven.plugin.logging.Log\nare ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1310": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"NOPMD\" suppression comments \nDescription: Why is this an issue?\nThis rule allows you to track the use of the PMD suppression comment mechanism.\nNoncompliant code example\n```java\n// NOPMD\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1301": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements should have at least 3 \"case\" clauses\nDescription: Why is this an issue?\nswitch\nstatements are useful when there are many different cases depending on the value of the same expression.\nFor just one or two cases, however, the code will be more readable with\nif\nstatements.\nNoncompliant code example\n```java\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n```\nCompliant solution\n```java\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1264": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A \"while\" loop should be used instead of a \"for\" loop\nDescription: Why is this an issue?\nA\nfor\nloop is a type of loop construct that allows a block of code to be executed repeatedly for a fixed number of times. The\nfor\nloop is typically used when the number of iterations is known in advance and consists of three parts:\n1. The initialization statement is executed once at the beginning of the loop. It is used to initialize the loop counter or any other variables\n  that may be used in the loop.\n2. The loop condition is evaluated at the beginning of each iteration, and if it istrue, the code inside the loop is executed.\n3. The update statement is executed at the end of each iteration and is used to update the loop counter or any other variables that may be used in\n  the loop.\n```java\nfor (initialization; termination; increment) { /*...*/ }\n```\nAll three statements are optional. However, when the initialization and update statements are not used, it can be unclear to the reader what the\nloop counter is and how it is being updated. This can make the code harder to understand and maintain.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\nfor (;condition;) { /*...*/ } // Noncompliant; only the condition is specified\n```\nWhen only the condition expression is defined in a\nfor\nloop, a\nwhile\nloop should be used instead to increase readability.\nA\nwhile\nloop consists of a single loop condition and allows a block of code to be executed repeatedly as long as the specified condition\nis true.\nCompliant solution\n```java\nwhile (condition) { /*...*/ }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1228": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Packages should have a javadoc file 'package-info.java'\nDescription: Why is this an issue?\nEach package in a Java project should include a\npackage-info.java\nfile. The purpose of this file is to document the Java package using\njavadoc and declare package annotations.\nCompliant solution\n```java\n/**\n* This package has non null parameters and is documented.\n**/\n@ParametersAreNonnullByDefault\npackage org.foo.bar;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1220": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The default unnamed package should not be used\nDescription: Why is this an issue?\nJava packages serve two purposes:\nStructure\u2009\u2014\u2009Packages give a structure to the set of classes of your project. It is a bad practice to put all classes flat into the source\n  directory of a project without a package structure. A structure helps to mentally break down a project into smaller parts, simplifying readers'\n  understanding of how components are connected and how they interact.\nAvoiding name clashes\u2009\u2014\u2009a class part of the\ndefault package\nif no explicit package name is specified. This can easily cause name\n  collisions when other projects define a class of the same name.\nWhen no package is explicitly specified for the classes in your project, this makes the project harder to understand and may cause name collisions\nwith other projects. Also, classes located in the default package not be accessed from classes within named packages since Java 1.4.\nHow to fix it\nMove your class to a package directory and explicitly state the package\u2019s name at the top of the class. If your project does not have a package\nstructure, think of a structure that fits your needs. The package names should be unique to your project. You can find some best practices when\nchoosing package names in the Ressources section below.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass { /* ... */ } // Noncompliant, no package spacified\n```\nCompliant solution\n```java\npackage org.example; // Compliant\n\npublic class MyClass{ /* ... */ }\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1213": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The members of an interface or class declaration should appear in a pre-defined order\nDescription: Why is this an issue?\nAccording to the Java Code Conventions as defined by Oracle, the members of a class or interface declaration should appear in the following order\nin the source files:\n1. Class variables\n2. Instance variables\n3. Constructors\n4. Methods\nNoncompliant code example\n```java\npublic class Foo{\n   private int field = 0;\n   public boolean isTrue() {...}\n   public Foo() {...}                         // Noncompliant, constructor defined after methods\n   public static final int OPEN = 4;  //Noncompliant, variable defined after constructors and methods\n}\n```\nCompliant solution\n```java\npublic class Foo{\n   public static final int OPEN = 4;\n   private int field = 0;\n   public Foo() {...}\n   public boolean isTrue() {...}\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1210": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"equals(Object obj)\" should be overridden along with the \"compareTo(T obj)\" method\nDescription: Why is this an issue?\nAccording to the Java\nComparable.compareTo(T o)\ndocumentation:\nIt is strongly recommended, but not strictly required that\n(x.compareTo(y)==0) == (x.equals(y))\n.\nGenerally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.\nThe recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"\nIf this rule is violated, weird and unpredictable failures can occur.\nFor example, in Java 5 the\nPriorityQueue.remove()\nmethod relied on\ncompareTo()\n, but since Java 6 it has relied on\nequals()\n.\nNoncompliant code example\n```java\npublic class Foo implements Comparable<Foo> {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Noncompliant as the equals(Object obj) method is not overridden\n}\n```\nCompliant solution\n```java\npublic class Foo implements Comparable<Foo> {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Compliant\n\n  @Override\n  public boolean equals(Object obj) { /* ... */ }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-120": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Package names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions improve readability and allow teams to collaborate efficiently. This rule checks that all package names match a provided\nregular expression.\nHow to fix it\nRename packages with the expected naming convention\nCode examples\nNoncompliant code example\nWith the default regular expression\n^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$\n:\n```java\npackage org.exAmple; // Noncompliant\n```\nCompliant solution\n```java\npackage org.example;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1199": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nested code blocks should not be used\nDescription: Why is this an issue?\nNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\nAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\nThe presence of nested blocks that don\u2019t affect the control flow might suggest possible mistakes in the code.\nExceptions\nThe usage of a code block after a\ncase\nis allowed.\nHow to fix it\nThe nested code blocks should be extracted into separate methods.\nCode examples\nNoncompliant code example\n```java\nclass Example {\n\n    private final Deque<Integer> stack = new LinkedList<>();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          { // Noncompliant - Extract this nested code block into a method\n            int a = stack.pop();\n            int b = stack.pop();\n            int result = a + b;\n            stack.push(result);\n          }\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n}\n```\nCompliant solution\n```java\nclass Example {\n\n    private final Deque<Integer> stack = new LinkedList<>();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          evaluateAdd();\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n\n    private void evaluateAdd() {\n      int a = stack.pop();\n      int b = stack.pop();\n      int result = a + b;\n      stack.push(result);\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1197": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Array designators \"[]\" should be on the type, not the variable\nDescription: Why is this an issue?\nArray designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the\nvariable name to know whether or not a variable is an array.\nNoncompliant code example\n```java\nint matrix[][];   // Noncompliant\nint[] matrix[];   // Noncompliant\n```\nCompliant solution\n```java\nint[][] matrix;   // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1195": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Array designators \"[]\" should be located after the type in method signatures\nDescription: Why is this an issue?\nPlacing the array designators\n[]\nafter the type helps maintain backward compatibility with older versions of the Java SE platform.\nThis syntax contributes to better readability as it becomes easier to distinguish between array types and non-array types. It helps convey the\nintention of the method to both the developer implementing it and the developer using it.\nNoncompliant code example\n```java\npublic class Cube {\n    private int magicNumbers[] = { 42 };      // Noncompliant\n    public int getVector()[] { /* ... */ }    // Noncompliant\n    public int[] getMatrix()[] { /* ... */ }  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class Cube {\n    private int[] magicNumbers = { 42 };      // Compliant\n    public int[] getVector() { /* ... */ }    // Compliant\n    public int[][] getMatrix() { /* ... */ }  // Compliant\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-119": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Type parameter names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type\nparameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class.\nThis rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular\nexpression.\nNoncompliant code example\n```java\npublic class MyClass<TYPE> { // Noncompliant\n  <TYPE> void method(TYPE t) { // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic class MyClass<T> {\n  <T> void method(T t) {\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1185": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Overriding methods should do more than simply call the same method in the super class \nDescription: Why is this an issue?\nOverriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time\nthis is justified is in\nfinal\noverriding methods, where the effect is to lock in the parent class behavior. This rule ignores such\noverrides of\nequals\n,\nhashCode\nand\ntoString\n.\nNoncompliant code example\n```java\npublic void doSomething() {\n  super.doSomething();\n}\n\n@Override\npublic boolean isLegal(Action action) {\n  return super.isLegal(action);\n}\n```\nCompliant solution\n```java\n@Override\npublic boolean isLegal(Action action) {         // Compliant - not simply forwarding the call\n  return super.isLegal(new Action(/* ... */));\n}\n\n@Id\n@Override\npublic int getId() {                            // Compliant - there is annotation different from @Override\n  return super.getId();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1182": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes that override \"clone\" should be \"Cloneable\" and call \"super.clone()\"\nDescription: Why is this an issue?\nCloneable\nis the marker\nInterface\nthat indicates that\nclone()\nmay be called on an object. Overriding\nclone()\nwithout implementing\nCloneable\ncan be helpful if you want to control how subclasses clone themselves, but otherwise,\nit\u2019s probably a mistake.\nThe usual convention for\nObject.clone()\naccording to Oracle\u2019s Javadoc is:\nx.clone() != x\nx.clone().getClass() == x.getClass()\nx.clone().equals(x)\nObtaining the object that will be returned by calling\nsuper.clone()\nhelps to satisfy those invariants:\nsuper.clone()\nreturns a new object instance\nsuper.clone()\nreturns an object of the same type as the one\nclone()\nwas called on\nObject.clone()\nperforms a shallow copy of the object\u2019s state.\nHow to fix it\nEnsure that the\nclone()\nmethod calls\nsuper.clone()\nand implement\nCloneable\nin the class or remove the clone\nmethod.\nCode examples\nNoncompliant code example\n```java\nclass BaseClass {  // Noncompliant - should implement Cloneable\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Noncompliant - should return the super.clone() instance\n    return new BaseClass();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Throws a ClassCastException because invariant #2 is violated\n  }\n}\n```\nCompliant solution\n```java\nclass BaseClass implements Cloneable {\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Compliant\n    return super.clone();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Displays \"Hello, world!\" as expected. Invariant #2 is satisfied\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-118": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract class names should comply with a naming convention\nDescription: Why is this an issue?\nSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nabstract\nclass names match a provided regular expression. If a non-abstract class match the regular expression, an issue is raised to\nsuggest to either make it abstract or to rename it.\nNoncompliant code example\nWith the default regular expression:\n^Abstract[A-Z][a-zA-Z0-9]*$\n:\n```java\nabstract class MyClass { // Noncompliant\n}\n\nclass AbstractLikeClass { // Noncompliant\n}\n```\nCompliant solution\n```java\nabstract class AbstractClass {\n}\n\nclass LikeClass {\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1170": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Public constants and fields initialized at declaration should be \"static final\" rather than merely \"final\"\nDescription: Why is this an issue?\nMaking a\npublic\nconstant just\nfinal\nas opposed to\nstatic final\nleads to duplicating its value for every\ninstance of the class, uselessly increasing the amount of memory required to execute the application.\nFurther, when a non-\npublic\n,\nfinal\nfield isn\u2019t also\nstatic\n, it implies that different instances can have\ndifferent values. However, initializing a non-\nstatic final\nfield in its declaration forces every instance to have the same value. So such\nfields should either be made\nstatic\nor initialized in the constructor.\nNoncompliant code example\n```java\npublic class Myclass {\n  public final int THRESHOLD = 3;\n}\n```\nCompliant solution\n```java\npublic class Myclass {\n  public static final int THRESHOLD = 3;    // Compliant\n}\n```\nExceptions\nNo issues are reported on final fields of inner classes whose type is not a primitive or a String. Indeed according to the Java specification:\nAn inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers (\u00a78.7)\n  or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields (\u00a715.28).\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-117": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local variable and method parameter names should comply with a naming convention\nDescription: Local variables and method parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable or\nmethod parameter to follow your project\u2019s naming convention to address this issue.\nWhy is this an issue?\nA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\nLocal\nvariables and method parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily recognizable\npattern.\nAdhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to maintain and\ndebug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\nThis rule checks that local variable and method parameter names match a provided regular expression.\nWhat is the potential impact?\nInconsistent naming of local variables and method parameters can lead to several issues in your code:\n1. Reduced Readability: Inconsistent local variable and method parameter names make the code harder to read and understand;\n  consequently, it is more difficult to identify the purpose of each variable, spot errors, or comprehend the logic.\n2. Difficulty in Identifying Variables: The local variables and method parameters that don\u2019t adhere to a standard naming\n  convention are challenging to identify; thus, the coding process slows down, especially when dealing with a large codebase.\n3. Increased Risk of Errors: Inconsistent or unclear local variable and method parameter names lead to misunderstandings about\n  what the variable represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code.\n4. Collaboration Difficulties: In a team setting, inconsistent naming conventions lead to confusion and miscommunication among\n  team members.\n5. Difficulty in Code Maintenance: Inconsistent naming leads to an inconsistent codebase. The code is difficult to understand,\n  and making changes feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain.\nIn summary, not adhering to a naming convention for local variables and method parameters can lead to confusion, errors, and inefficiencies, making\nthe code harder to read, understand, and maintain.\nExceptions\nLoop counters are ignored by this rule.\n```java\nfor (int i_1 = 0; i_1 < limit; i_1++) {  // Compliant\n  // ...\n}\n```\nas well as one-character\ncatch\nvariables:\n```java\ntry {\n//...\n} catch (Exception e) { // Compliant\n}\n```\nHow to fix it\nFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\nCode examples\nNoncompliant code example\nWith the default regular expression\n^[a-z][a-zA-Z0-9]*$\n:\n```java\npublic class MyClass {\n    public void doSomething(int myParam) {\n      int LOCAL;    // Noncompliant\n      // ...\n    }\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n    public void doSomething(int my_param) {\n      int local;\n      // ...\n    }\n}\n```\nDocumentation\n1. Oracle -Java SE Naming Conventions\n2. Geeksforgeeks -Java Naming Conventions\n3. Wikipedia -Naming Convention (programming)\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1165": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception classes should have final fields\nDescription: Why is this an issue?\nWhen a class has all\nfinal\nfields, the compiler ensures that the object\u2019s state remains constant. It also enforces a clear design\nintent of immutability, making the class easier to reason about and use correctly.\nExceptions are meant to represent the application\u2019s state at the point at which an error occurred. Making all fields in an\nException\nclass\nfinal\nensures that these class fields do not change after initialization.\nNoncompliant code example\n```java\npublic class MyException extends Exception {\n\n  private int status;                        // Noncompliant\n\n  public MyException(String message) {\n    super(message);\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n}\n```\nCompliant solution\n```java\npublic class MyException extends Exception {\n\n  private final int status;                  // Compliant\n\n  public MyException(String message, int status) {\n    super(message);\n    this.status = status;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-116": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Field names should comply with a naming convention\nDescription: Why is this an issue?\nA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\nThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\nThis rule checks that field names match a provided regular expression.\nUsing the regular expression\n^[a-z][a-zA-Z0-9]*$\n, the noncompliant code below:\n```java\nclass MyClass {\n   private int my_field;\n}\n```\nShould be replaced with:\n```java\nclass MyClass {\n   private int myField;\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1158": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Primitive wrappers should not be instantiated only for \"toString\" or \"compareTo\" calls\nDescription: Why is this an issue?\nCreating temporary primitive wrapper objects only for\nString\nconversion or the use of the\ncompareTo()\nmethod is\ninefficient.\nInstead, the static\ntoString()\nor\ncompare()\nmethod of the primitive wrapper class should be used.\nNoncompliant code example\n```java\nprivate int isZero(int value){\n    return Integer.valueOf(value).compareTo(0); // Noncompliant\n}\nprivate String convert(int value){\n    return Integer.valueOf(value).toString(); // Noncompliant\n}\n```\nCompliant solution\n```java\nprivate int isZero(int value){\n    return Integer.compare(value, 0); // Compliant\n}\nprivate String convert(int value){\n    return Integer.toString(value); // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1157": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Case insensitive string comparisons should be made without intermediate upper or lower casing\nDescription: Why is this an issue?\nUsing\ntoLowerCase()\nor\ntoUpperCase()\nto make case insensitive comparisons is inefficient because it requires the creation\nof temporary, intermediate\nString\nobjects.\nNoncompliant code example\n```java\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.toUpperCase().equals(bar);               // Noncompliant\n    boolean result2 = foo.equals(bar.toUpperCase());               // Noncompliant\n    boolean result3 = foo.toLowerCase().equals(bar.toLowerCase()); // Noncompliant\n}\n```\nCompliant solution\n```java\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.equalsIgnoreCase(bar);                    // Compliant\n}\n```\nExceptions\nNo issue will be raised when a locale is specified because the result could be different from\nequalsIgnoreCase()\n. (e.g.: using the\nTurkish locale)\n```java\nprivate void compareStrings(String foo, String bar, java.util.Locale locale){\n    boolean result1 = foo.toUpperCase(locale).equals(bar);         // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1155": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Collection.isEmpty()\" should be used to test for emptiness\nDescription: Why is this an issue?\nWhen you call\nisEmpty()\n, it clearly communicates the code\u2019s intention, which is to check if the collection is empty. Using\nsize() == 0\nfor this purpose is less direct and makes the code slightly more complex.\nMoreover, depending on the implementation, the\nsize()\nmethod can have a time complexity of\nO(n)\nwhere\nn\nis\nthe number of elements in the collection. On the other hand,\nisEmpty()\nsimply checks if there is at least one element in the collection,\nwhich is a constant time operation,\nO(1)\n.\n```java\npublic class MyClass {\n  public void doSomething(Collection<String> myCollection) {\n    if (myCollection.size() == 0) { // Noncompliant\n      doSomethingElse();\n    }\n  }\n}\n```\nPrefer using\nisEmpty()\nto test for emptiness over\nsize()\n.\n```java\npublic class MyClass {\n  public void doSomething(Collection<String> myCollection) {\n    if (myCollection.isEmpty()) {\n      doSomethingElse();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1153": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"String.valueOf()\" should not be appended to a \"String\"\nDescription: Why is this an issue?\nAppending\nString.valueOf()\nto a\nString\ndecreases the code readability.\nThe argument passed to\nString.valueOf()\nshould be directly appended instead.\nNoncompliant code example\n```java\nString message = \"Output is \" + String.valueOf(12);\n```\nCompliant solution\n```java\nString message = \"Output is \" + 12;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-114": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Interface names should comply with a naming convention\nDescription: Why is this an issue?\nSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\ninterface names match a provided regular expression.\nNoncompliant code example\nWith the default regular expression\n^[A-Z][a-zA-Z0-9]*$\n:\n```java\npublic interface myInterface {...} // Noncompliant\n```\nCompliant solution\n```java\npublic interface MyInterface {...}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1132": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Strings literals should be placed on the left side when checking for equality\nDescription: Why is this an issue?\nIt is preferable to place string literals on the left-hand side of an\nequals()\nor\nequalsIgnoreCase()\nmethod call.\nThis prevents null pointer exceptions from being raised, as a string literal can never be null by definition.\nNoncompliant code example\n```java\nString myString = null;\n\nSystem.out.println(\"Equal? \" + myString.equals(\"foo\"));                        // Noncompliant; will raise a NPE\nSystem.out.println(\"Equal? \" + (myString != null && myString.equals(\"foo\")));  // Noncompliant; null check could be removed\n```\nCompliant solution\n```java\nSystem.out.println(\"Equal?\" + \"foo\".equals(myString));                         // properly deals with the null case\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1130": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exceptions in \"throws\" clauses should not be superfluous\nDescription: Why is this an issue?\nSuperfluous exceptions within\nthrows\nclauses have negative effects on the readability and maintainability of the code. An exception in\na\nthrows\nclause is superfluous if it is:\n1. listed multiple times\n2. a subclass of another listed exception\n3. not actually thrown by any execution path of the method\nNoncompliant code example\n```java\nvoid foo() throws MyException, MyException {}  // Noncompliant; should be listed once\nvoid bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable\nvoid boo() throws IOException { // Noncompliant; IOException cannot be thrown\n  System.out.println(\"Hi!\");\n}\n```\nCompliant solution\n```java\nvoid foo() throws MyException {}\nvoid bar() throws Throwable {}\nvoid boo() {\n  System.out.println(\"Hi!\");\n}\n```\nExceptions\nThe rule will not raise any issue for exceptions that cannot be thrown from the method body:\n1. in interfacedefaultmethods\n2. in overriding and implementating methods\n3. in non-private methods that onlythrow, have empty bodies, or a single return statement.\n4. in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper\n  JavaDoc\n```java\ninterface MyInterface {\n  default void defaultMethod() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n  void doSomething() throws IOException;\n}\n\nclass A implements MyInterface {\n  @Override\n  void doSomething() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n\n  public void emptyBody() throws IOException {}\n\n  protected void singleThrowStatement() throws IOException {\n    throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n  }\n\n  Object singleReturnStatement() throws IOException {\n    return null;\n  }\n\n  /**\n   * @throws IOException Overriding classes may throw this exception if they print values into a file\n   */\n  protected void overridable() throws IOException { // no issue, method is overridable and the exception has proper javadoc\n    System.out.println(\"foo\");\n  }\n}\n```\nAlso, the rule will not raise issues on\nRuntimeException\n, or one of its sub-classes, because documenting runtime exceptions which\ncould be thrown can ultimately help users of the method understand its behavior.\n```java\nclass B {\n  int possibleDivisionByZero(int a, int b) throws ArithmeticException {\n      return a / b;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-113": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should end with a newline\nDescription: Why is this an issue?\nSome tools work better when files end with a newline.\nThis rule simply generates an issue if it is missing.\nFor example, a Git diff looks like this if the empty line is missing at the end of the file:\n```java\n+class Test {\n+}\n\\ No newline at end of file\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1128": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnecessary imports should be removed\nDescription: Why is this an issue?\nUnnecessary imports refer to importing types that are not used or referenced anywhere in the code.\nAlthough they don\u2019t affect the runtime behavior of the application after compilation, removing them will:\n1. Improve the readability and maintainability of the code.\n2. Help avoid potential naming conflicts.\n3. Improve the build time, as the compiler has fewer lines to read and fewer types to resolve.\n4. Reduce the number of items the code editor will show for auto-completion, thereby showing fewer irrelevant suggestions.\nExceptions\nImports for types mentioned in Javadocs are ignored.\nHow to fix it\nWhile it\u2019s not difficult to remove these unneeded lines manually, modern code editors support the removal of every unnecessary import with a single\nclick from every file of the project.\nCode examples\nNoncompliant code example\n```java\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.*;     // Noncompliant - package is imported twice\nimport java.lang.Runnable;  // Noncompliant - java.lang is imported by default\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n```\nCompliant solution\n```java\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n```\nDocumentation\n1. Java packages\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1126": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Return of boolean expressions should not be wrapped into an \"if-then-else\" statement\nDescription: Why is this an issue?\nReturn of boolean literal statements wrapped into\nif-then-else\nones should be simplified.\nSimilarly, method invocations wrapped into\nif-then-else\ndiffering only from boolean literals should be simplified into a single\ninvocation.\nNoncompliant code example\n```java\nboolean foo(Object param) {\n  if (expression) { // Noncompliant\n    bar(param, true, \"qix\");\n  } else {\n    bar(param, false, \"qix\");\n  }\n\n  if (expression) {  // Noncompliant\n    return true;\n  } else {\n    return false;\n  }\n}\n```\nCompliant solution\n```java\nboolean foo(Object param) {\n  bar(param, expression, \"qix\");\n\n  return expression;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1125": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Boolean literals should not be redundant\nDescription: Why is this an issue?\nA boolean literal can be represented in two different ways:\ntrue\nor\nfalse\n. They can be combined with logical operators\n(\n!, &&, ||, ==, !=\n) to produce logical expressions that represent truth values. However, comparing a boolean literal to a\nvariable or expression that evaluates to a boolean value is unnecessary and can make the code harder to read and understand. The more complex a\nboolean expression is, the harder it will be for developers to understand its meaning and expected behavior, and it will favour the introduction of\nnew bugs.\nHow to fix it\nRemove redundant boolean literals from expressions to improve readability and make the code more maintainable.\nCode examples\nNoncompliant code example\n```java\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n```\nCompliant solution\n```java\nif (booleanMethod()) { /* ... */ }\nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() && exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() && exp;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1124": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Modifiers should be declared in the correct order\nDescription: Why is this an issue?\nThe Java Language Specification recommends listing modifiers in the following order:\nAnnotations\npublic\nprotected\nprivate\nabstract\nstatic\nfinal\ntransient\nvolatile\nsynchronized\nnative\ndefault\nstrictfp\nNot following this convention has no technical impact, but will reduce the code\u2019s readability because most developers are used to the standard\norder.\nNoncompliant code example\n```java\nstatic public void main(String[] args) {   // Noncompliant\n}\n```\nCompliant solution\n```java\npublic static void main(String[] args) {   // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1120": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Source code should be indented consistently\nDescription: Indentation should be consistent to make the code easy to read, review and modify. To fix this issue, change the indentation so that the text\nstarts at the expected column.\nWhy is this an issue?\nConsistent indentation is a simple and effective way to improve the code\u2019s readability. It reduces the differences that are committed to source\ncontrol systems, making code reviews easier.\nThis rule raises an issue when the indentation does not match the configured value. Only the first line of a badly indented section is\nreported.\nThe rule behaves consistently when the indentation settings of the IDE use\nspaces\ninstead of\ntabs\n. Using\ntabs\ncan lead\nto inconsistent indentation because the width of a\ntab\ncan be configured differently in different environments.\nWhat is the potential impact?\nThe readability is decreased. It becomes more tedious to review and modify the code.\nHow to fix it\nChange the indentation so that the text starts at the expected column. The expected column should be the configured indent size multiplied by the\nlevel at which the code block is nested.\nCode examples\nNoncompliant code example\nWith an indent size of 2:\n```java\nclass Foo {\n  public int a;\n   public int b;   // Noncompliant, expected to start at column 4\n\n...\n\n  public void doSomething() {\n    if(something) {\n          doSomethingElse();  // Noncompliant, expected to start at column 6\n  }   // Noncompliant, expected to start at column 4\n  }\n}\n```\nCompliant solution\n```java\nclass Foo {\n  public int a;\n  public int b;\n\n...\n\n  public void doSomething() {\n    if(something) {\n      doSomethingElse();\n    }\n  }\n}\n```\nGoing the extra mile\nYou can adopt a tool or configure your IDE to take care of code formatting automatically.\nExternal coding guidelines\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1116": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Empty statements should be removed\nDescription: Why is this an issue?\nEmpty statements represented by a semicolon\n;\nare statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don\u2019t add value and lead to confusion and\nerrors.\nCode examples\nNoncompliant code example\n```java\nvoid doSomething() {\n  ; // Noncompliant - was used as a kind of TODO marker\n}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");; // Noncompliant - double ;\n  // ...\n}\n```\nCompliant solution\n```java\nvoid doSomething() {}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");\n  // ...\n  for (int i = 0; i < 3; i++) ; // Compliant if unique statement of a loop\n  // ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1109": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A close curly brace should be located at the beginning of a line\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.\nNoncompliant code example\n```java\nif(condition) {\n  doSomething();}\n```\nCompliant solution\n```java\nif(condition) {\n  doSomething();\n}\n```\nExceptions\nWhen blocks are inlined (open and close curly braces on the same line), no issue is triggered.\n```java\nif(condition) {doSomething();}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1108": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be on two different lines\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to collaborate efficiently.\nThis rule makes it mandatory to place a closing curly brace and the next\nelse\n,\ncatch\nor\nfinally\nkeyword on\ntwo different lines.\nNoncompliant code example\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {          // Noncompliant\n    doSomethingElse();\n  }\n  else {                               // Compliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  }\n  else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  }\n  catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1107": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be located on the same line\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to collaborate efficiently.\nThis rule makes it mandatory to place closing curly braces on the same line as the next\nelse\n,\ncatch\nor\nfinally\nkeywords.\nNoncompliant code example\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {                               // Noncompliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {                            // Noncompliant\n    closeConnection();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  } else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  } finally {\n    closeConnection();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1106": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An open curly brace should be located at the beginning of a line\nDescription: Why is this an issue?\nShared coding conventions make it possible to collaborate efficiently. This rule makes it mandatory to place the open curly brace at the beginning\nof a line.\nNoncompliant code example\n```java\npublic void myMethod {  // Noncompliant\n  if(something) {  // Noncompliant\n    executeTask();\n  } else {  // Noncompliant\n    doSomethingElse();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod\n{\n  if(something)\n  {\n    executeTask();\n  } else\n  {\n    doSomethingElse();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1105": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An open curly brace should be located at the end of a line\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate effectively. This rule raises an issue when an open curly brace is not placed at the end of a\nline of code.\nNoncompliant code example\n```java\nif(condition)\n{\n  doSomething();\n}\n```\nCompliant solution\n```java\nif(condition) {\n  doSomething();\n}\n```\nExceptions\nWhen blocks are inlined (left and right curly braces on the same line), no issue is triggered.\n```java\nif(condition) {doSomething();}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1104": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class variable fields should not have public accessibility\nDescription: Why is this an issue?\nPublic fields in public classes do not respect the encapsulation principle and have three main disadvantages:\n1. Additional behavior such as validation cannot be added.\n2. The internal representation is exposed, and cannot be changed afterwards.\n3. Member values are subject to change from anywhere in the code and may not meet the programmer\u2019s assumptions.\nTo prevent unauthorized modifications, private attributes and accessor methods (set and get) should be used.\nWhat is the potential impact?\nPublic fields can be modified by any part of the code and this can lead to unexpected changes and hard-to-trace bugs.\nPublic fields don\u2019t hide the implementation details. As a consequence, it is no longer possible to change how the data is stored internally without\nimpacting the client code of the class.\nThe code is harder to maintain.\nExceptions\nThis rule ignores\npublic final\nfields because they are not modifiable. Also, annotated fields, whatever the annotation(s) will be\nignored, as annotations are often used by injection frameworks, which in exchange require having public fields.\nHow to fix it\nDepending on your need there are multiple options:\n1. Encapsulate the fieldMake the field private.Define methods to get and set the value of the field.These methods are commonly known as getter and setter methods and are prefixed bygetandsetfollowed by the name of the field.Note:as a bonus it is now possible to monitor value changes\n      using breakpoints.\n2. Make the field private.\n3. Define methods to get and set the value of the field.These methods are commonly known as getter and setter methods and are prefixed bygetandsetfollowed by the name of the field.Note:as a bonus it is now possible to monitor value changes\n      using breakpoints.\n4. Mark the field aspublic finalif it is not supposed to change.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  public String firstName;                       // Noncompliant\n\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  private String firstName;\n\n  public String getFirstName() {\n    return firstName;\n  }\n\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n\n}\n```\nHow does this work?\nBy having a setter and a getter the code can control how the field is accessed and modified. For example, adding validation in the setter method\nwill ensure that only valid values are set.\nThe access modifiers on the setter can also be changed to\nprivate\nor\nprotected\nto restrain which code can modify the\nvalue.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-1075": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: URIs should not be hardcoded\nDescription: Why is this an issue?\nHard-coding a URI makes it difficult to test a program for a variety of reasons:\n1. path literals are not always portable across operating systems\n2. a given absolute path may not exist in a specific test environment\n3. a specified Internet URL may not be available when executing the tests\n4. production environment filesystems usually differ from the development environment\nIn addition, hard-coded URIs can contain sensitive information, like IP addresses, and they should not be stored in the code.\nFor all those reasons, a URI should never be hard coded. Instead, it should be replaced by a customizable parameter.\nFurther, even if the elements of a URI are obtained dynamically, portability can still be limited if the path delimiters are hard-coded.\nThis rule raises an issue when URIs or path delimiters are hard-coded.\nExceptions\nThis rule does not raise an issue when:\n1. A constant path is relative and contains at most two parts.\n2. A constant path is used in an annotation\n3. A path is annotated\nHow to fix it\nCode examples\nNoncompliant code example\n```java\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public Collection<User> listUsers() {\n    File userList = new File(\"/home/mylogin/Dev/users.txt\"); // Noncompliant\n    Collection<User> users = parse(userList);\n    return users;\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo {\n  // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.\n  private Configuration config;\n  public Foo(Configuration myConfig) {\n    this.config = myConfig;\n  }\n  public Collection<User> listUsers() {\n    // Find here the way to get the correct folder, in this case using the Configuration object\n    String listingFolder = config.getProperty(\"myApplication.listingFolder\");\n    // and use this parameter instead of the hard coded path\n    File userList = new File(listingFolder, \"users.txt\"); // Compliant\n    Collection<User> users = parse(userList);\n    return users;\n  }\n}\n```\nExceptions examples:\n```java\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public static final String ACCOUNT = \"/account/group/list.html\"; // Compliant path is used in an annotation\n\n  @Value(\"${base.url}\" + ACCOUNT)\n  private String groupUrl;\n\n  @MyAnnotation()\n  String path = \"/default/url/for/site\"; // Compliant path is annotated\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-105": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tabulation characters should not be used\nDescription: Why is this an issue?\nThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\nThat is why using spaces is preferable.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-101": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently.\nThis rule raises an issue when a class name does not match a provided regular expression.\nFor example, with the default provided regular expression\n^[A-Z][a-zA-Z0-9]*$\n, the class:\n```java\nclass my_class {...} // Noncompliant\n```\nshould be renamed to\n```java\nclass MyClass {...}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n",
    "RSPEC-100": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Method names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently.\nThis rule raises an issue when a method name does not match a provided regular expression.\nFor example, with the default provided regular expression\n^[a-z][a-zA-Z0-9]*$\n, the method:\n```java\npublic int DoSomething(){...} // Noncompliant\n```\nshould be renamed to\n```java\npublic int doSomething(){...}\n```\nExceptions\nOverriding methods are excluded.\n```java\n@Override\npublic int Do_Something(){...} // Compliant by exception\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file\n"
}
# Default prompt for when no specific rule prompt is found
rule_prompt_map['DEFAULT_PROMPT'] = '''
You are a code quality expert. The following code has been flagged by SonarQube as having a code smell that needs to be fixed.

Code smell details:
- Rule: {rule}
- Message: {message}
- Severity: {severity}
- Lines: {start_line}-{end_line}

Please analyze the code and fix the identified code smell while maintaining the original functionality.

Code lines to refactor::\n```java\n{{replace_code_smell_lines_here}}
\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\nFormat your output as only refactored java Code file

Return only the corrected code without any explanations or markdown formatting.
'''
