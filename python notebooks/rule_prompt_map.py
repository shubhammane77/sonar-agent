rule_prompt_map = {
    "RSPEC-923": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Functions should not be defined with a variable number of arguments\nDescription: Why is this an issue?\nAs stated per effective java :\nVarargs methods are a convenient way to define methods that require a variable number of arguments, but they should not be overused. They can\n  produce confusing results if used inappropriately.\nNoncompliant code example\n```java\nvoid fun ( String... strings )\t// Noncompliant\n{\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-888": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Equality operators should not be used in \"for\" loop termination conditions\nDescription: Why is this an issue?\nTesting\nfor\nloop termination using an equality operator (\n==\nand\n!=\n) is dangerous, because it could set up an\ninfinite loop. Using a broader relational operator instead casts a wider net, and makes it harder (but not impossible) to accidentally write an\ninfinite loop.\nNoncompliant code example\n```java\nfor (int i = 1; i != 10; i += 2)  // Noncompliant. Infinite; i goes from 9 straight to 11.\n{\n  //...\n}\n```\nCompliant solution\n```java\nfor (int i = 1; i <= 10; i += 2)  // Compliant\n{\n  //...\n}\n```\nExceptions\nEquality operators are ignored if the loop counter is not modified within the body of the loop and either:\n1. starts below the ending value and is incremented by 1 on each iteration.\n2. starts above the ending value and is decremented by 1 on each iteration.\nEquality operators are also ignored when the test is against\nnull\n.\n```java\nfor (int i = 0; arr[i] != null; i++) {\n  // ...\n}\n\nfor (int i = 0; (item = arr[i]) != null; i++) {\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-881": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression\nDescription: Why is this an issue?\nThe use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:\n1. It can significantly impair the readability of the code.\n2. It introduces additional side effects into a statement, with the potential for undefined behavior.\n3. It is safer to use these operators in isolation from any other arithmetic operators.\nNoncompliant code example\n```java\nu8a = ++u8b + u8c--;\nfoo = bar++ / 4;\n```\nCompliant solution\nThe following sequence is clearer and therefore safer:\n```java\n++u8b;\nu8a = u8b + u8c;\nu8c--;\nfoo = bar / 4;\nbar++;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-864": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Limited dependence should be placed on operator precedence\nDescription: Why is this an issue?\nThe rules of operator precedence are complicated and can lead to errors. For this reason, parentheses should be used for clarification in complex\nstatements. However, this does not mean that parentheses should be gratuitously added around every operation.\nThis rule raises issues when\n&&\nand\n||\nare used in combination, when assignment and equality or relational\noperators are used together in a condition, and for other operator combinations according to the following table:\n+\n,\n-\n,\n*\n,\n/\n,\n%\n<<\n,\n>>\n,\n>>>\n&\n^\n|\n+\n,\n-\n,\n*\n,\n/\n,\n%\nx\nx\nx\nx\n<<\n,\n>>\n,\n>>>\nx\nx\nx\nx\n&\nx\nx\nx\nx\n^\nx\nx\nx\nx\n|\nx\nx\nx\nx\nThis rule also raises an issue when the \"true\" or \"false\" expression of a ternary operator is not trivial and not wrapped inside parentheses.\nNoncompliant code example\n```java\nx = a + b - c;\nx = a + 1 << b;  // Noncompliant\ny = a == b ? a * 2 : a + b;  // Noncompliant\n\nif ( a > b || c < d || a == d) {...}\nif ( a > b && c < d || a == b) {...}  // Noncompliant\nif (a = f(b,c) == 1) { ... } // Noncompliant; == evaluated first\n```\nCompliant solution\n```java\nx = a + b - c;\nx = (a + 1) << b;\ny = a == b ? (a * 2) : (a + b);\n\nif ( a > b || c < d || a == d) {...}\nif ( (a > b && c < d) || a == b) {...}\nif ( (a = f(b,c)) == 1) { ... }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-818": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Literal suffixes should be upper case\nDescription: Why is this an issue?\nUsing upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\nNoncompliant code example\n```java\nlong long1 = 1l; // Noncompliant\nfloat float1 = 1.0f; // Noncompliant\ndouble double1 = 1.0d; // Noncompliant\n```\nCompliant solution\n```java\nlong long1 = 1L;\nfloat float1 = 1.0F;\ndouble double1 = 1.0D;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7629": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: When a defaultFinisher is passed to a Gatherer factory, use the overload that does not take a finisher\nDescription: Why is this an issue?\nPassing an empty finisher to\nGatherer.of\nor to\nGatherer.ofSequential\nprovides no additional value and removing the\nfinisher clearly communicates that no finisher is applied.\nHow to fix it\nCall the overload of\nGatherer.of\nor\nGatherer.ofSequential\nthat does not take a finisher.\nCode examples\nNoncompliant code example\n```java\nGatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n  () -> new AtomicInteger(-1),\n  (state, number, downstream) -> {\n    if (state.get() < 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  },\n  Gatherer.defaultFinisher()); // Noncompliant: useless finisher\n```\nCompliant solution\n```java\nGatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n  () -> new AtomicInteger(-1),\n  (state, number, downstream) -> {\n    if (state.get() < 0) {\n      state.set(number);\n      return true;\n    }\n    return downstream.push(number - state.get());\n  }); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7482": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Don't provide an initializer for a stateless stream gatherer\nDescription: Why is this an issue?\nStateless stream gatherers, which process each element of the stream independently, don\u2019t need an initializer function. That\u2019s because the role of\nthe initializer function is to set up the gatherer\u2019s private state object.\nThe gatherer interface provides factory methods that create gatherers without taking an initializer as an argument:\n1. ofSequential(Gatherer.Integrator<Void,T,R> integrator)\n2. ofSequential(Gatherer.Integrator<Void,T,R> integrator, BiConsumer<Void, Gatherer.Downstream<? super R>>\n  finisher)\nUsing these specific factory methods to create stateless gatherers is preferable because it clearly communicates their stateless nature.\nThis rule reports the use of\nofSequential(Gatherer.Integrator<Void,T,R> integrator, BiConsumer<Void, Gatherer.Downstream<? super\nR>> finisher)\nwhen it returns a stateless gatherer.\nCode examples\nNoncompliant code example\n```java\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.<Integer, Void, Integer>ofSequential(\n      () -> null, // Noncompliant: unnecessary initializer\n      (_, element, downstream) -> {\n        if (element >= start && element <= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -> downstream.push(-1)\n    );\n}\n```\nCompliant solution\n```java\nprivate static Gatherer inRange(int start, int end) {\n    return Gatherer.<Integer, Integer>ofSequential(\n      (_, element, downstream) -> {\n        if (element >= start && element <= end)\n          return downstream.push(element - start);\n        return !downstream.isRejecting();\n      },\n      (_, downstream) -> downstream.push(-1)\n    );\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7481": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Gatherer.ofSequential() should be used to build sequential gathers\nDescription: Why is this an issue?\nWhen a method uses a\nGatherer.of(\u2026\u200b)\nfactory and provides a combiner function that always throws an exception, this implicitly signals\nthat the gatherer is designed for sequential processing. The\njava.util.stream.Gatherer\nAPI provides\nGatherer.ofSequential(\u2026\u200b)\nfactories which clearly indicates that the gatherer is intended for sequential streams. Using such a factory\nimproves code clarity, makes the intended processing model explicit, and avoids the need for a dummy or throwing combiner.\nHow to fix it\nUse\nGatherer.ofSequential\ninstead of\nGatherer.of\n.\nCode examples\nNoncompliant code example\n```java\npublic static List<Integer> diffWithFirstPositive(List<Integer> list) {\n    Gatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.of(\n      () -> new AtomicInteger(-1),\n      (state, number, downstream) -> {\n        if (state.get() < 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      (_, _) -> {\n        throw new IllegalStateException();\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n```\nCompliant solution\n```java\npublic static List<Integer> diffWithFirstPositive(List<Integer> list) {\n    Gatherer<Integer, AtomicInteger, Integer> gatherer = Gatherer.ofSequential(\n      () -> new AtomicInteger(-1),\n      (state, number, downstream) -> {\n        if (state.get() < 0) {\n          state.set(number);\n          return true;\n        }\n        return downstream.push(number - state.get());\n      },\n      Gatherer.defaultFinisher());\n    return list.stream().gather(gatherer).toList();\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7479": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ClassBuilder.withMethodBody\" should be preferred to \"ClassBuilder.withMethod\"\nDescription: Why is this an issue?\nThe\nClassBuilder\nAPI provides multiple ways to declare a method and its body, including\nwithMethod\nand\nwithMethodBody\n. While they can be used in very similar ways,\nwithMethodBody\nreduces boilerplate code, lowers cognitive\ncomplexity and improves maintainability.\nExceptions\nThe rule will not raise on calls where the method under construction is abstract (eg: using the flag\nClassFile.ACC_ABSTRACT\n).\nHow to fix it\nReplace the invocation of\nwithMethod\nwith\nwithMethodBody\n.\nCode examples\nNoncompliant code example\n```java\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethod(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, methodBuilder -> { // Noncompliant\n            methodBuilder.withCode(codeBuilder ->\n                codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                    .ldc(\"Hello World\")\n                    .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                    .return_()\n            );\n        });\n}\n```\nCompliant solution\n```java\nClassBuilder addMethod(ClassBuilder builder) {\n    return builder\n        .withMethodBody(\"foo\", MTD_void, ACC_PUBLIC | ACC_STATIC, codeBuilder ->\n            codeBuilder.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n                .ldc(\"Hello World\")\n                .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\", MTD_void)\n                .return_()\n        );\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7478": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"transformClass\" method should be used instead of \"build\" when transforming a class\nDescription: Why is this an issue?\nThe common pattern of taking a class-file entity, obtaining a corresponding builder, examining each element of the entity and possibly replacing it\nwith other elements can be expressed by transforms. Using the\ntransformClass\nmethod in that case instead of\nbuild\nremoves\nall that boilerplate and makes the intent clearer.\nHow to fix it\nUse the\nClassFile.transformClass\nmethod instead of\nClassFile.build\n.\nCode examples\nNoncompliant code example\n```java\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.build( // Noncompliant\n    classModel.thisClass().asSymbol(), classBuilder -> {\n        for (ClassElement classElement : classModel) {\n          if (!(classElement instanceof MethodModel methodModel &&\n              methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n\n          }\n        }\n    });\n  Files.write(path, newBytes);\n}\n```\nCompliant solution\n```java\npublic static void transformClassFile(Path path) throws IOException {\n  ClassFile classFile = ClassFile.of();\n  ClassModel classModel = classFile.parse(path);\n  byte[] newBytes = classFile.transformClass(\n    classModel, (classBuilder, classElement) -> {\n      if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n          classBuilder.with(classElement);\n        }\n      });\n  Files.write(path, newBytes);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7477": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class name should be omitted when unchanged by class transform\nDescription: Why is this an issue?\nIn the classfile API introduced by Java 24, there are several versions of the\ntransformClass\nmethods. In particular if the name of the\ntransformed class is unchanged compared to the original class, then it is recommended to use the simplest version of the method that takes only 2\narguments. This makes the code shorter, clearer, and reduces chances for mistakes.\nHow to fix it\nRemove the class name argument of the\ntransformClass\ncall.\nCode examples\nNoncompliant code example\n```java\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      classModel.thisClass().asSymbol(), // Noncompliant\n      (classBuilder, classElement) -> {\n        if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n```\nCompliant solution\n```java\npublic static void transformClassFile(Path path) throws IOException {\n    ClassFile classFile = ClassFile.of();\n    ClassModel classModel = classFile.parse(path);\n    byte[] newBytes = classFile.transformClass(classModel,\n      (classBuilder, classElement) -> {\n        if (!(classElement instanceof MethodModel methodModel &&\n            methodModel.methodName().stringValue().startsWith(\"debug\"))) {\n            classBuilder.with(classElement);\n        }\n      });\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7476": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comments should start with the appropriate number of slashes\nDescription: Why is this an issue?\nStarting in Java 23, comments beginning with three slashes\n///\nare interpreted as JavaDoc comments using Markdown syntax.\nIn Java 22 and earlier, comments starting with more than 2 slashes were treated as normal comments. Accidentally writing comments with three or\nmore slashes can lead to unintended JavaDoc being generated, when migrating to Java 23.\nWhat is the potential impact?\nComments starting with three or more slashes will increase the migration cost when upgrading to Java 23 or later. Moreover, IDE or other tools may\nhandle such comments as JavaDoc comments if they are not aware of the Java version.\nExceptions\n1. The rule does not raise issues on license headers at the start of files because they will not be considered as JavaDoc comments.\n2. The rule only raises issues in projects using Java 17 or above, because those projects will likely be migrated to Java 23 or later.\nHow to fix it\nIn versions of Java prior to 23, comments should not start with more than 2 slashes, and from Java 23 forward they should not start with more than\n3.\nCode examples\nNoncompliant code example\nThe following code will generate unintended JavaDoc comments if migrated to Java 23:\n```java\n/// Some comment for the developers\npublic abstract void foo();\n//// public void foo(String s){}\npublic void foo(){}\n```\nCompliant solution\n```java\n// Some comment for the developers\npublic abstract void foo();\n// public void foo(String s){}\npublic void foo(){}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7475": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Types of unused record components should be removed from pattern matching\nDescription: Why is this an issue?\nWhen using pattern matching on records, matching is done against the canonical constructor of the record. This implies listing all the components\nin the canonical constructor even if some are unused. To make the intent of not using the component clear, Java 22 introduced the unnamed variable\npattern\n_\n.\nBecause we can only pattern match against the canonical constructor, there is no need to disambiguate by specifying the types of its parameters.\nTherefore, the type of unused variables in pattern matching should be omitted, as it does not bring additional value.\nHow to fix it\nRemove the type of the unused component.\nCode examples\nNoncompliant code example\n```java\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, String _, String _)) { // Noncompliant\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, String _, String _) -> \"Hello \" + name + \"!\"; // Noncompliant\n        default -> \"Hello!\";\n    };\n}\n```\nCompliant solution\n```java\nrecord Guest(String name, String email, String phoneNumber) {}\n\nString greet(Object o) {\n    if (o instanceof Guest(String name, _, _)) {\n        return \"Hello \" + name + \"!\";\n    }\n    return \"Hello!\";\n}\n\nString switchToGreet(Object o) {\n    return switch (o) {\n        case Guest(String name, _, _) -> \"Hello \" + name + \"!\";\n        default -> \"Hello!\";\n    };\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7474": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Markdown, HTML and Javadoc tags should be consistent\nDescription: Why is this an issue?\nWith the introduction of Markdown support in Javadoc comments in Java 23, developers should prefer Markdown syntax over legacy HTML tags (e.g.,\n<b>\n,\n<i>\n,\n<code>\n,\n<ul>\n,\n<li>\n, etc.) and legacy Javadoc\ntags (e.g.\n{@link java.util.HashMap}\n,\n{@code Object}\n).\nMixing HTML and Markdown can lead to readability issues and inconsistencies in rendering across tools. Markdown is generally more readable, less\ncluttered and, should be preferred over HTML tags when possible.\nThis rule will raise an issue when an HTML tag or a legacy Javadoc tag inside a markdown comment could be replaced with a slimmer, and more\ncohesive, syntax.\nHow to fix it\nHere is a list of tags that should be replaced with markdown syntax:\n1. <p>should be replaced with 2 new lines\n2. <code>MyCode</code>,{@code MyCode}should be replaced with`MyCode`\n3. <i>italic text</i>,<em>should be replaced with*italic text*\n4. <b>bold text</b>,<strong>should be replaced with**bold text**\n5. <ul><li>list item</li></ul>,<ol><li>should be replaced with* list\n  item\n6. {@link some.java.Class}should be replaced with[some.java.Class]\n7. {@link #equals(Object) equals}should be replaced with[equals][#equals(Object)]\nCode examples\nNoncompliant code example\n```java\n/// This is a markdown Javadoc comment\n/// <b>ExampleClass</b> is a simple utility for <i>demonstration purposes</i>.\n/// <p>\n///     Use <code>ExampleClass.run()</code> to execute the example.\n/// </p>\n/// {@link some.java.Class} for more details\npublic class ExampleClass {\n}\n```\nCompliant solution\n```java\n/// This is a markdown Javadoc comment\n/// **ExampleClass** is a simple utility for *demonstration purposes*.\n///\n/// Use `ExampleClass.run()` to execute the example.\n/// [some.java.Class] for more details\npublic class ExampleClass {\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7467": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused exception parameter should use the unnamed variable pattern\nDescription: Why is this an issue?\nGood exception management is key to keeping a consistent application state in the face of errors and unexpected behaviors. However, in some cases,\nthe information carried by the exception is not as important as the exception bubbling up itself. In such cases, developers may want to explicitly\nindicate that they have no use for the exception parameter. Java 22 introduces the unnamed variable pattern\n_\nwhich allows developers to\nfree the catch clause from an unnecessary exception parameter name.\nHow to fix it\nReplace exception parameter name with unnamed variable pattern\n_\n.\nCode examples\nNoncompliant code example\n```java\nList<String> elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException nfe) { // Noncompliant\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException ioob) {  // Noncompliant\n  System.err.println(\"No such element\");\n}\n```\nCompliant solution\n```java\nList<String> elements = // ...\nint value = 0;\ntry {\n  var elem = elements.get(idx);\n  value = Integer.parseInt(elem);\n} catch (NumberFormatException _) {\n  System.err.println(\"Wrong number format\");\n} catch (IndexOutOfBoundsException _) {\n  System.err.println(\"No such element\");\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7466": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnamed variable declarations should use the \"var\" identifier\nDescription: Why is this an issue?\nThe syntax of some Java constructs, such as enhanced for loops, requires that you declare a variable that you may have no use for. To solve this\nissue, Java 22 introduced an unnamed variable pattern,\n_\n. This feature removes the need to name variables that are syntactically required\nbut otherwise unused. Moreover, it clearly indicates the intent not to use the variable.\nTo further minimize clutter, unnamed variables should use the\nvar\npattern rather than explicit type declarations. In addition to\nminimizing clutter, removing the type makes the code easier to maintain. Indeed, if the type was to change in future, the code would remain the\nsame.\nExceptions\nThis rule does not apply to basic\nfor\nloops and local variable declarations in a block.\nHow to fix it\nReplace the local variable type with\nvar\n.\nCode examples\nNoncompliant code example\n```java\nfor (String _ : myIterable) { // Noncompliant\n  // ...\n}\n\n\ntry (Resource _ = new Resource()) { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\nfor (var _ : myIterable) {\n  // ....\n}\n\ntry (var _ = new Resource()) {\n  // ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7190": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods annotated with \"@BeforeTransaction\" or \"@AfterTransaction\" must respect the contract\nDescription: Why is this an issue?\nIn tests configured with Spring\u2019s\n@Transactional\nannotation, methods annotated with\n@BeforeTransaction\nor\n@AfterTransaction\nmust be void and have no arguments. These methods are executed before or after a transaction, respectively. Deviating\nfrom this contract by having a non-void return type or accepting arguments will cause Spring to throw a runtime error.\nHow to fix it\nEnsure that methods annotated with\n@BeforeTransaction\nor\n@AfterTransaction\nhave a void return type and do not accept any\narguments.\nCode examples\nNoncompliant code example\n```java\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public String setupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public int cleanupTransaction(int x) { // non-compliant, method should be void and have no argument\n        // Cleanup logic\n    }\n}\n```\nCompliant solution\n```java\n@Transactional\npublic class TransactionalTest {\n\n    @BeforeTransaction\n    public void setupTransaction() {\n        // Setup logic\n    }\n\n    @AfterTransaction\n    public void cleanupTransaction() {\n        // Cleanup logic\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7186": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods returning \"Page\" or \"Slice\" must take \"Pageable\" as an input parameter\nDescription: Why is this an issue?\nSpring Data Repository supports paging for queries, allowing you to return results in small, manageable chunks rather than retrieving an entire\nlarge result set.\nThe conventional approach to paginating data in Spring is to use the\nPageable\ninterface to control pagination and to store the query\nresults into a\nPage\nor\nSlice\n. If a query declaration in a\nSpring Data Repository\nreturns a\nPage\nor\nSlice\nwithout taking a\nPageable\nas an input, it raises a runtime exception.\nThis rule raises an issue on queries in a\nRepository\nthat return a\nPage\nor\nSlice\nwithout taking a\nPageable\nas an input.\nHow to fix it\nEnsure that query methods returning a\nPage\nor\nSlice\ninclude a\nPageable\nparameter in their method\nsignature.\nCode examples\nNoncompliant code example\n```java\ninterface ItemRepository extends JpaRepository<Item, Long> {\n    Page<Item> findItems(); //non compliant, no Pageable parameter\n}\n```\nCompliant solution\n```java\ninterface ItemRepository extends JpaRepository<Item, Long> {\n    Page<Item> findItems(Pageable pageable);\n}\n```\nDocumentation\n1. Spring -JPA Query Methods\n2. Spring -Defining Query\n  Methods\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7183": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: @InitBinder methods should have void return type\nDescription: Why is this an issue?\nSpring provides the\n@InitBinder\nannotation to initialize a\nWebDataBinder\ninstance for controllers. This is useful to bind\nrequest parameters to a model object, and to plug converters and formatters into this process.\nMethods annotated with\n@InitBinder\nmust not have a return value, otherwise the controller containing them will throw an exception when\ninvoked.\nThis rule raises an issue when a method annotated with\n@InitBinder\ndoes not have a\nvoid\nreturn type\nHow to fix it\nCode examples\nNoncompliant code example\n```java\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic String initBinder(WebDataBinder binder) { // Non compliant, make the @InitBinder method return void\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n        return \"OK\";\n\t}\n\n\t// ...\n}\n```\nCompliant solution\n```java\n@Controller\npublic class MyController {\n\n\t@InitBinder\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tSimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\n\t\tdateFormat.setLenient(false);\n\t\tbinder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\n\t}\n\n\t// ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7180": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Cache*\" annotations should only be applied on concrete classes\nDescription: Why is this an issue?\nAnnotating interfaces or interface methods with\n@Cache*\nannotations is not recommended by the official Spring documentation:\n```java\nSpring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Cache* annotations, as opposed to annotating interfaces. You certainly can place an @Cache* annotation on an interface (or an interface method), but this works only if you use the proxy mode (mode=\"proxy\"). If you use the weaving-based aspect (mode=\"aspectj\"), the caching settings are not recognized on interface-level declarations by the weaving infrastructure.\n```\nAlso, when a method is annotated as cacheable inside an interface, if two different implementations of that method exist, the first one to be\ninvoked will populate the cache. Subsequent calls will always return the cached value, even if it\u2019s the other implementation being called.\nWhat is the potential impact?\n1. Confusing Code: Developers may mistakenly believe that caching is in effect, leading to confusion and incorrect assumptions\n  about application performance.\n2. Unreliable Code: Annotating interface methods as@Cacheablehides the cache name from the implementing classes,\n  making it hard to detect where a conflict of names might occur, causing unexpected results at runtime.\nThis rule raises an issue when an interface or an interface method is annotated with a\n@Cache*\nannotation.\nHow to fix it\nMove\n@Cache*\nannotation from interface or interface method to the concrete class.\nCode examples\nNoncompliant code example\n```java\npublic interface ExampleService {\n\n    @Cacheable(\"exampleCache\") // Noncompliant: interface method is annotated with @Cacheable\n    String getData(String id);\n}\n```\nIn the following example, if our application has two different rest APIs to query the most popular animal in two different zoos, the first zoo to\nbe queried will populate the cache.\nCalls to a different API to query the other zoo will produce the same cached output, invalidating our application\u2019s business logic.\n```java\npublic interface Zoo {\n    @Cacheable(\"popAnimal\") //non compliant, interface method is annotated with @Cacheable\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n```\nCompliant solution\n```java\n@Service\npublic class ExampleServiceImpl implements ExampleService {\n\n    @Cacheable(\"exampleCache\")\n    @Override\n    public String getData(String id) {\n        // Implementation here\n    }\n}\n```\nWith the following solution, we are granted that the two implementations will have separate caches.\n```java\npublic interface Zoo {\n    Animal getMostPopularAnimal();\n}\n\npublic class SanDiegoZoo implements Zoo {\n    @Override\n    @Cacheable(\"sanDiegoPopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Lion();\n    }\n}\n\npublic class RomeBioparc implements Zoo {\n    @Override\n    @Cacheable(\"romePopAnimal\")\n    public Animal getMostPopularAnimal() {\n        return new Pantegana();\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7179": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: @Cacheable and @CachePut should not be combined\nDescription: Why is this an issue?\n@Cacheable\nannotation is used to store the result of a method and avoid executing it for the same inputs.\n@CachePut\ninstead is used to force the execution of a method and store the result in the cache. Annotating a method with both will produce unreliable behavior,\nexcept for specific corner-cases when their\ncondition()\nor\nunless()\nexpressions are mutually exclusive. Hence this pattern\nis strongly discouraged and an issue will be raised on such cases.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\n@Cacheable\n@CachePut\nvoid getBook(String isbn){ // Non compliant, methods annotated with both @Cacheable and @CachePut will not behave as intended\n    ...\n}\n```\nCompliant solution\n```java\n@Cacheable\nvoid getBook(String isbn){\n    ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7178": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Injecting data into static fields is not supported by Spring\nDescription: Why is this an issue?\nSpring dependency injection framework does not support injecting data into static fields. When @Value, @Inject, or @Autowired are applied to static\nfields, they are ignored.\nWhat is the potential impact?\n1. Null Values: Uninitialized static fields annotated with @Value, @Inject, or @Autowired will not be initialized by Spring,\n  potentially causing NullPointerException at runtime.\n2. Confusing Code: The presence of injection annotations on static fields can mislead developers into believing that the fields\n  will be populated by Spring.\nThis rule raises an issue when a static field is annotated with @Value, @Inject, or @Autowired.\nHow to fix it\nEither use an instance field instead of a static field or remove the @Value, @Inject, or @Autowired annotation and initialize the field.\nCode examples\nNoncompliant code example\n```java\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private static SomeDependency dependency; // non compliant, @Value will be ignored and no value will be injected\n    // ...\n}\n```\nCompliant solution\n```java\n@Component\npublic class MyComponent {\n\n    @Value(\"${my.app.prop}\")\n    private final SomeDependency dependency;\n    // ...\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7177": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use appropriate @DirtiesContext modes\nDescription: Why is this an issue?\nIn a Spring application, the\n@DirtiesContext\nannotation marks the ApplicationContext as dirty and indicates that it should be cleared\nand recreated. This is important in tests that modify the context, such as altering the state of singleton beans or databases.\nMisconfiguring\n@DirtiesContext\nby setting the\nmethodMode\nat the class level or the\nclassMode\nat the method\nlevel will make the annotation have no effect.\nThis rule will raise an issue when the incorrect mode is configured on a @DirtiesContext annotation targeting a different scope.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\n@ContextConfiguration\n@DirtiesContext(methodMode = MethodMode.AFTER_METHOD) // Noncompliant, for class-level control, use classMode instead.\npublic class TestClass {\n  @DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS) // Non compliant, for method-level control use methodMode instead\n  public void test() {...}\n}\n```\nCompliant solution\n```java\n@ContextConfiguration\n@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)\npublic class TestClass {\n  @DirtiesContext(methodMode = MethodMode.AFTER_METHOD)\n  public void test() {...}\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7158": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"String.isEmpty()\" should be used to test for emptiness\nDescription: Why is this an issue?\nCalling\nString.isEmpty()\nclearly communicates the code\u2019s intention, which is to test if the string is empty. Using\nString.length() == 0\nis less direct and makes the code less readable. This preference for\nisEmpty()\nextends to all\nCharSequence\nobjects, including\nStringBuilder\nand\nStringBuffer\n.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\nif (\"string\".length() == 0) { /* \u2026 */ } // Noncompliant\n\nif (\"string\".length() > 0) { /* \u2026 */ } // Noncompliant\n```\n```java\nStringBuilder sb = new StringBuilder();\n...\nif (sb.length() == 0) { /* \u2026 */ } // Noncompliant\n```\nCompliant solution\n```java\nif (\"string\".isEmpty()){ /* \u2026 */ }\n\nif (!\"string\".isEmpty()){ /* \u2026 */ }\n```\n```java\nStringBuilder sb = new StringBuilder();\n...\nif (sb.isEmpty()) { /* \u2026 */ }\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7091": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Circular dependencies between classes across packages should be resolved\nDescription: This rule reports circular dependencies between classes across different packages.\nWhy is this an issue?\nCircular dependencies occur when two classes reference each other, either directly or indirectly. This means that the classes' dependency structure\ndoes not represent an intuitive hierarchy, which makes it harder to understand and maintain.\nCompared to {rule:java:S7027}, this issue is even more significant when a cycle crosses package boundaries because:\nIt disrupts the dependency hierarchy or layer structure even between packages.\nIt spreads the problem across more distant locations in the source code.\nWhat is the potential impact?\nCircular dependencies increase the architectural complexity of the code, reducing its readability, extensibility, and maintainability. As the\nproject grows, circular dependencies often lead to more circular dependencies, further complication of the architecture and increasing technical debt.\nOver time, untangling these dependencies becomes increasingly difficult.\nHow to fix it\nExtract an interface\n: If two classes share similar functionality, move that functionality to an interface that both can\n  implement. This allows each class to depend on the interface rather than on each other.\nUse dependency injection\n: Replace direct references between classes with dependency injection. By passing necessary objects as\n  parameters through constructors or setters, you break the circular reference, making your code more flexible and easier to test.\nSplit responsibilities\n: Evaluate whether each class is handling too many responsibilities. If so, break them down into\n  smaller, more focused classes. This eliminates circular dependencies and makes sure your code has fewer reasons to change, making it easier to\n  manage and extend.\nRethink the package structure\nCode examples\nNoncompliant code example\nThe following code contains two cycles: Order \u2192 Customer \u2192 Order, and Order \u2192 Product \u2192 Order. Furthermore, both cycles are connected to each other\nvia class Order. This is called\na tangle consisting of two cycles\n.\n```java\nclass Order {\n    public Customer customer;\n    public List<Product> products;\n}\nclass Customer {\n    public List<Order> orders;\n}\nclass Product {\n    public List<Order> orders;\n}\n```\nCompliant solution\nThe issue can be resolved by changing the structure. Two service functions can replace the dependencies Customer \u2192 Order and Product \u2192 Order.\n```java\nclass Order {\n    public Customer customer;\n    public List<Product> products;\n}\nclass Customer { }\nclass Product { }\ninterface OrderService {\n  List<Order> getOrdersByCustomer(Customer customer);\n  List<Order> getOrdersByProduct(Product product);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-7027": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Circular dependencies between classes in the same package should be resolved\nDescription: This rule reports circular dependencies between classes within the same package.\nWhy is this an issue?\nCircular dependencies occur when two classes reference each other, either directly or indirectly. This means that the classes' dependency structure\ndoes not represent an intuitive hierarchy, which makes it harder to understand and maintain.\nWhat is the potential impact?\nCircular dependencies increase the architectural complexity of the code, reducing its readability, extensibility, and maintainability. As the\nproject grows, circular dependencies often lead to more circular dependencies, further complication of the architecture and increasing technical debt.\nOver time, untangling these dependencies becomes increasingly difficult.\nExceptions\nCircular dependencies between an inner class and its outer class, or between inner classes within the same enclosing class, are not flagged as\nissues.\nHow to fix it\nExtract an interface\n: If two classes share similar functionality, move that functionality to an interface that both can\n  implement. This allows each class to depend on the interface rather than on each other.\nUse dependency injection\n: Replace direct references between classes with dependency injection. By passing necessary objects as\n  parameters through constructors or setters, you break the circular reference, making your code more flexible and easier to test.\nSplit responsibilities\n: Evaluate whether each class is handling too many responsibilities. If so, break them down into\n  smaller, more focused classes. This eliminates circular dependencies and makes sure your code has fewer reasons to change, making it easier to\n  manage and extend.\nCode examples\nNoncompliant code example\nThe following code contains two cycles: Order \u2192 Customer \u2192 Order, and Order \u2192 Product \u2192 Order. Furthermore, both cycles are connected to each other\nvia class Order. This is called\na tangle consisting of two cycles\n.\n```java\nclass Order {\n    public Customer customer;\n    public List<Product> products;\n}\nclass Customer {\n    public List<Order> orders;\n}\nclass Product {\n    public List<Order> orders;\n}\n```\nCompliant solution\nThe issue can be resolved by changing the structure. Two service functions can replace the dependencies Customer \u2192 Order and Product \u2192 Order.\n```java\nclass Order {\n    public Customer customer;\n    public List<Product> products;\n}\nclass Customer { }\nclass Product { }\ninterface OrderService {\n  List<Order> getOrdersByCustomer(Customer customer);\n  List<Order> getOrdersByProduct(Product product);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6926": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Bluetooth should be configured to use low power\nDescription: BluetoothGATT\nis a class to provide a functionality to enable communication with Bluetooth Smart or Smart Ready devices.\nTo connect to a remote peripheral device, a\nBluetoothGattCallback\nis used and a method\nBluetoothDevice#connectGatt\nis\nused to get an instance of this class. GATT-capable devices can be discovered using the Bluetooth device discovery or BLE scan process.\nWhy is this an issue?\nUsing high power consumption modes for Bluetooth operations can drain the device battery faster and may not be suitable for scenarios where power\nefficiency is crucial.\nThis rule identifies instances where high power consumption Bluetooth operations are used, specifically when\nrequestConnectionPriority\nor\nsetAdvertiseMode\nmethods are invoked with arguments other than those promoting low power consumption.\nHow to fix it\n1. UseCONNECTION_PRIORITY_LOW_POWERforrequestConnectionPrioritymethod.\n2. UseADVERTISE_MODE_LOW_POWERforsetAdvertiseModemethod to promote low power consumption.\nCode examples\nNoncompliant code example\n```java\npublic class BluetoothExample {\n    private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH); // Noncompliant\n            }\n        }\n    };\n}\n```\nCompliant solution\n```java\npublic class BluetoothExample {\n   private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() {\n        @Override\n        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {\n          // ...\n        }\n\n        @Override\n        public void onServicesDiscovered(BluetoothGatt gatt, int status) {\n            if (status == BluetoothGatt.GATT_SUCCESS) {\n                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_LOW_POWER); // Compliant\n            }\n        }\n    };\n}\n```\nNoncompliant code example\n```java\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_LATENCY); // Noncompliant\n        // Other settings configuration...\n    }\n}\n```\nCompliant solution\n```java\npublic class BluetoothExample {\n    private void startAdvertising() {\n        AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder();\n        settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER); // Compliant\n        // Other settings configuration...\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6923": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Motion Sensor should not use gyroscope\nDescription: The\nandroid.hardware.SensorManager#getDefaultSensor\noffers two types of Motion Sensors:\n1. TYPE_ROTATION_VECTOR:a combination of the gyroscope, accelerometer, and magnetometer.\n2. TYPE_GEOMAGNETIC_ROTATION_VECTOR:a combination of the accelerometer and magnetometer.\nWhy is this an issue?\nThe battery life is a major concern for mobile devices and choosing the right Sensor is very important to reduce the power usage and extend the\nbattery life.\nIt is recommended, for reducing the power usage, to use\nTYPE_GEOMAGNETIC_ROTATION_VECTOR\nfor\nbackground tasks\n,\nlong-running tasks\nand other tasks not requiring accurate motion detection.\nThe rule reports an issue when\nandroid.hardware.SensorManager#getDefaultSensor\nuses\nTYPE_ROTATION_VECTOR\ninstead of\nTYPE_GEOMAGNETIC_ROTATION_VECTOR\n.\nHow to fix it\nReplace\nTYPE_ROTATION_VECTOR\nwith\nTYPE_GEOMAGNETIC_ROTATION_VECTOR\nwhen retrieving the Motion Sensor.\nCode examples\nNoncompliant code example\n```java\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR); // Noncompliant\n        // ..\n    }\n    //..\n}\n```\nCompliant solution\n```java\npublic class BackGroundActivity extends Activity {\n\n    private Sensor motionSensor;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        SensorManager sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);\n        motionSensor = sensorManager.getDefaultSensor(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR); // Compliant\n        // ..\n    }\n    //..\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6916": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use when instead of a single if inside a pattern match body\nDescription: Why is this an issue?\nJava 21 has introduced enhancements to switch statements and expressions, allowing them to operate on any type, not just specific ones, as in\nprevious versions. Furthermore, case labels have been upgraded to support patterns, providing an alternative to the previous restriction of only\naccepting constants.\n```java\n// As of Java 21\nString patternMatchSwitch(Object obj) {\n    return switch (obj) {\n        case String s  -> String.format(\"String %s\", s);\n        case Integer i -> String.format(\"int %d\", i);\n        default        -> obj.toString();\n    };\n}\n```\nThis allows to use the\nwhen\nkeyword to specify a condition for a case label, also called a guarded case label.\n```java\nString guardedCaseSwitch(Object obj) {\n    return switch (obj) {\n        case String s when s.length() > 0 -> String.format(\"String %s\", s);\n        case Integer i when i > 0 -> String.format(\"int %d\", i);\n        default        -> obj.toString();\n    };\n}\n```\nThis syntax is more readable and less error-prone than using an if statement inside the case block and should be preferred.\nThis rule reports an issue when a single\nif\nstatement is used inside a case block.\nHow to fix it\nReplace the\nif\nstatement with a guarded case label.\nCode examples\nNoncompliant code example\n```java\nvoid testObject(Object response) {\n    switch (response) {\n        case String s -> {\n            if(s.length() > 80) { // Noncompliant; use the \"when\" keyword\n                System.out.println(\"This string is too long\");\n            }\n        }\n        case Integer i -> {\n            if(i > 80) { // Noncompliant; use the \"when\" keyword\n                System.out.println(\"This integer is too big\");\n            }\n        }\n        default -> System.out.println(\"Unknown type\");\n    }\n}\n```\nCompliant solution\n```java\nvoid testObject(Object response) {\n    switch (response) {\n        case String s when s.length() > 80 -> {\n            System.out.println(\"This string is too long\");\n        }\n        case Integer i when i > 80 -> {\n            System.out.println(\"This integer is too big\");\n        }\n        default -> System.out.println(\"Unknown type\");\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6914": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use Fused Location to optimize battery power\nDescription: Location awareness is a common feature for mobile application that enhance the user experience by providing context-specific services.\nWhy is this an issue?\nThe location awareness feature can significantly drain the device\u2019s battery.\nThe recommended way to maximize the battery life is to use the\nfused location provider\nwhich combines signals from GPS, Wi-Fi, and cell\nnetworks, as well as accelerometer, gyroscope, magnetometer and other sensors. The\nFusedLocationProviderClient\nautomatically chooses the\nbest method to retrieve a device\u2019s location based on the device\u2019s context.\nThe rule flags an issue when\nandroid.location.LocationManager\nor\ncom.google.android.gms.location.LocationClient\nis used\ninstead of\ncom.google.android.gms.location.FusedLocationProviderClient\n.\nWhat is the potential impact?\n1. Usability: the non-optimized location API consumer more battery.\n2. Sustainability: the extra energy required has a negative impact on the environment.\nHow to fix it\nReplace the usages of\nandroid.location.LocationManager\nor\ncom.google.android.gms.location.LocationClient\nwith\ncom.google.android.gms.location.FusedLocationProviderClient\n.\nCode examples\nNoncompliant code example\n```java\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        LocationManager locationManager = (LocationManager) this.getSystemService(Context.LOCATION_SERVICE); // Noncompliant\n\n        LocationListener locationListener = new LocationListener() {\n            public void onLocationChanged(Location location) {\n                // Use the location object as needed\n            }\n        };\n\n        locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, locationListener);\n    }\n}\n```\nCompliant solution\n```java\npublic class LocationsActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        // ...\n\n        FusedLocationProviderClient fusedLocationClient = LocationServices.getFusedLocationProviderClient(this); // Compliant\n\n        fusedLocationClient.getLastLocation()\n            .addOnSuccessListener(this, location -> {\n                // Use the location object as needed\n            });\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6912": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use batch Processing in JDBC\nDescription: Why is this an issue?\nExecuting a batch of SQL queries instead of individual queries improves performance by reducing communication overhead with the database.\nBatching SQL statements is beneficial in common situations where a SQL statement is executed within a loop. In such cases, adding the statement to\na batch and subsequently executing it reduces the number of interactions with the database. This results in improved efficiency and faster execution\ntimes.\nThe rule raises an issue when it detects a\njava.sql.Statement\nbeing executed within a loop instruction, such as\nfor\n,\nwhile\nor the\nforEach\nmethod of\njava.lang.Iterable\n,\njava.util.Map\nand\njava.util.stream.Stream\n.\nHow to fix it\nGroup SQL statements by using the method\naddBatch\nto add them to a batch and then execute them using\nexecuteBatch\nto send\nthem to the database in a single call.\nCode examples\nNoncompliant code example\n```java\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i < 10; i++) {\n      statement.execute(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // Noncompliant\n    }\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n```\nCompliant solution\n```java\npublic void execute(Connection connection) {\n  try {\n    Statement statement = connection.createStatement();\n\n    for (int i = 0; i < 10; i++) {\n      statement.addBatch(\"INSERT INTO myTable (column1, column2) VALUES (\" + i + \", 'value\" + i + \"')\"); // Compliant\n    }\n    statement.executeBatch();\n\n    statement.close();\n    connection.close();\n  } catch (SQLException e) {\n    e.printStackTrace();\n  }\n}\n```\nDocumentation\n1. Oracle Java SE 21 API - java.sql.Statement\n2. Oracle Java SE 21 API -\n  java.sql.PreparedStatement\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6909": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Constant parameters in a \"PreparedStatement\" should not be set more than once\nDescription: The\njava.sql.PreparedStatement\nrepresents a precompiled SQL statement that can be efficiently executed multiple times.\nWhy is this an issue?\nThe\nPreparedStatement\nis frequently used in loops because it allows to conveniently set parameters. A small optimization is possible\nby setting constant parameters outside the loop or hard-coding them in the query whenever possible.\nWhat is the potential impact?\n1. Performance: the unnecessary calls to the setter methods bring overhead.\n2. Sustainability: the extra overhead has a negative impact on the environment.\nHow to fix it\nPlace calls to setter methods that take a constant argument outside the loop.\nCode examples\nNoncompliant code example\n```java\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List<Order> orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.setDate(3, today); // Noncompliant\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n```\nCompliant solution\n```java\npublic class DatabaseExample {\n\n    public record Order(String id, BigDecimal price) {}\n\n    public void updateTodayOrders(Connection connection, List<Order> orders) {\n            Date today = java.sql.Date.valueOf(LocalDate.now());\n            String insertQuery = \"INSERT INTO Order (id, price, executionDate) VALUES (?, ?, ?)\";\n            PreparedStatement preparedStatement = connection.prepareStatement(insertQuery);\n\n            preparedStatement.setDate(3, today); // Compliant\n            for(Order order: orders) {\n                preparedStatement.setString(1, order.id());\n                preparedStatement.setString(2, order.price());\n                preparedStatement.executeUpdate();\n            }\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6905": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: SQL queries should retrieve only necessary fields\nDescription: The\nJava Database Connectivity (JDBC) API\nprovides the\njava.sql.Statement\ninterface that allows to represent an SQL statement\nand to execute queries with the database.\nWhy is this an issue?\nA common reason for a poorly performant query is because it\u2019s processing more data than required.\nQuerying unnecessary data demands extra work on the server, adds network overhead, and consumes memory and CPU resources on the application server.\nThe effect is amplified when the query includes multiple\njoins\n.\nThe rule flags an issue when a\nSELECT *\nquery is provided as an argument to methods in\njava.sql.Connection\nand\njava.sql.Statement\n.\nWhat is the potential impact?\n1. Performance: the unnecessary extra data being processed brings overhead.\n2. Sustainability: the extra resources used have a negative impact on the environment.\nHow to fix it\nMake the\nSELECT *\nan explicit selection of the required fields.\nCode examples\nNoncompliant code example\n```java\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List<OrderSummary> queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT * \" +                                                         // Noncompliant\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n```\nCompliant solution\n```java\npublic class OrderRepository {\n\n    public record OrderSummary(String name, String orderId, BigDecimal price) { }\n\n    public List<OrderSummary> queryOrderSummaries(Connection conn) {\n            String sql = \"SELECT Customers.name, Orders.id, Orders.price \" +                   // Compliant\n                          \"FROM Orders JOIN Customers ON Orders.customerId = Customers.id \";\n\n            Statement stmt = conn.createStatement();\n            ResultSet rs = stmt.executeQuery(sql);\n\n            return convertResultToOrderSummaryList(rs);\n    }\n}\n```\nDocumentation\n1. Oracle SDK - Statement\n2. O\u2019Reilly - High Performance MySQL - Query\n  Performance Optimization\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6904": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Avoid using \"FetchType.EAGER\"\nDescription: FetchType\nis an enumeration in the Java Persistence API (JPA) that is used to define the fetching strategy for associations\n(relationships) between entities in a relational database.\nThere are two main values for FetchType:\n1. FetchType.EAGER: the association is loaded immediately when the owning entity is loaded.\n2. FetchType.LAZY: the association is not loaded unless it is explicitly accessed.\nThis rule raises an issue when the\nfetch\nargument is explicitly set to\nFetchType.EAGER\n.\nWhy is this an issue?\nUsing\nFetchType.EAGER\ncan lead to inefficient data loading and potential performance issues. Eager Loading initializes associated data\non the spot, potentially fetching more data than needed.\nHow to fix it\nRemove or replace\nFetchType.EAGER\nwith\nFetchType.LAZY\nin JPA annotations.\nCode examples\nNoncompliant code example\n```java\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.EAGER) // Noncompliant\nprivate List<ChildEntity> children;\n\n@OneToMany(mappedBy = \"child\", fetch = FetchType.EAGER) // Noncompliant\nprivate List<ParentEntity> parents;\n```\nCompliant solution\n```java\n@OneToMany(mappedBy = \"parent\", fetch = FetchType.LAZY) // Compliant\nprivate List<ChildEntity> children;\n\n@OneToMany(mappedBy = \"child\") // Compliant\nprivate List<ParentEntity> parents;\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6898": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: High frame rates should not be used\nDescription: The\nFrame Rate API\nallows applications to communicate their desired frame rate to the\nAndroid platform\nto enhance the user\nexperience. The API is useful since many devices now offer varying refresh rates like 60Hz, 90Hz, or 120Hz.\nWhy is this an issue?\nStandard applications don\u2019t require a display refresh rate above 60Hz, hence it is advisable to avoid higher frequencies to avoid unnecessary\nenergy consumption.\nThe rule flags an issue when\nsetFrameRate()\nis invoked with a frameRate higher than 60Hz for\nandroid.view.Surface\nand\nandroid.view.SurfaceControl.Transaction\n.\nIt\u2019s important to note that the scheduler considers several factors when determining the display refresh rate. Therefore, using\nsetFrameRate()\ndoesn\u2019t guarantee your app will achieve the requested frame rate.\nWhat is the potential impact?\n1. Usability: the device may run out of battery faster than expected.\n2. Sustainability: the extra battery usage has a negative impact on the environment.\nHow to fix it\nUse a frame rate of maximum 60Hz, unless you have a strong reason to used higher rates. Valid exceptions are\ngaming apps\n, especially those\nwith fast-paced action or high-quality graphics, or\nAR/VR apps\n.\nCode examples\nNoncompliant code example\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(90.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // Noncompliant\n    }\n}\n```\nCompliant solution\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        SurfaceView surfaceView = findViewById(R.id.my_surface_view);\n        Surface surface = surfaceView.getHolder().getSurface();\n\n        surface.setFrameRate(60.0f, Surface.FRAME_RATE_COMPATIBILITY_FIXED_SOURCE); // Compliant\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6891": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exact alarms should not be abused\nDescription: The\nAlarmManager\nclass provides access to the system alarm services. It allows you to schedule your application to run at some point\nin the future, even when it\u2019s not active.\nFrom API 19 onwards, the alarm delivery is inexact in order to save battery life. The Android OS now batches together alarms from all apps that\noccur at reasonably similar times so the system wakes the device once instead of several times to handle each alarm.\nIt is possible to use exact alarms with\nsetExact\n,\nsetExactAndAllowWhileIdle\n,\nsetWindow\nand\nsetAlarmClock\n. Exact alarms should be used only when strict delivery guarantees are required, for example for an alarm clock application\nor for calendar notifications.\nThe rule raises an issue when an exact alarm is set, or when a window is set to less than 10 minutes.\nWhy is this an issue?\nThe use of exact alarms triggers the device to wake up at precise times that can lead several wake-ups in a short period of time. The wake-up\nmechanism is a significant battery drain because it requires powering up the main processor and pulling it out of a low-power state.\nIt\u2019s highly recommended to create an inexact alarm whenever possible.\nIt is also recommended for normal timing operations, such as ticks and timeouts, using the\nHandler\n, and for long-running operations,\nsuch as network downloads, using\nWorkManager\nor\nJobScheduler\n.\nWhat is the potential impact?\n1. Usability: the device may run out of battery faster than expected.\n2. Sustainability: the extra battery usage has a negative impact on the environment.\nHow to fix it\nReplace occurrences of\nsetExact\nwith\nset\nand\nsetExactAndAllowWhileIdle\nwith\nsetAndAllowWhileIdle\n, and avoid to use\nsetWindow\nwith a window less than 10 minutes.\nAlternatively, consider using\nHandler\n,\nWorkManager\nor\nJobScheduler\ninstead of\nAlarmManager\nwhen\npossible, depending on your use case.\nCode examples\nNoncompliant code example\n```java\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Noncompliant, avoid using exact alarms unless necessary\n        alarmManager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Noncompliant, avoid using exact alarms unless necessary\n\n        long windowLengthMillis = 5 * 60 * 1000; // 5 minutes in milliseconds\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // Noncompliant, don't use windows below 10 minutes\n    }\n}\n```\nCompliant solution\n```java\npublic class AlarmScheduler {\n    private Context context;\n\n    public AlarmScheduler(Context context) {\n        this.context = context;\n    }\n\n    public void scheduleAlarm(long triggerTime) {\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        Intent intent = new Intent(context, AlarmReceiver.class);\n        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n\n        alarmManager.set(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent); // Compliant\n        alarmManager.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, triggerTime, pendingIntent);  // Compliant\n\n        long windowLengthMillis = 10 * 60 * 1000; // 10 minutes in milliseconds\n        alarmManager.setWindow(AlarmManager.RTC_WAKEUP, triggerTime, windowLengthMillis, pendingIntent); // Compliant\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6889": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Proper Sensor Resource Management\nDescription: Why is this an issue?\nOptimizing resource usage and preventing unnecessary battery drain are critical considerations in Android development. Failing to release sensor\nresources when they are no longer needed can lead to prolonged device activity, negatively impacting battery life. Common Android sensors, such as\ncameras, GPS, and microphones, provide a method to release resources after they are not in use anymore.\nThis rule identifies situations where a sensor is not released after being utilized, helping developers maintain efficient and battery-friendly\napplications.\n1. Missing call torelease()method:android.os.PowerManager.WakeLockandroid.net.wifi.WifiManager$MulticastLockandroid.hardware.Cameraandroid.media.MediaPlayerandroid.media.MediaRecorderandroid.media.SoundPoolandroid.media.audiofx.Visualizerandroid.hardware.display.VirtualDisplay\n2. android.os.PowerManager.WakeLock\n3. android.net.wifi.WifiManager$MulticastLock\n4. android.hardware.Camera\n5. android.media.MediaPlayer\n6. android.media.MediaRecorder\n7. android.media.SoundPool\n8. android.media.audiofx.Visualizer\n9. android.hardware.display.VirtualDisplay\n10. Missing call toclose()methodandroid.hardware.camera2.CameraDevice\n11. android.hardware.camera2.CameraDevice\n12. Missing call toremoveUpdates()method:android.location.LocationManager\n13. android.location.LocationManager\n14. Missing call tounregisterListener()method:android.hardware.SensorManager\n15. android.hardware.SensorManager\nHow to fix it\nEnsure that resources are released when they are no longer needed. This can be done by calling the appropriate release method, such as\nrelease()\n,\nremoveUpdates()\n,\nunregisterListener()\n, or\nstop()\n.\nCode examples\n1. android.os.PowerManager.WakeLock\nNoncompliant code example\n```java\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // Noncompliant\n  // do some work...\n}\n```\nCompliant solution\n```java\npublic void method() {\n  PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n  PowerManager.WakeLock wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, \"My Wake Lock\");\n  wakeLock.acquire(); // Compliant\n  // do some work...\n  wakeLock.release();\n}\n```\n1. android.media.MediaPlayer\nNoncompliant code example\n```java\npublic void method() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // Noncompliant\n  // do some work...\n}\n```\nCompliant solution\n```java\npublic void onCreate() {\n  MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);\n  mediaPlayer.start(); // Compliant\n  // do some work...\n  wakeLock.release();\n}\n```\n1. android.hardware.SensorManager\nNoncompliant code example\n```java\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // Noncompliant\n  // do some work...\n}\n```\nCompliant solution\n```java\npublic void method() {\n  SensorManager sensorManager = getSystemService(SENSOR_SERVICE);\n  Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);\n  sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL); // Compliant\n  // do some work...\n  sensorManager.unregisterListener(this);\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6885": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use built-in \"Math.clamp\" methods\nDescription: Why is this an issue?\nIn Java 21 the\njava.lang.Math\nclass was updated with the static method\nMath.clamp\n, to clamp a numerical value between a\nmin and a max value.\nUsing this built-in method is now the preferred way to restrict to a given interval, as it is more readable and less error-prone.\nHow to fix it\nReplace your clamp method implementation with the\nMath.clamp\nmethod.\nCode examples\nNoncompliant code example\n```java\nint clampedValue = value > max ? max : value < min ? min : value; // Noncompliant; Replace with \"Math.clamp\"\n```\n```java\nint clampedValue = Math.max(min, Math.min(max, value)); // Noncompliant; Replace with \"Math.clamp\"\n```\nCompliant solution\n```java\nint clampedValue = Math.clamp(value, min, max);\n```\n```java\nint clampedValue = Math.clamp(value, min, max);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6880": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use switch instead of if-else chain to compare a variable against multiple cases\nDescription: Why is this an issue?\nComparing a variable to multiple cases is a frequent operation. This can be done using a sequence of if-else statements. However, for many cases\nlike enums or simple value comparisons, a\nswitch\nstatement is the better alternative. With Java 21, the\nswitch\nstatement has\nbeen significantly improved to support pattern matching and record pattern.\nUsing a\nswitch\nstatement instead of an if-else chain provides benefits like clearer code, certainty of covering all cases, and may\neven improve performance.\nThis rule raises an issue when an if-else chain should be replaced by a\nswitch\nstatement.\nHow to fix it\nReplace the chain of if-else with a switch expression.\nCode examples\nNoncompliant code example\n```java\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  if(expr instanceof Plus plus){ // Noncompliant; should be replaced by a switch expression\n    return eval(plus.left) + eval(plus.right);\n  }else if(expr instanceof Div div){\n    return eval(div.left) / eval(div.right);\n  }else if(expr instanceof Minus minus){\n    return eval(minus.left) - eval(minus.right);\n  } else {\n    throw new IllegalArgumentException(\"Unknown expression\");\n  }\n}\n```\n```java\nenum Color{RED,GREEN,YELLOW}\n\nString name(Color c){\n  if(c == Color.RED){ // Noncompliant; should be replaced by a switch expression\n    return \"red\";\n  }else if(c == Color.GREEN){\n    return \"green\";\n  }else if(c == Color.YELLOW){\n    return \"yellow\";\n  }else{\n    throw new IllegalArgumentException(\"Unknown color\");\n  }\n}\n```\n```java\nint points(int result){\n  if(result == 2){ // Noncompliant; should be replaced by a switch expression\n    return 10;\n  } else if(result == 3 || result==4 ){\n    return 20;\n  } else if (result == 5) {\n    return 50;\n  }else{\n    return 0;\n  }\n}\n```\n```java\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  if (shape instanceof Circle) { // Noncompliant; should be replaced by a switch expression\n    return \"circle\";\n  } else if (shape instanceof Rectangle) {\n     return \"rectangle\";\n  } else if (shape instanceof Square) {\n    return \"square\";\n  } else {\n    throw new IllegalArgumentException();\n  }\n}\n```\nCompliant solution\n```java\nsealed interface Expression {}\nrecord Plus(Expression left, Expression right) implements Expression {}\nrecord Minus(Expression left, Expression right) implements Expression {}\nrecord Div(Expression left, Expression right) implements Expression {}\n\nint eval(Expression expr){\n  return switch(expr){\n    case Div(var left, var right) -> eval(left) / eval(right);\n    case Plus(var left, var right) -> eval(left) + eval(right);\n    case Minus(var left, var right) -> eval(left) - eval(right);\n  };\n}\n```\n```java\nenum Color{RED,GREEN,YELLOW}\nString name(Color c){\n  return switch(c){\n    case RED -> \"red\";\n    case GREEN -> \"green\";\n    case YELLOW -> \"yellow\";\n  };\n}\n```\n```java\nint points(int result){\n  return switch(result){\n    case 2 -> 10;\n    case 3,4 -> 20;\n    case 5 -> 50;\n    default -> 0;\n  };\n}\n```\n```java\nclass Circle{}\nclass Rectangle{}\nclass Square{}\n\nString name(Object shape){\n  return switch(shape){\n    case Circle c -> \"circle\";\n    case Rectangle r -> \"rectangle\";\n    case Square s -> \"square\";\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6878": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use record pattern instead of explicit field access\nDescription: Why is this an issue?\nJava 21 enhances Pattern Matching, introduced in Java 16, with a\nrecord pattern\nthat decomposes records into local variables. This form\nshould be used when all fields of a record are accessed within a block for improved readability. Nested record patterns are also allowed and should be\nused when a record field is another record, and all its fields are accessed.\nExceptions\nThis rule does not apply when not all record fields are accessed. This prevents the creation of unused local variables in the decomposed record\nstructure.\nHow to fix it\nReplace the instance check or simple pattern matching with a record pattern.\nCode examples\nNoncompliant code example\nThis example uses pattern matching but not a record pattern, even though all fields of the record are accessed in the block.\n```java\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // Noncompliant, because all three fields x, y, z are accessed\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n```\nCompliant solution\nThe compliant example uses a record pattern to decompose the record structure.\n```java\nrecord Point(Float x, Float y, Float z) {}\n\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant\n        System.out.println(x + y + z);\n    }\n}\n```\nNoncompliant code example\nThis example does not use pattern matching or a record pattern. Rule\n{rule:java:S6201} - Pattern matching or \"instanceOf\" operator should be\nused\nwould report first. When fixed using simple pattern matching instead of a record pattern, this rule ({rule:java:S6878}) will report.\n```java\nvoid print(Object obj) {\n    if (obj instanceof Point) { // Noncompliant\n        Point p = (Point) obj;\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y + p.z);\n    }\n}\n```\nCompliant solution\nThe solution compliant with both rules, {rule:java:S6201} and {rule:java:S6878}, uses pattern matching and decomposes the record structure using a\nrecord pattern.\n```java\nvoid print(Object obj) {\n    if (obj instanceof Point(Float x, Float y, Float z)) { // Compliant\n        System.out.println(x + y + z);\n    }\n}\n```\nNoncompliant code example\nThis example is noncompliant because a nested record pattern could have been used.\n```java\nrecord Plane(Point normal, Float d) {}\n\nvoid print(Object obj) {\n    // Noncompliant, because all field of \"normal\" are accessed\n    if (obj instanceof Plane(Point normal, Float d)) {\n        System.out.println(normal.x + normal.y + normal.z);\n        System.out.println(d);\n    }\n}\n```\nCompliant solution\nThis is the same example using a nested record pattern.\n```java\nvoid print(Object obj) {\n    if (obj instanceof Plane(Point(Float x, Float y, Float z), Float d)) { // Compliant\n        System.out.println(x + y + z);\n        System.out.println(d);\n    }\n}\n```\nCompliant solution\nThis example uses\nvar\ninstead of replicating the field types in the record pattern, which is less verbose and keeps the code more\nreadable, especially in the case of longer type names. Also, it uses variable names that do not match the original field names. The reason for this\ncan be to avoid name collisions with fields or other local variables.\n```java\nvoid print(Object obj) {\n    if (obj instanceof Point(var px, var py, var pz)) { // Compliant\n        System.out.println(px + py + pz);\n    }\n}\n```\nCompliant solution\nThis example is compliant without using a record pattern, as it does not access all fields.\n```java\nvoid print(Object obj) {\n    if (obj instanceof Point p) { // Compliant, because z is never accessed\n        Float x = p.x;\n        Float y = p.y();\n        System.out.println(x + y);\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6877": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Reverse view should be used instead of reverse copy in read-only cases\nDescription: Why is this an issue?\nJava 21 introduces the new Sequenced Collections API, which applies to all collections with a defined sequence on their elements, such as\nLinkedList\n,\nTreeSet\n, and others (see\nJEP 431\n). For projects using Java 21 and\nonwards, use this API instead of workaround implementations that were necessary before Java 21. One of the features of the new Sequenced Collections\nAPI is\nSequencedCollection.reversed()\nwhich returns a lightweight view of the original collection, in the reverse order.\nThis rule reports when reverse view would have been sufficient instead of a reverse copy of a sequenced collection created using a list constructor\nplus a\nCollections.reverse(collection);\ncall.\nIf feasible, a view should be preferred over a copy because a view is a lightweight iterator without modification of the list itself.\nHow to fix it\nRemove\nCollections.reverse(list);\nand replace\nlist\nwith\nlist.reversed()\nafter.\nCode examples\nNoncompliant code example\n```java\nvoid foo() {\n  var list = new ArrayList<String>();\n  list.add(\"A\");\n  list.add(\"B\");\n  Collections.reverse(list); // Noncompliant\n  for (var e : list) {\n    // ...\n  }\n}\n```\nCompliant solution\n```java\nvoid foo() {\n  var list = new ArrayList<String>();\n  list.add(\"A\");\n  list.add(\"B\");\n  for (var e : list.reversed()) {  // Compliant\n    // ...\n  }\n}\n```\nNoncompliant code example\n```java\nvoid foo(List<String> list) {\n  var copy = new ArrayList<String>(list);\n  Collections.reverse(copy); // Noncompliant\n  for (var e : copy) {\n    // ...\n  }\n}\n```\nCompliant solution\n```java\nvoid foo(List<String> list) {\n  for (var e : list.reversed()) {  // Compliant\n    // ...\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6876": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Reverse iteration should utilize reversed view\nDescription: Why is this an issue?\nJava 21 introduces the new Sequenced Collections API, which is applicable to all collections with a defined sequence on their elements, such as\nLinkedList\n,\nTreeSet\n, and others (see\nJEP 431\n). For projects using Java 21 and\nonwards, this API should be utilized instead of workaround implementations that were necessary before Java 21.\nThis rule reports when a collection is iterated in reverse through explicit implementation or workarounds, instead of using the reversed view of\nthe collection.\nHow to fix it\nReplace the reported statement with a forward-iteration over the reversed view of the collection.\nCode examples\nNoncompliant code example\n```java\nvoid printLastToFirst(List<String> list) {\n  for (var it = list.listIterator(list.size()); it.hasPrevious();) {\n    var element = it.previous();\n    System.out.println(element);\n  }\n}\n```\nCompliant solution\n```java\nvoid printLastToFirst(List<String> list) {\n  for (var element: list.reversed()) {\n    System.out.println(element);\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6837": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Superfluous \"@ResponseBody\" annotations should be removed\nDescription: Why is this an issue?\nThe Spring framework\u2019s\n@RestController\nannotation is equivalent to using the\n@Controller\nand\n@ResponseBody\nannotations together. As such, it is redundant to add a\n@ResponseBody\nannotation when the class is already annotated with\n@RestController\n.\nHow to fix it\nRemove the\n@ResponseBody\nannotation from the class or method.\nCode examples\nNoncompliant code example\n```java\n@RestController\npublic class MyController {\n  @ResponseBody // Noncompliant, the @RestController annotation already implies @ResponseBody\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n```\nCompliant solution\n```java\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n```\nNoncompliant code example\n```java\n@RestController\n@ResponseBody // Noncompliant, the @RestController annotation already implies @ResponseBody\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n```\nCompliant solution\n```java\n@RestController\npublic class MyController {\n  @RequestMapping(\"/hello\")\n  public String hello() {\n    return \"Hello World!\";\n  }\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6833": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Controller\" should be replaced with \"@RestController\"\nDescription: Why is this an issue?\nClasses annotated as\n@Controller\nin Spring are responsible for handling incoming web requests. When annotating methods or the entire\ncontroller with\n@ResponseBody\n, the return value of said methods will be serialized and set as the response body. In other words, it tells\nthe Spring framework that this method does not produce a view. This mechanism is commonly used to create API endpoints.\nSpring provides\n@RestController\nas a convenient annotation to replace the combination of\n@Controller\nand\n@ResponseBody\n. The two are functionally identical, so the single annotation approach is preferred.\nThis rule will raise an issue on a class that is annotated with\n@Controller\nif:\n1. the class is also annotated with@ResponseBodyor\n2. all methods in said class are annotated with@ResponseBody.\nHow to fix it\nReplace the\n@Controller\nannotation with the\n@RestController\nannotation and remove all\n@ResponseBody\nannotations from the class and its methods.\nCode examples\nNoncompliant code example\n```java\n@Controller\n@ResponseBody\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n```\nCompliant solution\n```java\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n}\n```\nNoncompliant code example\n```java\n@Controller\npublic class MyController {\n    @ResponseBody\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @ResponseBody\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n```\nCompliant solution\n```java\n@RestController\npublic class MyController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello World!\";\n    }\n\n    @GetMapping(\"/foo\")\n    public String foo() {\n        return \"Foo\";\n    }\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6832": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Non-singleton Spring beans should not be injected into singleton beans\nDescription: In Spring the scope of a bean defines the lifecycle and visibility of that bean in the Spring container. There are six scopes:\n1. Singleton: default, one instance per Spring container\n2. Prototype: a new instance per bean request\n3. Request: a new instance per HTTP request\n4. Session: a new instance per HTTP session\n5. Application: a new instance per ServletContext\n6. Websocket: a new instance per Websocket session\nThe last four scopes mentioned, request, session, application and websocket, are only available in a web-aware application.\nWhy is this an issue?\nIn Spring, singleton beans and their dependencies are initialized when the application context is created.\nIf a\nSingleton\nbean depends on a bean with a shorter-lived scope (like\nRequest\nor\nSession\nbeans), it retains\nthe same instance of that bean, even when new instances are created for each Request or Session. This mismatch can cause unexpected behavior and bugs,\nas the Singleton bean doesn\u2019t interact correctly with the new instances of the shorter-lived bean.\nThis rule raises an issue when non-singleton beans are injected into a singleton bean.\nWhat is the potential impact?\nWhen a\nSingleton\nbean has a dependency on a bean with a shorter-lived scope, it can lead to the following issues:\n1. Data inconsistency: any state change in the shorter-lived bean will not be reflected in the Singleton bean.\n2. Incorrect behavior: using the same instance of the shorter-lived bean, when a new instance is supposed to be created for each\n  new request or session.\n3. Memory leaks: preventing garbage collection of a shorter-lived bean that allocates a significant amount of data over time.\nHow to fix it\nInject a shorter-lived bean into a\nSingleton\nbean using\nApplicationContext\n,\nFactories\nor\nProviders\n.\nCode examples\nNoncompliant code example\nWhen a\nSingleton\nbean auto-wires a\nRequest\nbean, the dependency is resolved at instantiation time and thus the same\ninstance is used for each HTTP request.\n```java\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    @Autowired\n    private final RequestBean requestBean; // Noncompliant, the same instance of RequestBean is used for each HTTP request.\n\n    public RequestBean getRequestBean() {\n        return requestBean;\n    }\n}\n```\nCompliant solution\nInstead, use a\nObjectFactory<RequestBean>\n,\nObjectProvider<RequestBean>\n, or\nProvider<RequestBean>\nas injection point (as for\nJSR-330\n).\nSuch a dependency is resolved at runtime, allowing for actual injection of a new instance of the shorter-lived bean on each HTTP request.\n```java\n@Component\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\npublic class RequestBean {\n    //...\n}\n\npublic class SingletonBean {\n    private final ObjectFactory<RequestBean> requestBeanFactory;\n\n    @Autowired\n    public SingletonBean(ObjectFactory<RequestBean> requestBeanFactory) {\n        this.requestBeanFactory = requestBeanFactory;\n    }\n\n    public RequestBean getRequestBean() {\n        return requestBeanFactory.getObject();\n    }\n}\n```\nNoncompliant code example\nWhen a\nSingleton\nbean auto-wires a\nPrototype\nbean, the dependency is resolved at instantiation time and thus the same\ninstance is used for each bean request.\n```java\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean {\n    private PrototypeBean prototypeBean;\n\n    @Autowired\n    public SingletonBean(PrototypeBean prototypeBean) { // Noncompliant, the same instance of PrototypeBean is used for each bean request.\n      this.prototypeBean = prototypeBean;\n    }\n\n    public Object process() {\n        return prototypeBean.execute();\n    }\n}\n```\nCompliant solution\nUsing the\nApplicationContext\nto retrieve a new instance of a\nPrototype\nbean on each bean request.\n```java\n@Component\n@Scope(\"prototype\")\npublic class PrototypeBean {\n    public Object execute() {\n      //...\n    }\n}\n\npublic class SingletonBean implements ApplicationContextAware {\n    private ApplicationContext applicationContext;\n\n    @Autowired\n    public SingletonBean(ApplicationContext applicationContext) {\n      this.applicationContext = applicationContext;\n    }\n\n    public Object process() {\n        PrototypeBean prototypeBean = createPrototypeBean();\n        return prototypeBean.execute();\n    }\n\n    protected PrototypeBean createPrototypeBean() {\n        return this.applicationContext.getBean(\"prototypeBean\", PrototypeBean.class);\n    }\n}\n```\nDocumentation\n1. Spring Framework -Factory Scopes\n2. Spring Framework -Beans\n  Inject Named\n3. Spring Framework -Method\n  Injection\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6830": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Bean names should adhere to the naming conventions\nDescription: Why is this an issue?\nConsistent naming of beans is important for the readability and maintainability of the code. More precisely, according to the Spring\ndocumentation:\n```java\nNaming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.\n```\nNot following accepted conventions can introduce inconsistent naming, especially when multiple developers work on the same project, leading to\ntechnical debt.\nThe spring documentation establishes a naming convention that consists of camel-cased names with a leading lowercase letter.\nThis rule raises an issue when a bean name defined in one of the following annotations does not adhere to the naming convention:\n1. @Bean\n2. @Configuration\n3. @Controller\n4. @Component\n5. @Qualifier\n6. @Repository\n7. @Service\nHow to fix it\nChange the bean\u2019s name to adhere to the naming conventions. Names should be camel-cased and start with a lowercase letter, for example,\nmyBean\n.\nCode examples\nNoncompliant code example\n```java\n@Bean(name = \"MyBean\") // Noncompliant, the first letter of the name should be lowercase\npublic MyBean myBean() {\n    ...\n```\nCompliant solution\n```java\n@Bean(name = \"myBean\") // Compliant\npublic MyBean myBean() {\n    ...\n```\nNoncompliant code example\n```java\n@Service(\"my_service\") // Noncompliant, the name should be camel-cased\npublic class MyService {\n    ...\n```\nCompliant solution\n```java\n@Service(\"myService\") // Compliant\npublic class MyService {\n    ...\n```\nDocumentation\n1. Spring Framework Documentation -3.3 Bean\n  overview\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6829": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Autowired\" should be used when multiple constructors are provided\nDescription: The\n@Autowired\nannotation in Spring is used for automatic dependency injection. It allows Spring to resolve and inject the required\nbeans into your bean. For example to inject a\n@Repository\nobject into a\n@Service\n.\nWhy is this an issue?\nThe Spring dependency injection mechanism cannot identify which constructor to use for auto-wiring when multiple constructors are present in a\nclass. This ambiguity can cause the application to crash at runtime, and it makes the code less clear to understand and more complex to extend and\nmaintain.\nWhat is the potential impact?\n1. incorrect instantiation: the wrong constructor is selected for instantiation, leading to a bean not being correctly\n  initialized.\n2. unsatisfied dependency exception: the constructor selected by Spring requires beans that are not available in the Spring\n  context.\n3. non-deterministic behavior: the constructor selected by Spring can vary, based on the number of dependencies that can be\n  satisfied at runtime, leading to unpredictable application behavior.\n4. maintainability issues: adding more constructors in the future could lead to further confusion and potential bugs.\nHow to fix it\nUse the\n@Autowired\nannotation to specify which constructor to use for auto-wiring.\nCode examples\nNoncompliant code example\n```java\n@Component\npublic class ExampleClass { // Noncompliant: multiple constructors present and no @Autowired annotation to specify which one to use\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n```\nCompliant solution\n```java\n@Component\npublic class ExampleClass {\n\n    private final DependencyClass1 dependency1;\n\n    public ExampleClass() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    @Autowired\n    public ExampleClass(DependencyClass1 dependency1) {\n        this.dependency1 = dependency1;\n    }\n\n    // ...\n}\n```\nDocumentation\n1. Spring -Annotation Config:\n  Autowired\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6814": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Optional REST parameters should have an object type\nDescription: Why is this an issue?\nSpring provides two options to mark a REST parameter as optional:\nUse\nrequired = false\nin the\n@PathVariable\nor\n@RequestParam\nannotation of the respective method parameter\n  or\nUse type\njava.util.Optional<T>\nfor the method parameter\nWhen using 1., the absence of the parameter, when the REST function is called, is encoded by\nnull\n, which can only be used for object\ntypes. If\nrequired = false\nis used for a parameter with a primitive and the REST function is called without the parameter, a runtime\nexception occurs because the Spring data mapper cannot map the\nnull\nvalue to the parameter.\nHow to fix it\nReplace primitive types, such as\nboolean\n,\nchar\n,\nint\n, with the corresponding wrapper type, such as\nBoolean\n,\nCharacter\n,\nInteger\n.\nAlternatively, you might choose to remove\nrequired = false\nfrom the annotation and use an\nOptional<T>\ntype for the\nparameter, such as\nOptional<Boolean>\nor\nOptional<String>\n, which automatically makes the REST parameter optional.\nThis is the preferred approach because it enforces the proper handling of\nnull\nin the method implementation.\nCode examples\nNoncompliant code example\n```java\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // Noncompliant, null cannot be mapped to int\n   //...\n}\n```\nCompliant solution\n```java\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) Integer articleId) { // Compliant\n   //...\n}\n```\nNoncompliant code example\n```java\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable(required = false) int articleId) { // Noncompliant, null cannot be mapped to int\n   //...\n}\n```\nCompliant solution\n```java\n@RequestMapping(value = {\"/article\", \"/article/{id}\"})\npublic Article getArticle(@PathVariable Optional<Integer> articleId) { // Compliant and preferred approach\n   //...\n}\n```\nDocumentation\n1. Spring\n  Framework API - Annotation Interface PathVariable\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6813": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Field dependency injection should be avoided\nDescription: Why is this an issue?\nDependency injection frameworks such as Spring, Quarkus, and others support dependency injection by using annotations such as\n@Inject\nand\n@Autowired\n. These annotations can be used to inject beans via constructor, setter, and field injection.\nGenerally speaking, field injection is discouraged. It allows the creation of objects in an invalid state and makes testing more difficult. The\ndependencies are not explicit when instantiating a class that uses field injection.\nIn addition, field injection is not compatible with final fields. Keeping dependencies immutable where possible makes the code easier to\nunderstand, easing development and maintenance.\nFinally, because values are injected into fields after the object has been constructed, they cannot be used to initialize other non-injected fields\ninline.\nThis rule raises an issue when the\n@Autowired\nor\n@Inject\nannotations are used on a field.\nHow to fix it\nUse constructor injection instead.\nBy using constructor injection, the dependencies are explicit and must be passed during an object\u2019s construction. This avoids the possibility of\ninstantiating an object in an invalid state and makes types more testable. Fields can be declared final, which makes the code easier to understand, as\ndependencies don\u2019t change after instantiation.\nCode examples\nNoncompliant code example\n```java\npublic class SomeService {\n    @Autowired\n    private SomeDependency someDependency; // Noncompliant\n\n    private String name = someDependency.getName(); // Will throw a NullPointerException\n}\n```\nCompliant solution\n```java\npublic class SomeService {\n    private final SomeDependency someDependency;\n    private final String name;\n\n    @Autowired\n    public SomeService(SomeDependency someDependency) {\n        this.someDependency = someDependency;\n        name = someDependency.getName();\n    }\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6809": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods with Spring proxy should not be called via \"this\"\nDescription: Why is this an issue?\nA method annotated with Spring\u2019s\n@Async\n,\n@Cacheable\nor\n@Transactional\nannotations will not work as expected\nif invoked directly from within its class.\nThis is because Spring generates a proxy class with wrapper code to manage the method\u2019s asynchronicity (\n@Async\n), to cache methods\ninvocations (\n@Cacheable\n), or to handle the transaction (\n@Transactional\n). However, when called using\nthis\n, the\nproxy instance is bypassed, and the method is invoked directly without the required wrapper code.\nHow to fix it\nReplace calls to\n@Async\n,\n@Cacheable\nor\n@Transactional\nmethods via\nthis\nwith calls on an\ninstance that was injected by Spring (\n@Autowired\n,\n@Resource\nor\n@Inject\n). The injected instance is a proxy on\nwhich the methods can be invoked safely.\nCode examples\nNoncompliant code example\n```java\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Override\n  public void process(Notification notification) {\n    processAsync(notification); // Noncompliant, call bypasses proxy\n    retrieveNotification(notification.id); // Noncompliant, call bypasses proxy and will not be cached\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n\n}\n```\nCompliant solution\n```java\n@Service\npublic class AsyncNotificationProcessor implements NotificationProcessor {\n\n  @Resource\n  private AsyncNotificationProcessor asyncNotificationProcessor;\n\n  @Override\n  public void process(Notification notification) {\n    asyncNotificationProcessor.processAsync(notification); // Compliant, call via injected proxy\n    asyncNotificationProcessor.retrieveNotification(notification.id); // Compliant, the call will be cached\n  }\n\n  @Async\n  public processAsync(Notification notification) {\n    // ...\n  }\n\n  @Cacheable\n  public Notification retrieveNotification(Long id) {\n    // ...\n  }\n}\n```\nDocumentation\n1. Spring\n  Framework API - Annotation Interface Async\n2. Spring\n  Framework API - Annotation Interface Transactional\n3. Spring Framework\n  API - Annotation Interface Cacheable\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6804": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Value\" annotation should inject property or SpEL expression\nDescription: This rule reports when the Spring\n@Value\nannotation injects a simple value that does not contain an expression.\nWhy is this an issue?\nThe purpose of the\n@Value\nannotation in\norg.springframework.beans.factory.annotation\nis to inject a value into a field or\nmethod based on the Spring context after it has been established.\nIf the annotation does not include an expression (either Spring Expression Language or a property injection), the injected value is a simple\nconstant that does not depend on the Spring context, making the annotation replaceable with a standard field initialization statement.\nThis not only implies the redundant use of\n@Value\n, but could also indicate an error where the expression indicators (\n#\n,\n$\n) were omitted by mistake.\nExceptions\nThis rule does not raise an issue if\n@Value\nis applied to a method or method argument, because the annotation has the side effect that\nthe method is called.\nHow to fix it\n1. If a property is to be injected, use${propertyName}instead ofpropertyName.\n2. If a SpEL expression is to be evaluated, use#{expression}instead ofexpression.\n3. If you intend to initialize a field with a simple value or with an expression that does not depend on the Spring context, use a standard field\n  initialization statement.\nCode examples\nNoncompliant code example\n```java\n@Value(\"catalog.name\") // Noncompliant, this will not inject the property\nString catalog;\n```\nCompliant solution\n```java\n@Value(\"${catalog.name}\") // Compliant\nString catalog;\n```\nNoncompliant code example\n```java\n@Value(\"book.topics[0]\") // Noncompliant, this will not evaluate the expression\nTopic topic;\n```\nCompliant solution\n```java\n@Value(\"#{book.topics[0]}\") // Compliant\nTopic topic;\n```\nNoncompliant code example\n```java\n@Value(\"Hello, world!\") // Noncompliant, this use of @Value is redundant\nString greeting;\n```\nCompliant solution\n```java\nString greeting = \"Hello, world!\"; // Compliant\n```\nDocumentation\n1. Spring\n  Framework API - Annotation Interface Value\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6665": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant nullability annotations should be removed\nDescription: Why is this an issue?\nNullability annotations in Java are used to indicate whether a variable or parameter can be assigned a null value or not. These annotations help to prevent Null Pointer Exceptions and improve the reliability of code.\nRedundant nullability annotations can clutter the code and make it harder to read and understand. When a nullability annotation is already implied by the context or by other annotations, explicitly adding it again only adds noise and makes the code less clear.\nRemoving them improves code readability, maintainability, reduces the risk of inconsistencies, and ensures that the remaining annotations carry meaningful information.\nNoncompliant code example\nJSpecify code example:\n```java\n@NullMarked\nclass MyClass {\n  public void method(@NonNull Object o) { // Noncompliant: @NonNull is redundant here\n    // ...\n  }\n}\n```\nCompliant solution\n```java\n@NullMarked\nclass MyClass {\n  public void method(Object o) {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6548": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The Singleton design pattern should be used with care\nDescription: The Singleton design pattern is a creational pattern. It ensures that only one class instance is created and provides a global point of access to\nit. There are several ways to implement a Singleton in Java, and the debate about the best approach has yet to be settled.\nThis rule marks all classes that are considered as Singletons, regardless of how they are implemented. This helps developers identify where in the\ncode Singletons are used. Singletons should be reviewed to confirm whether a Singleton is truly necessary and whether the selected implementation is\nthe most suitable for the context.\nEvery Singleton implementation has its advantages and disadvantages. This rule exists to bring attention to them so that informed decisions can be\nmade.\nWhy is this an issue?\nWhile the Singleton pattern can be useful in certain situations, overusing it can have several drawbacks:\n1. Tight coupling: The Singleton pattern can create tight coupling between the Singleton class and other classes that use it, making the code\n  difficult to maintain and modify.\n2. Global state: The Singleton pattern can create a global state, making it difficult to manage the state of the application and leading to\n  unexpected behavior.\n3. Testing: The Singleton pattern can make it difficult to test classes that depend on the Singleton, as the Singleton cannot be easily\n  substituted with a mock object.\n4. Scalability: The Singleton pattern can make it difficult to scale an application, as it can create a bottleneck if multiple threads try to\n  access the Singleton concurrently.\n5. Dependency injection: The Singleton pattern can make it difficult to use dependency injection frameworks, as the Singleton instance is usually\n  created statically.\nIn general, the Singleton pattern should be used sparingly and only in situations where it provides a clear benefit over other patterns or\napproaches. It is important to consider the drawbacks and tradeoffs of using the Singleton pattern before incorporating it into an application.\nWhat is the potential impact?\nEnum Implementation\n```java\npublic enum EnumSingleton {\n\n    INSTANCE;\n\n    private EnumSingleton() {\n        // Initialization code here...\n    }\n}\n```\nAdvantages\n:\nThis implementation is thread-safe by default because the initialization of an Enum value is guaranteed to be thread-safe and atomic.\nThe Enum Singleton implementation allows for lazy initialization while also providing thread-safety guarantees.\nBill Pugh Implementation\n```java\npublic class BillPughSingleton {\n\n    private BillPughSingleton(){}\n\n    private static class SingletonHelper {\n        private static final BillPughSingleton INSTANCE = new BillPughSingleton();\n    }\n\n    public static BillPughSingleton getInstance() {\n        return SingletonHelper.INSTANCE;\n    }\n}\n```\nAdvantages\n:\nThe instance is created only at the first call of the\ngetInstance()\nmethod.\nThis implementation is thread-safe.\nThread Safe Implementation\n```java\npublic class ThreadSafeSingleton {\n\n    private static ThreadSafeSingleton instance;\n\n    private ThreadSafeSingleton(){}\n\n    public static synchronized ThreadSafeSingleton getInstance() {\n        if (instance == null) {\n            instance = new ThreadSafeSingleton();\n        }\n        return instance;\n    }\n}\n```\nAdvantage\n:\nThis implementation is thread-safe.\nDisadvantage\n:\nIt reduces the performance because of the cost associated with the synchronized method. To avoid this extra overhead every time, double-checked\nlocking principle should be used.\nStatic Block Initialization Implementation\n```java\npublic class StaticBlockSingleton {\n\n    private static StaticBlockSingleton instance;\n\n    private StaticBlockSingleton(){}\n\n    static {\n        try {\n            instance = new StaticBlockSingleton();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Exception while creating singleton instance\");\n        }\n    }\n\n    public static StaticBlockSingleton getInstance() {\n        return instance;\n    }\n}\n```\nAdvantage\n:\nCompared to the Eager Initialization, this implementation provides options for exception handling.\nDisadvantage\n:\nThe instance is created even if it\u2019s never used, like for the Eager Initialization implementation.\nEager Initialization Implementation\n```java\npublic class EagerInitializedSingleton {\n\n    private static final EagerInitializedSingleton instance = new EagerInitializedSingleton();\n\n    private EagerInitializedSingleton() {}\n\n    public static EagerInitializedSingleton getInstance() {\n        return instance;\n    }\n}\n```\nAdvantage\n:\nThis implementation is thread-safe, as the instance variable is initialized when the class is loaded.\nDisadvantages\n:\nThe instance is created even if it\u2019s never used, which can be wasteful in terms of memory usage. However, if the Singleton is expected to be used\nfrequently or is not too memory-intensive, Eager Initialization can be a good choice.\nThis implementation doesn\u2019t provide any options for exception handling.\nLazy Initialization Implementation\n```java\npublic class LazyInitializedSingleton {\n\n    private static LazyInitializedSingleton instance;\n\n    private LazyInitializedSingleton(){}\n\n    public static LazyInitializedSingleton getInstance() {\n        if (instance == null) {\n            instance = new LazyInitializedSingleton();\n        }\n        return instance;\n    }\n}\n```\nAdvantage\n:\nThis implementation works fine in the case of the single-threaded environment.\nDisadvantage\n:\nThis implementation is not thread-safe if multiple threads are at the same time in the\nif\ncondition.\nPublic Static Field Implementation\n```java\npublic class PublicStaticSingleton {\n\n    public static final PublicStaticSingleton INSTANCE = new PublicStaticSingleton();\n\n    private PublicStaticSingleton() {}\n}\n```\nAdvantage\n:\nThis implementation is thread-safe.\nDisadvantage\n:\nThis implementation does not allow lazy initialization: the constructor runs as soon as the class is initialized.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6541": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not perform too many tasks (aka Brain method)\nDescription: Methods should not perform too many tasks (Brain Method).\nWhy is this an issue?\nThis issue is raised when Sonar considers that a method is a 'Brain Method'.\nA Brain Method is a method that tends to centralize its owner\u2019s\nclass logic and generally performs too many operations. This can include checking too many conditions, using lots of variables, and ultimately making\nit difficult to understand, maintain and reuse.\nIt is characterized by high LOC number, high cyclomatic and cognitive complexity, and a large\nnumber of variables being used.\nWhat is the potential impact?\nBrain Methods are often hard to cover with tests, because of their deep nesting, and they are error-prone, because of the many local variables they\nusually introduce. Such methods will be very hard to read and understand for anyone outside who created them, and therefore hard to maintain and fix\nif bugs get spotted.\nThey also enable code duplication since the method itself can hardly be reused anywhere else.\nHow to fix it\nThe common approach is to identify fragments of the method\u2019s code that deal with a specific responsibility and extract them to a new method. This\nwill make each method more readable, easy to understand and maintain, easier to test, and more prone to be reused.\nIn this paper, the authors\ndescribe a systematic procedure to refactor this type of code smell:\n\"Assessing the Refactoring of\nBrain Methods\"\n.\nCode examples\nNoncompliant code example\n```java\nvoid farmDailyRoutine() {\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List<Bottle> bottles = new ArrayList<>();\n    for(int i = 0; i < 10; i++) {\n        var bottle = new Bottle();\n        bottle.addWater(10L);\n        bottle.putCap();\n        bottle.shake(2);\n        bottles.add(bottle);\n    }\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        List<Bottle> extraBottles = new ArrayList<>();\n        if(southEastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        if(eastCrops.isDry()) {\n            for(LandSlot ls : southEastCrops.lands()) {\n                Bottle b = new Bottle();\n                b.addWater(10L);\n                b.putCap();\n                extraBottles.add(b);\n            }\n        } else {\n            extraBottles.add(new Bottle());\n        }\n        extraWaterContainer.store(extraBottles);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n```\nCompliant solution\n```java\nvoid farmDailyRoutine() { // Compliant: Simpler method, making use of extracted and distributed logic\n    Crops southEastCrops = getCrops(1, -1);\n    Crops eastCrops = getCrops(1, 0);\n    WaterContainer waterContainer = new WaterContainer();\n    List<Bottle> bottles = getWaterBottles(10, 10L, true);\n    waterContainer.store(bottles);\n\n    Truck t1 = new Truck(Truck.Type.TRANSPORT);\n    t1.load(waterContainer);\n    if(Weather.current != Weather.RAINY) {\n        WaterContainer extraWaterContainer = new WaterContainer();\n        fillContainerForCrops(extraWaterContainer, southEastCrops);\n        fillContainerForCrops(extraWaterContainer, eastCrops);\n        t1.load(extraWaterContainer);\n    } else {\n        WaterContainer extraWaterContainer = WaterSource.clone(waterContainer);\n        t1.load(extraWaterContainer)\n    }\n}\n\nprivate fillContainerForCrops(WaterContainer wc, Crops crops) { // Compliant: extracted readable and reusable method\n    if(crops.isDry()) {\n        wc.store(getWaterBottles(crops.lands().size(), 10L, false));\n    } else {\n        wc.store(Collections.singleton(new Bottle()));\n    }\n}\n\nprivate List<Bottle> getWaterBottles(int qt, long liquid, boolean shake){ // Compliant: extracted readable and reusable method\n    List<Bottle> bottles = new ArrayList<>();\n    for(int i = 0; i < qt; i++) {\n        Bottle b = new Bottle();\n        b.addWater(liquid);\n        b.putCap();\n        if(shake) {\n            b.shake();\n        }\n        bottles.add(b);\n    }\n    return bottles;\n}\n```\nHow does this work?\nIn this case, the method\nfarmDailyRoutine\nwas taking care of performing many different tasks, with nested conditions and loops, it was\nlong and had plenty of local variables. By separating its logic into multiple single-responsibility methods, it is reusing parts of its original\nduplicated code and each of the new methods is now readable and easy to understand. They are now also easier to cover with tests, and many other parts\nof the owner class could benefit from using these methods.\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6539": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not depend on an excessive number of classes (aka Monster Class)\nDescription: \"Monster Class\" is a class that implements too many functionalities that are not well organized, or cohesive. Monster Classes are not created\nintentionally, but rather they often arise over time as a result of poor software design or a lack of attention to good programming practices such as\nmodularization and encapsulation. As a software evolves and new requirements are added, it can be tempting to add new functionality to existing\nclasses rather than creating new classes to handle the new functionality. This leads to classes becoming bloated and difficult to understand and\nmaintain, ultimately resulting in a Monster Class.\nHere are the characteristics of a Monster Class:\n1. High number of instance variables and methods\n2. Variables and methods that are not related to each other (low cohesion and high coupling)\n3. Too many responsibilities, violating the Single Responsibility Principle (aka SRP)\n4. Difficult to test, leading to poor test coverage and a higher risk of defects\nWhy is this an issue?\nMonster Classes become monolithic entities, with numerous responsibilities and functionalities packed into a single class. This is problematic\nbecause it violates the Single Responsibility Principle, which states that a class should have only one reason to change.\nWhen a class has too many responsibilities and functionalities, it becomes difficult to maintain. Changes to one part of the class can\nunintentionally affect other parts, leading to bugs. Additionally, it can be difficult to test the class, as there may be many different interactions\nbetween different parts of the class that need to be considered.\nHow to fix it\nThere is no magical recipe. Monster Classes should be refactored and broken into smaller, more focused classes, each one with a single\nresponsibility. When a class has only one responsibility, it is easier to reason about its behavior and to make changes to it without affecting other\nparts of the code.\nCode examples\nNoncompliant code example\nWith a threshold of 5:\n```java\nclass Foo { // class Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n  T1 t1;\n  T2 t2;\n  T3 t3;\n\n  public T4 compute(T5 a, T6 b) {\n    T7 result = a.getResult(b);\n    return (T4) result;\n  }\n}\n```\nCompliant solution\n```java\npublic class Bar {\n    T8 a8;\n    T9 a9;\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6485": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Hash-based collections with known capacity should be initialized with the proper related static method.\nDescription: Hash-based collections with known capacity should be initialized with the proper related static method.\nWhy is this an issue?\nWhen creating an instance of HashMap or HashSet, the developer can pick a constructor with known capacity. However, the requested capacity is not\nfully allocated by default. Indeed, when the collection reaches the load factor of the collection (default: 0.75), the collection is resized on the\nfly, leading to unexpected performance issues.\nHow to fix it\nAs of Java 19, hash-based collections provide a static method that allocates the requested capacity at construction time.\nCode examples\nNoncompliant code example\n```java\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map<String, Integer> buildAMap() {\n    return new HashMap<>(KNOWN_CAPACITY); // Noncompliant\n}\n\npublic static Set<String> buildASet() {\n    return new HashSet<>(KNOWN_CAPACITY); // Noncompliant\n}\n```\nCompliant solution\n```java\nprivate static final int KNOWN_CAPACITY = 1_000_000;\n\npublic static Map<String, Integer> buildABetterMap() {\n    return HashMap.newHashMap(KNOWN_CAPACITY);\n}\n\npublic static Set<String> buildABetterSet() {\n    return HashSet.newHashSet(KNOWN_CAPACITY);\n}\n\npublic static Set<String> buildABetterSet(float customLoadFactor) {\n    return new HashSet<>(KNOWN_CAPACITY, customLoadFactor);\n}\n```\nDocumentation\n1. https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashMap.html#newHashMap(int)\n2. https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/HashSet.html#newHashSet(int)\n3. https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashMap.html#newLinkedHashMap(int)\n4. https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/LinkedHashSet.html#newLinkedHashSet(int)\n5. https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/WeakHashMap.html#newWeakHashMap(int)\nMessage:\nReplace this call to the constructor with the better suited static method.\nHighlighting:\nThe infringing constructor call.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6411": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Types used as keys in Maps should implement Comparable\nDescription: Why is this an issue?\nMaps use hashes of the keys to select a bucket to store data in. Objects that hash to the same value will be added to the same bucket.\nWhen the hashing function has a poor distribution, buckets can grow to very large sizes. This may negatively affect lookup performance, as, by\ndefault, matching a key within a bucket has linear complexity.\nIn addition, as the default hashCode function can be selected at runtime, performance expectations cannot be maintained.\nImplementing Comparable mitigates the performance issue for objects that hash to the same value.\nNoncompliant code example\n```java\nclass MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map<MyKeyType, MyValueType> data = new HashMap<>(); // Noncompliant\n\n    Map<MyKeyType, MyValueType> buildMap() { // Noncompliant\n        //...\n    }\n}\n```\nCompliant solution\n```java\nclass MyKeyType implements Comparable<MyKeyType> {\n    // ...\n}\n\nclass MyChildKeyType extends MyKeyType {\n    // ...\n}\n\nclass Program {\n    Map<MyKeyType, MyValueType> data = new HashMap<>();\n    Map<MyChildKeyType, MyValueType> data = new HashMap<>();\n\n    Map<MyKeyType, MyValueType> buildMap() {\n        //...\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6397": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Character classes in regular expressions should not contain only one character\nDescription: Why is this an issue?\nCharacter classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or\nranges of characters. If a character class contains only one character, the effect is the same as just writing the character without a character\nclass.\nThus, having only one character in a character class is usually a simple oversight that remained after removing other characters of the class.\nNoncompliant code example\n```java\n\"a[b]c\"\n\"[\\\\^]\"\n```\nCompliant solution\n```java\n\"abc\"\n\"\\\\^\"\n\"a[*]c\" // Compliant, see Exceptions\n```\nExceptions\nThis rule does not raise when the character inside the class is a metacharacter. This notation is sometimes used to avoid escaping (e.g.,\n[.]{3}\nto match three dots).\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6396": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Superfluous curly brace quantifiers should be avoided\nDescription: Why is this an issue?\nCurly brace quantifiers in regular expressions can be used to have a more fine-grained control over how many times the character or the\nsub-expression preceeding them should occur. They can be used to match an expression exactly n times with\n{n}\n, between n and m times with\n{n,m}\n, or at least n times with\n{n,}\n. In some cases, using such a quantifier is superfluous for the semantic of the regular\nexpression, and it can be removed to improve readability. This rule raises an issue when one of the following quantifiers is encountered:\n1. {1,1}or{1}: they match the expression exactly once. The same behavior can be achieved without the quantifier.\n2. {0,0}or{0}: they match the expression zero times. The same behavior can be achieved by removing the expression.\nNoncompliant code example\n```java\n\"ab{1,1}c\"\n\"ab{1}c\"\n\"ab{0,0}c\"\n\"ab{0}c\"\n```\nCompliant solution\n```java\n\"abc\"\n\"ac\"\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6395": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Non-capturing groups without quantifier should not be used\nDescription: Why is this an issue?\nSub-patterns can be wrapped by parentheses to build a group. This enables to restrict alternations, back reference the group or apply quantifier to\nthe sub-pattern.\nIf this group should not be part of the match result or if no reference to this group is required, a non-capturing group can be created by adding\n?:\nbehind the opening parenthesis.\nHowever, if this non-capturing group does not have a quantifier, or does not wrap an alternation, then imaging this group is redundant.\nNoncompliant code example\n```java\n\"(?:number)\\\\d{2}\"\n```\nCompliant solution\n```java\n\"number\\\\d{2}\"      \t// it is anyway required\n\"(?:number)?\\\\d{2}\"  \t// it is in fact optional\n```\nExceptions\nThis rule does not report an issue if the non-capturing group is an alternation.\n```java\n\"(?:number|string)\"\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6355": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Deprecated annotations should include explanations\nDescription: Why is this an issue?\nSince Java 9,\n@Deprecated\nhas two additional arguments to the annotation:\n1. sinceallows you to describe when the deprecation took place\n2. forRemoval, indicates whether the deprecated element will be removed at some future date\nIn order to ease the maintainers work, it is recommended to always add one or both of these arguments.\nThis rule reports an issue when\n@Deprecated\nis used without any argument.\nNoncompliant code example\n```java\n@Deprecated\n```\nCompliant solution\n```java\n@Deprecated(since=\"4.2\", forRemoval=true)\n```\nExceptions\nThe members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to\nit.\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6353": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regular expression quantifiers and character classes should be used concisely\nDescription: Why is this an issue?\nA regular expression is a sequence of characters that specifies a match pattern in text. Among the most important concepts are:\n1. Character classes: defines a set of characters, any one of which can occur in an input string for a match to succeed.\n2. Quantifiers: used to specify how many instances of a character, group, or character class must be present in the input for a match.\n3. Wildcard (.): matches all characters except line terminators (also matches them if thesflag is set).\nMany of these features include shortcuts of widely used expressions, so there is more than one way to construct a regular expression to achieve the\nsame results. For example, to match a two-digit number, one could write\n[0-9]{2,2}\nor\n\\d{2}\n. The latter is not only shorter\nbut easier to read and thus to maintain.\nThis rule recommends replacing some quantifiers and character classes with more concise equivalents:\n1. \\dfor[0-9]and\\Dfor[^0-9]\n2. \\wfor[A-Za-z0-9_]and\\Wfor[^A-Za-z0-9_]\n3. .for character classes matching everything (e.g.[\\w\\W],[\\d\\D], or[\\s\\S]withsflag)\n4. x?forx{0,1},x*forx{0,},x+forx{1,},x{N}forx{N,N}\n```java\n\"[0-9]\"        // Noncompliant - same as \"\\\\d\"\n\"[^0-9]\"       // Noncompliant - same as \"\\\\D\"\n\"[A-Za-z0-9_]\" // Noncompliant - same as \"\\\\w\"\n\"[\\\\w\\\\W]\"     // Noncompliant - same as \".\"\n\"a{0,}\"        // Noncompliant - same as \"a*\"\n```\nUse the more concise version to make the regex expression more readable.\n```java\n\"\\\\d\"\n\"\\\\D\"\n\"\\\\w\"\n\".\"\n\"a*\"\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6331": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regular expressions should not contain empty groups\nDescription: Why is this an issue?\nThere are several reasons to use a group in a regular expression:\n1. to change the precedence (e.g.do(g|or)will match 'dog' and 'door')\n2. to remember parenthesised part of the match in the case of capturing group\n3. to improve readability\nIn any case, having an empty group is most probably a mistake. Either it is a leftover after refactoring and should be removed, or the actual\nparentheses were intended and were not escaped.\nNoncompliant code example\n```java\n\"foo()\"  // Noncompliant, will match only 'foo'\n```\nCompliant solution\n```java\n\"foo\\\\(\\\\)\"  // Matches 'foo()'\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6326": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regular expressions should not contain multiple spaces\nDescription: Why is this an issue?\nMultiple spaces in a regular expression can make it hard to tell how many spaces should be matched. It\u2019s more readable to use only one space and\nthen indicate with a quantifier how many spaces are expected.\nNoncompliant code example\n```java\nPattern.compile(\"hello   world\");\n```\nCompliant solution\n```java\nPattern.compile(\"hello {3}world\");\n```\nExceptions\nIn\nfree-spacing mode\n(\nPattern.COMMENTS\nflag, or with embedded flag\nexpression\n(?x)\n), whitespaces are ignored. In this case no issue should be triggered, because the whitespaces may be intended to improve\nreadability.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6262": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: AWS region should not be set with a hardcoded String\nDescription: Why is this an issue?\nWhen explicitly setting the region on an AWS Client, you should always prefer providing the value from the Enum\nRegions\ninstead of a hardcoded String.\nThis will allow you to transparently support any change in the API and avoid mistakes.\nThis rule reports an issue when a hardcoded string is used instead of an available enum value.\nNoncompliant code example\n```java\nAmazonS3ClientBuilder.standard().withRegion(\"eu_west_1\").build();\n```\nCompliant solution\n```java\nAmazonS3ClientBuilder.standard().withRegion(Regions.EU_WEST_1).build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6246": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas should not invoke other lambdas synchronously\nDescription: Why is this an issue?\nInvoking other Lambdas synchronously from a Lambda is a scalability anti-pattern. Lambdas have a maximum execution time before they timeout (15\nminutes as of May 2021). Having to wait for another Lambda to finish its execution could lead to a timeout.\nA better solution is to generate\u00a0events that can be consumed asynchronously by other Lambdas.\nNoncompliant code example\nWith AWS SDKv1\n```java\nInvokeRequest invokeRequest = new InvokeRequest()\n         .withFunctionName(\"myFunction\");\n\nAWSLambda awsLambda = AWSLambdaClientBuilder.standard()\n\t\t.withCredentials(new ProfileCredentialsProvider())\n\t\t.withRegion(Regions.US_WEST_2).build();\n\nawsLambda.invoke(invokeRequest); // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6244": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Consumer Builders should be used\nDescription: Why is this an issue?\nSome API, like the AWS SDK, heavily rely on the builder pattern to create different data structures. Despite all the benefits, this pattern can\nbecome really verbose, especially when dealing with nested structures. In order to reach a more concise code, \"Consumer Builders\", also called\n\"Consumer Interface\" are often introduced.\nThe idea is to overload the methods taking others structures in a Builder with a Consumer of Builder instead. This enables to use a lambda instead\nof nesting another Builder, resulting in more concise and readable code.\nThis rule reports an issue when the Consumer Builder methods could be used instead of the classical ones.\nNoncompliant code example\n```java\nSendEmailRequest.builder()\n  .destination(Destination.builder()\n    .toAddresses(\"to-email@domain.com\")\n    .bccAddresses(\"bcc-email@domain.com\")\n    .build())\n.build();\n```\nCompliant solution\n```java\nSendEmailRequest.builder()\n  .destination(d -> d.toAddresses(\"to-email@domain.com\").bccAddresses(\"bcc-email@domain.com\"))\n  .build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6243": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Reusable resources should be initialized at construction time of Lambda functions\nDescription: Why is this an issue?\nResources that can be reused across multiple invocations of the Lambda function should be initialized at construction time. For example in the\nconstructor of the class, or in field initializers. This way, when the same container is reused for multiple function invocations, the existing\ninstance can be reused, along with all resources stored in its fields. It is a good practice to reuse SDK clients and database connections by\ninitializing them at class construction time, to avoid recreating them on every lambda invocation. Failing to do so can lead to performance\ndegradation, and when not closed properly, even out of memory errors.\nThis rule reports an issue when the SDK client or the database connection is initialized locally inside a Lambda function.\nNoncompliant code example\n```java\npublic class App implements RequestHandler<Object, Object> {\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      S3Client s3Client = DependencyFactory.s3Client();\n      s3Client.listBuckets();\n      // ...\n    }\n}\n```\nCompliant solution\n```java\npublic class App implements RequestHandler<Object, Object> {\n    private final S3Client s3Client;\n\n    public App() {\n      s3Client = DependencyFactory.s3Client();\n    }\n\n    @Override\n    public Object handleRequest(final Object input, final Context context) {\n      s3Client.listBuckets();\n      // ...\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6242": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Credentials Provider should be set explicitly when creating a new \"AwsClient\"\nDescription: Why is this an issue?\nIf the credentials provider is not specified when creating a new AwsClient with an\nAwsClientBuilder\n, the AWS SDK\nwill execute some logic to identify it automatically.\nWhile it will probably identify the correct one, this extra logic will slow down startup time, already known to be a hotspot.\nYou should therefore always define the logic to set the credentials provider yourself. This is typically done by retrieving it from the Lambda\nprovided environment variable.\nThis will make the code more explicit and spare initialization time.\nThis rule reports an issue when the credentials provider is not set when creating an AwsClient.\nNoncompliant code example\n```java\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable())))\n    .build();\n```\nCompliant solution\n```java\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6241": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Region should be set explicitly when creating a new \"AwsClient\"\nDescription: Why is this an issue?\nIf the region is not specified when creating a new AwsClient with an\nAwsClientBuilder\n, the AWS SDK\nwill execute some logic to identify the endpoint automatically.\nWhile it will probably identify the correct one, this extra logic will slow down startup time, already known to be a hotspot.\nYou should therefore always define the logic to set the region yourself. This is typically done by retrieving the region from the Lambda provided\nAWS_REGION environment variable.\nThis will make the code more explicit and spare initialization time.\nThis rule reports an issue when the region is not set when creating an AwsClient.\nNoncompliant code example\n```java\nS3Client.builder()\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n```\nCompliant solution\n```java\nS3Client.builder()\n    .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable()))\n    .credentialsProvider(EnvironmentVariableCredentialsProvider.create())\n    .build();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6219": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: 'serialVersionUID' field should not be set to '0L' in records\nDescription: Why is this an issue?\nIn Records serialization is not done the same way as for ordinary serializable or externalizable classes. Records serialization does not rely on\nthe\nserialVersionUID\nfield, because the requirement to have this field equal is waived for record classes. By default, all records will\nhave this field equal to\n0L\nand there is no need to specify this field with\n0L\nvalue and it is possible to specify it with\nsome custom value to support serialization/deserialization involving ordinary classes.\nThis rule raises an issue when there is a\nprivate static final long serialVersionUID\nfield which is set to\n0L\nin a Record\nclass.\nNoncompliant code example\n```java\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 0L; // Noncompliant\n}\n```\nCompliant solution\n```java\nrecord Person(String name, int age) implements Serializable {} // Compliant\n\nrecord Person(String name, int age) implements Serializable {\n@Serial\n  private static final long serialVersionUID = 42L; // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6217": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Permitted types of a sealed class should be omitted if they are declared in the same file\nDescription: Why is this an issue?\nsealed\nclasses were introduced in Java 17. This feature is very useful if there is a need to define a strict hierarchy and restrict\nthe possibility of extending classes. In order to mention all the allowed subclasses, there is a keyword\npermits\n, which should be\nfollowed by subclasses' names.\nThis notation is quite useful if subclasses of a given\nsealed\nclass can be found in different files, packages, or even modules. In\ncase when all subclasses are declared in the same file there is no need to mention the explicitly and\npermits\npart of a declaration can\nbe omitted.\nThis rule reports an issue if all subclasses of a\nsealed\nclass are declared in the same file as their superclass.\nNoncompliant code example\n```java\nsealed class A permits B, C, D, E {} // Noncompliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n```\nCompliant solution\n```java\nsealed class A {} // Compliant\nfinal class B extends A {}\nfinal class C extends A {}\nfinal class D extends A {}\nfinal class E extends A {}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6213": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Restricted Identifiers should not be used as Identifiers\nDescription: Why is this an issue?\nEven if it is technically possible,\nRestricted Identifiers\nshould not be used as identifiers. This is only possible for compatibility reasons, using it in Java code is confusing and should be avoided.\nNote that this applies to any version of Java, including the one where these identifiers are not yet restricted, to avoid future confusion.\nThis rule reports an issue when restricted identifiers:\n1. var\n2. yield\n3. record\nare used as identifiers.\nNoncompliant code example\n```java\nvar var = \"var\"; // Noncompliant: compiles but this code is confusing\nvar = \"what is this?\";\n\nint yield(int i) { // Noncompliant\n  return switch (i) {\n    case 1: yield(0); // This is a yield from switch expression, not a recursive call.\n    default: yield(i-1);\n  };\n}\n\nString record = \"record\"; // Noncompliant\n```\nCompliant solution\n```java\nvar myVariable = \"var\";\n\nint minusOne(int i) {\n  return switch (i) {\n    case 1: yield(0);\n    default: yield(i-1);\n  };\n}\n\nString myRecord = \"record\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6212": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local-Variable Type Inference should be used\nDescription: Why is this an issue?\nIn Java 10\nLocal-Variable Type Inference\nwas introduced. It allows you to omit the expected type of\na variable by declaring it with the\nvar\nkeyword.\nWhile it is not always possible or cleaner to use this new way of declaring a variable, when the type on the left is the same as the one on the\nright in an assignment, using the\nvar\nwill result in a more concise code.\nThis rule reports an issue when the expected type of the variable is the same as the returned type of assigned expression and the type can be\neasily inferred by the reader, either when the type is already mentioned in the name or the initializer, or when the expression is\nself-explanatory.\nNoncompliant code example\n```java\nMyClass myClass = new MyClass();\n\nint i = 10; // Type is self-explanatory\n\nMyClass something = MyClass.getMyClass(); // Type is already mentioned in the initializer\n\nMyClass myClass = get(); // Type is already mentioned in the name\n```\nCompliant solution\n```java\nvar myClass = new MyClass();\n\nvar i = 10;\n\nvar something = MyClass.getMyClass();\n\nvar myClass = get();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6211": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Custom getter method should not be used to override record's getter behavior\nDescription: Why is this an issue?\nBefore records appeared in Java 16, there was a common way to represent getters for private fields of a class:\u00a0 a method named \"get\" with a\ncapitalized field name. For example, for a\nString\nfield named \"myField\" the signature of the getter method will be:\npublic\nString getMyField()\nIn records, getters are named differently. Getters created by default do not contain the \"get\" prefix. So for a record\u2019s\nString\nfield\n\"myField\" the getter method will be:\npublic String myField()\nThis means that if you want to override the default getter behavior it is better to use the method provided by records instead of creating a new\none. Otherwise, this will bring confusion to the users of the record as two getters will be available and even leads to bugs if the behavior is\ndifferent from the default one.\nThis rule raises an issue when a record contains a getter named \"get\" with a capitalized field name that is not behaving the same as the default\none.\nNoncompliant code example\n```java\nrecord Person(String name, int age) {\n    public String getName() { // Noncompliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n```\nCompliant solution\n```java\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n\nrecord Person(String name, int age) {\n    public String getNameUpperCase() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\nrecord Person(String name, int age) {\n    public String getName() { // Compliant, is equivalent to 'name()'\n        return name;\n    }\n}\nrecord Person(String name, int age) {\n    @Override\n    public String name() { // Compliant\n        return name.toUpperCase(Locale.ROOT);\n    }\n    public String getName() { // Compliant, equal to 'name()'\n        return name.toUpperCase(Locale.ROOT);\n    }\n}\n```\nExceptions\nIf the implementations of\ngetMyField()\nand\nmyField()\nmethods are equivalent, the issue should not be raised as this was\nprobably done to support compatibility with the previous convention.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6208": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comma-separated labels should be used in Switch with colon case\nDescription: Why is this an issue?\nIn Java 14 there is a new way to write cases in Switch Statement and Expression when the same action should be performed for different cases.\nInstead of declaring multiples branches with the same action, you can combine all of them in a single case group, separated with commas. It will\nresult in a more concise code and improved readability.\nThis rule reports an issue when multiple cases in a Switch can be grouped into a single comma-separated case.\nNoncompliant code example\n```java\n// Switch Expression\nint i = switch (mode) {\n  case \"a\":\n  case \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch Statement\nswitch (mode) {\n  case \"a\":\n  case \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n```\nCompliant solution\n```java\n// Switch Expression\nint i = switch (mode) {\n  case \"a\", \"b\":\n    yield 1;\n  default:\n    yield 3;\n};\n\n// Switch Statement\nswitch (mode) {\n  case \"a\", \"b\":\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n}\n\n// Or even better:\nswitch (mode) {\n  case \"a\", \"b\" -> doSomething();\n  default -> doSomethingElse();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6207": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant constructors/methods should be avoided in records\nDescription: Why is this an issue?\nIn Java 16 records represent a brief notation for immutable data structures. Records have autogenerated implementations for constructors with all\nparameters,\ngetters\n,\nequals\n,\nhashcode\nand\ntoString\n. Although these methods can still be overridden\ninside records, there is no use to do so if no special logic is required.\nThis rule reports an issue on empty compact constructors, trivial canonical constructors and simple getter methods with no additional logic.\nNoncompliant code example\n```java\nrecord Person(String name, int age) {\n  Person(String name, int age) { // Noncompliant, already autogenerated\n    this.name = name;\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // Noncompliant, no need for empty compact constructor\n  }\n  public String name() { // Noncompliant, already autogenerated\n    return name;\n  }\n}\n```\nCompliant solution\n```java\nrecord Person(String name, int age) { } // Compliant\n\nrecord Person(String name, int age) {\n  Person(String name, int age) { // Compliant\n    this.name = name.toLowerCase(Locale.ROOT);\n    this.age = age;\n  }\n}\n\nrecord Person(String name, int age) {\n  Person { // Compliant\n    if (age < 0) {\n      throw new IllegalArgumentException(\"Negative age\");\n    }\n  }\n  public String name() { // Compliant\n    return name.toUpperCase(Locale.ROOT);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6206": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Records should be used instead of ordinary classes when representing immutable data structure\nDescription: Why is this an issue?\nIn Java 16\nrecords\nare finalized and can be safely used in production code.\nRecords\nrepresent immutable read-only data\nstructure and should be used instead of creating immutable classes. Immutability of records is guaranteed by the Java language itself, while\nimplementing immutable classes on your own might lead to some bugs.\nOne of the important aspects of\nrecords\nis that final fields can\u2019t be overwritten using reflection.\nThis rule reports an issue on classes for which all these statements are true:\n1. all instance fields are private and final\n2. has only one constructor with a parameter for all fields\n3. has getters for all fields\nNoncompliant code example\n```java\nfinal class Person { // Noncompliant\n  private final String name;\n  private final int age;\n\n  public Person(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  public String getName() {...}\n\n  public int getAge() {...}\n\n  @Override\n  public boolean equals(Object o) {...}\n\n  @Override\n  public int hashCode() {...}\n\n  @Override\n  public String toString() {...}\n}\n```\nCompliant solution\n```java\nrecord Person(String name, int age) { }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6205": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Switch arrow labels should not use redundant keywords\nDescription: Why is this an issue?\nIn Switch Expressions, an arrow label consisting of a block with a single\nyield\ncan be simplified to directly return the value,\nresulting in cleaner code.\nSimilarly, for Switch Statements and arrow labels, a\nbreak\nin a block is always redundant and should not be used. Furthermore, if the\nresulting block contains only one statement, the curly braces of that block can also be omitted.\nThis rule reports an issue when a case of a Switch Expression contains a block with a single\nyield\nor when a Switch Statement contains\na block with a\nbreak\n.\nNoncompliant code example\n```java\nint i = switch (mode) {\n  case \"a\" -> {        // Noncompliant: Remove the redundant block and yield.\n    yield 1;\n  }\n  default -> {         // Noncompliant: Remove the redundant block and yield.\n    yield 2;\n  }\n};\n\nswitch (mode) {\n  case \"a\" -> {        // Noncompliant: Remove the redundant block and break.\n    result = 1;\n    break;\n  }\n  default -> {         // Noncompliant: Remove the redundant break.\n    doSomethingElse();\n    result = 2;\n    break;\n  }\n}\n```\nCompliant solution\n```java\nint i = switch (mode) {\n  case \"a\" -> 1;\n  default -> 2;\n};\n\nswitch (mode) {\n  case \"a\" -> result = 1;\n  default -> {\n   doSomethingElse();\n   result = 2;\n }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6204": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream.toList()\" method should be used instead of \"collectors\" when unmodifiable list needed\nDescription: Why is this an issue?\nIn Java 8\nStreams\nwere introduced to support chaining of operations over collections in a functional style. The most common way to\nsave a result of such chains is to save them to some collection (usually\nList\n). To do so there is a terminal method\ncollect\nthat can be used with a library of\nCollectors\n. The key problem is that\n.collect(Collectors.toList())\nactually returns a\nmutable kind of\nList\nwhile in the majority of cases unmodifiable lists are preferred. In Java 10 a new collector appeared to return an\nunmodifiable list:\ntoUnmodifiableList()\n. This does the trick but results in verbose code. Since Java 16 there is now a better variant to\nproduce an unmodifiable list directly from a stream:\nStream.toList()\n.\nThis rule raises an issue when \"collect\" is used to create a list from a stream.\nNoncompliant code example\n```java\nList<String> list1 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // Noncompliant\n\nList<String> list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toUnmodifiableList()); // Noncompliant\n```\nCompliant solution\n```java\nList<String> list1 = Stream.of(\"A\", \"B\", \"C\").toList(); // Compliant\n\nList<String> list2 = Stream.of(\"A\", \"B\", \"C\")\n                           .collect(Collectors.toList()); // Compliant, the list2 needs to be mutable\n\nlist2.add(\"X\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6203": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Text blocks should not be used in complex expressions\nDescription: Why is this an issue?\nIn Java 15 Text Blocks are official and can be used just like an ordinary String. However, when they are used to represent a big chunk of text,\nthey should not be used directly in complex expressions, as it decreases the readability. In this case, it is better to extract the text block into a\nvariable or a field.\nThis rule reports an issue when a text block longer than a number of lines given as a parameter is directly used within a lambda expression.\nNoncompliant code example\n```java\nlistOfString.stream()\n  .map(str -> !\"\"\"\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n      <parent>\n        <groupId>com.mycompany.app</groupId>\n        <artifactId>my-app</artifactId>\n        <version>1</version>\n      </parent>\n\n      <groupId>com.mycompany.app</groupId>\n      <artifactId>my-module</artifactId>\n      <version>1</version>\n    </project>\n    \"\"\".equals(str));\n```\nCompliant solution\n```java\nString myTextBlock = \"\"\"\n    <project>\n      <modelVersion>4.0.0</modelVersion>\n      <parent>\n        <groupId>com.mycompany.app</groupId>\n        <artifactId>my-app</artifactId>\n        <version>1</version>\n      </parent>\n\n      <groupId>com.mycompany.app</groupId>\n      <artifactId>my-module</artifactId>\n      <version>1</version>\n    </project>\n    \"\"\";\n\nlistOfString.stream()\n  .map(str -> !myTextBlock.equals(str));\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6202": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Operator \"instanceof\" should be used instead of \"A.class.isInstance()\"\nDescription: Why is this an issue?\nThe\ninstanceof\nconstruction is a preferred way to check whether a variable can be cast to some type statically because a compile-time\nerror will occur in case of incompatible types. The method\nisInstance()\nfrom\njava.lang.Class\nworks differently and does type check at runtime only, incompatible types will therefore not be detected early in the development, potentially\nresulting in dead code. The\nisInstance()\nmethod should only be used in dynamic cases when the\ninstanceof\noperator can\u2019t be\nused.\nThis rule raises an issue when\nisInstance()\nis used and could be replaced with an\ninstanceof\ncheck.\nNoncompliant code example\n```java\nint f(Object o) {\n\u00a0 if (String.class.isInstance(o)) {\u00a0 // Noncompliant\n\u00a0 \u00a0 return 42;\n\u00a0 }\n\u00a0 return 0;\n}\n\nint f(Number n) {\n\u00a0 if (String.class.isInstance(n)) {\u00a0 // Noncompliant\n\u00a0 \u00a0 return 42;\n\u00a0 }\n\u00a0 return 0;\n}\n```\nCompliant solution\n```java\nint f(Object o) {\n\u00a0 if (o instanceof String) {\u00a0 // Compliant\n\u00a0 \u00a0 return 42;\n\u00a0 }\n\u00a0 return 0;\n}\n\nint f(Number n) {\n\u00a0 if (n instanceof String) {\u00a0 // Compile-time error\n\u00a0 \u00a0 return 42;\n\u00a0 }\n\u00a0 return 0;\n}\n\nboolean fun(Object o, String c) throws ClassNotFoundException\n{\n  return Class.forName(c).isInstance(o); // Compliant, can't use instanceof operator here\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6201": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Pattern Matching for \"instanceof\" operator should be used instead of simple \"instanceof\" + cast\nDescription: Why is this an issue?\nIn Java 16, the feature \"Pattern matching for instanceof\" is finalized and can\u00a0be used in production. Previously developers needed to do 3\noperations in order to do this: check the variable type, cast it and assign the casted value to the new variable. This approach is quite verbose and\ncan be replaced with pattern matching for\ninstanceof\n, doing these 3 actions (check, cast and assign) in one expression.\nThis rule raises an issue when an\ninstanceof\ncheck followed by a cast and an assignment could be replaced by pattern matching.\nNoncompliant code example\n```java\nint f(Object o) {\n  if (o instanceof String) {\u00a0 // Noncompliant\n    String string = (String) o;\n    return string.length();\n  }\n  return 0;\n}\n```\nCompliant solution\n```java\nint f(Object o) {\n\u00a0 if (o instanceof String string) {\u00a0 // Compliant\n\u00a0 \u00a0 return string.length();\n\u00a0 }\n\u00a0 return 0;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6126": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: String multiline concatenation should be replaced with Text Blocks\nDescription: Why is this an issue?\nIn Java 15 Text Blocks are now official and can be used. The most common pattern for multiline strings in Java < 15 was to write String\nconcatenation. Now it\u2019s possible to do it in a more natural way using Text Blocks.\nNoncompliant code example\n```java\nString textBlock =\n               \"<html>\\n\" +\n               \"    <body>\\n\" +\n               \"        <tag>\\n\" +\n               \"        </tag>\\n\" +\n               \"    </body>\\n\" +\n               \"</html>\";\n```\nCompliant solution\n```java\nString textBlock = \"\"\"\n        <html>\n            <body>\n                <tag>\n                </tag>\n            </body>\n        </html>\"\"\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6068": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Call to Mockito method \"verify\", \"when\" or \"given\" should be simplified\nDescription: Why is this an issue?\nMockito provides\nargument matchers\nfor flexibly stubbing or verifying method calls.\nMockito.verify()\n,\nMockito.when()\n,\nStubber.when()\nand\nBDDMockito.given()\neach have overloads\nwith and without argument matchers.\nHowever, the default matching behavior (i.e. without argument matchers) uses\nequals()\n. If only the matcher\norg.mockito.ArgumentMatchers.eq()\nis used, the call is equivalent to the call without matchers, i.e. the\neq()\nis not\nnecessary and can be omitted. The resulting code is shorter and easier to read.\nNoncompliant code example\n```java\n@Test\npublic void myTest() {\n  given(foo.bar(eq(v1), eq(v2), eq(v3))).willReturn(null);   // Noncompliant\n  when(foo.baz(eq(v4), eq(v5))).thenReturn(\"foo\");   // Noncompliant\n  doThrow(new RuntimeException()).when(foo).quux(eq(42));    // Noncompliant\n  verify(foo).bar(eq(v1), eq(v2), eq(v3));   // Noncompliant\n}\n```\nCompliant solution\n```java\n@Test\npublic void myTest() {\n  given(foo.bar(v1, v2, v3)).willReturn(null);\n  when(foo.baz(v4, v5)).thenReturn(\"foo\");\n  doThrow(new RuntimeException()).when(foo).quux(42);\n  verify(foo).bar(v1, v2, v3);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6035": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Single-character alternations in regular expressions should be replaced with character classes\nDescription: Why is this an issue?\nWhen an alternation contains multiple alternatives that consist of a single character, it can be rewritten as a character class. This should be\npreferred because it is more efficient and can even help prevent stack overflows when used inside a repetition (see rule {rule:java:S5998}).\nNoncompliant code example\n```java\nPattern.compile(\"a|b|c\"); // Noncompliant\n```\nCompliant solution\n```java\nPattern.compile(\"[abc]\");\n// or\nPattern.compile(\"[a-c]\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-6019": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Reluctant quantifiers in regular expressions should be followed by an expression that can't match the empty string\nDescription: Why is this an issue?\nWhen a reluctant quantifier (such as\n*?\nor\n+?\n) is followed by a pattern that can match the empty string or directly by\nthe end of the regex, it will always match the empty string when used with methods that find partial matches (such as\nfind\n,\nreplaceAll\n,\nsplit\netc.).\nSimilarly, when used with methods that find full matches, a reluctant quantifier that\u2019s followed directly by the end of the regex (or a pattern\nthat always matches the empty string, such as\n()\n) behaves indistinguishably from a greedy quantifier while being less efficient.\nThis is likely a sign that the regex does not work as intended.\nNoncompliant code example\n```java\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end)?\", \"x\"); // Noncompliant. In contrast to what one would expect, the result is not \"xx\".\nstr.matches(\"\\\\d*?\"); // Noncompliant. Matches the same as \"\\d*\", but will backtrack in every position.\n```\nCompliant solution\n```java\n\"start123endstart456\".replaceAll(\"start\\\\w*?(end|$)\", \"x\"); // Result is \"xx\".\nstr.matches(\"\\\\d*\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5993": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Constructors of an \"abstract\" class should not be declared \"public\"\nDescription: Why is this an issue?\nAbstract classes should not have public constructors. Constructors of abstract classes can only be called in constructors of their subclasses. So\nthere is no point in making them public. The\nprotected\nmodifier should be enough.\nNoncompliant code example\n```java\npublic abstract class AbstractClass1 {\n    public AbstractClass1 () { // Noncompliant, has public modifier\n        // do something here\n    }\n}\n```\nCompliant solution\n```java\npublic abstract class AbstractClass2 {\n    protected AbstractClass2 () {\n        // do something here\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5977": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tests should use fixed data instead of randomized data\nDescription: Why is this an issue?\nRandomness in test code, whether introduced intentionally to cover multiple scenarios or unintentionally through non-deterministic library\nfunctions, undermines the principles of effective testing. In most cases, randomness leads to problems, resulting in code that is unreliable and\ndifficult to debug. Consequently, deterministic and reproducible tests are preferred, primarily for the following reasons:\n1. When a test fails, the ability to reproduce the conditions that led to the failure is crucial for effective debugging. Randomness can make it\n  difficult or even impossible to pinpoint the root cause, as subsequent runs may not exhibit the same failure.\n2. Being able to replay a scenario allows us to easily compare logs between different test runs.\n3. Determinism gives us confidence that a bug is fixed when it no longer appears in tests. If they behave randomly, a passing test after a fix\n  might be coincidental due to a specific random input, rather than a genuine resolution of the underlying problem.\n4. Flaky tests, which pass or fail intermittently without any code changes, are a significant problem for CI pipelines (continuous integration).\n  They erode confidence in the CI system, lead to unnecessary investigations and reruns, and ultimately slow down the development and release process.\n  A stable CI pipeline relies on deterministic test outcomes.\nThis rule raises an issue when\nnew Random()\nor\nUUID.randomUUID()\nare called in test code.\nHow to fix it\n1. When a test uses random numbers to generate inputs, an easy fix is to replace those random inputs with pseudo-random values generated from a\n  known seed. By initializing a pseudo-random number generator with a fixed seed, tests can generate sequences of seemingly random data that are\n  reproducible across different test runs.\n2. When randomness occurs due to the use of a library function, the solution is to replace the call with a constant. For example, rather than\n  generating a UUID at random, one should use a fixed value.\nNoncompliant code example\n```java\nint userAge = new Random().nextInt(42);  // Noncompliant\nUUID userID = UUID.randomUUID(); // Noncompliant\n```\nCompliant solution\n```java\nstatic final int SEED = 0x533d;\nint userAge = new Random(SEED).nextInt(42);\nUUID userID = UUID.fromString(\"00000000-000-0000-0000-000000000001\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5976": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Similar tests should be grouped in a single Parameterized test\nDescription: Why is this an issue?\nWhen multiple tests differ only by a few hardcoded values they should be refactored as a single \"parameterized\" test. This reduces the chances of\nadding a bug and makes them more readable. Parameterized tests exist in most test frameworks (JUnit, TestNG, etc\u2026\u200b).\nThe right balance needs of course to be found. There is no point in factorizing test methods when the parameterized version is a lot more complex\nthan initial tests.\nThis rule raises an issue when at least 3 tests could be refactored as one parameterized test with less than 4 parameters. Only test methods which\nhave at least one duplicated statement are considered.\nNoncompliant code example\nwith JUnit 5\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.api.Test;\n\npublic class AppTest\n{\n    @Test\n    void test_not_null1() {  // Noncompliant. The 3 following tests differ only by one hardcoded number.\n      setupTax();\n      assertNotNull(getTax(1));\n    }\n\n    @Test\n    void test_not_null2() {\n      setupTax();\n      assertNotNull(getTax(2));\n    }\n\n    @Test\n    void test_not_nul3l() {\n      setupTax();\n      assertNotNull(getTax(3));\n    }\n\n    @Test\n    void testLevel1() {  // Noncompliant. The 3 following tests differ only by a few hardcoded numbers.\n        setLevel(1);\n        runGame();\n        assertEquals(playerHealth(), 100);\n    }\n\n    @Test\n    void testLevel2() {  // Similar test\n        setLevel(2);\n        runGame();\n        assertEquals(playerHealth(), 200);\n    }\n\n    @Test\n    void testLevel3() {  // Similar test\n        setLevel(3);\n        runGame();\n        assertEquals(playerHealth(), 300);\n    }\n}\n```\nCompliant solution\n```java\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\n\npublic class AppTest\n{\n\n   @ParameterizedTest\n   @ValueSource(ints = {1, 2, 3})\n   void test_not_null(int arg) {\n     setupTax();\n     assertNotNull(getTax(arg));\n   }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"1, 100\",\n        \"2, 200\",\n        \"3, 300\",\n    })\n    void testLevels(int level, int health) {\n        setLevel(level);\n        runGame();\n        assertEquals(playerHealth(), health);\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5973": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tests should be stable\nDescription: Why is this an issue?\nUnstable / flaky tests are tests which sometimes pass and sometimes fail, without any code change. Obviously, they slow down developments when\ndevelopers have to rerun failed tests. However, the real problem is that you can\u2019t completely trust these tests, they might fail for many different\nreasons and you don\u2019t know if any of them will happen in production.\nSome tools, such as TestNG, enable developers to automatically retry flaky tests. This might be acceptable as a temporary solution, but it should\neventually be fixed. The more flaky tests you add, the more chances there are for a bug to arrive in production.\nThis rule raises an issue when the annotation\norg.testng.annotations.Test\nis given a\nsuccessPercentage\nargument with a\nvalue lower than\n100\n.\nNoncompliant code example\n```java\nimport org.testng.annotations.Test;\n\npublic class PercentageTest {\n    @Test(successPercentage = 80, invocationCount = 10)  // Noncompliant. The test is allowed to fail 2 times.\n    public void flakyTest() {\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5970": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Spring's ModelAndViewAssert assertions should be used instead of other assertions\nDescription: Why is this an issue?\nThe Spring framework comes with dedicated classes to help writing better and simpler unit tests. In particular, when testing applications built on\ntop of Spring MVC, it is recommended to use Spring\u2019s\nModelAndViewAssert\nassertions class, instead of manually testing MVC\u2019s\nproperties.\nThis rule raises an issue when\u00a0Spring\u2019s\nModelAndViewAssert\nassertions should be used instead of manual testing.\nNoncompliant code example\n```java\nModelAndView mav = getMyModelAndView();\n\nAssert.assertEquals(\"register\", mav.getViewName());\nAssert.assertTrue((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertFalse((Boolean) mav.getModelMap().get(\"myAttribute\"));\nAssert.assertEquals(myObject, mav.getModelMap().get(\"myAttribute\"));\n```\nCompliant solution\n```java\nModelAndView mav = getMyModelAndView();\n\nModelAndViewAssert.assertViewName(mav, \"register\");\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.TRUE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", Boolean.FALSE);\nModelAndViewAssert.assertModelAttributeValue(mav, \"myAttribute\", myObject);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5969": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Mocking all non-private methods of a class should be avoided\nDescription: Why is this an issue?\nIf you end up mocking every non-private method of a class in order to write tests, it is a strong sign that your test became too complex, or that\nyou misunderstood the way you are supposed to use the mocking mechanism.\nYou should either refactor the test code into multiple units, or consider using the class itself, by either directly instantiating it, or creating\na new one inheriting from it, with the expected behavior.\nThis rule reports an issue when every member of a given class are mocked.\nNoncompliant code example\n```java\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClassMock = mock(MyClass.class); // Noncompliant\n  when(myClassMock.f()).thenReturn(1);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n```\nCompliant solution\n```java\n@Test\nvoid test_requiring_MyClass() {\n  MyClass myClass = new MyClassForTest();\n  //...\n}\n\nclass MyClassForTest extends MyClass {\n\n  @Override\n  int f() {\n    return 1;\n  }\n\n  @Override\n  int g() {\n    return 2;\n  }\n}\n```\nor\n```java\n@Test\nvoid test_requiring_f() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.f()).thenReturn(1);\n  //...\n}\n\n@Test\nvoid test_requiring_g() {\n  MyClass myClassMock = mock(MyClass.class);\n  when(myClassMock.g()).thenReturn(2);\n  //...\n}\n\nabstract class MyClass {\n  abstract int f();\n  abstract int g();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5961": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test methods should not contain too many assertions\nDescription: Why is this an issue?\nA common good practice is to write test methods targeting only one logical concept, that can only fail for one reason.\nWhile it might make sense to have more than one assertion to test one concept, having too many is a sign that a test became too complex and should\nbe refactored to multiples ones.\nThis rule will report any test method containing more than a given number of assertion.\nNoncompliant code example\nWith a parameter of 2.\n```java\n@Test\nvoid test() { // Refactor this method.\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n  assertEquals(3, g(1));\n}\n```\nCompliant solution\n```java\nvoid test_f() {\n  assertEquals(1, f(1));\n  assertEquals(2, f(2));\n}\nvoid test_g() {\n  assertEquals(3, g(1));\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5958": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: AssertJ \"assertThatThrownBy\" should not be used alone\nDescription: Why is this an issue?\nUnlike similar AssertJ methods testing exceptions (\nassertThatCode()\n,\nassertThatExceptionOfType()\n, \u2026\u200b), the\nassertThatThrownBy()\nmethod can be used alone, failing if the code did not raise any exception.\nStill, only testing that an exception was raised is not enough to guarantee that it was the expected one, and you should test the exception type or\ncontent further. In addition, it will make explicit what you are expecting, without relying on side-effects.\nThis rule raises an issue when\nassertThatThrownBy\nis used, without testing the exception further.\nNoncompliant code example\n```java\nassertThatThrownBy(() -> shouldThrow()); // Noncompliant, is it really the exception you expected?\n```\nCompliant solution\n```java\nassertThatThrownBy(() -> shouldThrow()).isInstanceOf(IOException.class);\n//or\nassertThatThrownBy(() -> shouldThrow()).hasMessage(\"My exception\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5869": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Character classes in regular expressions should not contain the same character twice\nDescription: Why is this an issue?\nCharacter classes in regular expressions are a convenient way to match one of several possible characters by listing the allowed characters or\nranges of characters. If the same character is listed twice in the same character class or if the character class contains overlapping ranges, this\nhas no effect.\nThus duplicate characters in a character class are either a simple oversight or a sign that a range in the character class matches more than is\nintended or that the author misunderstood how character classes work and wanted to match more than one character. A common example of the latter\nmistake is trying to use a range like\n[0-99]\nto match numbers of up to two digits, when in fact it is equivalent to\n[0-9]\n.\nAnother common cause is forgetting to escape the\n-\ncharacter, creating an unintended range that overlaps with other characters in the\ncharacter class.\nNoncompliant code example\n```java\nstr.matches(\"[0-99]\") // Noncompliant, this won't actually match strings with two digits\nstr.matches(\"[0-9.-_]\") // Noncompliant, .-_ is a range that already contains 0-9 (as well as various other characters such as capital letters)\n```\nCompliant solution\n```java\nstr.matches(\"[0-9]{1,2}\")\nstr.matches(\"[0-9.\\\\-_]\")\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5867": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unicode-aware versions of character classes should be preferred\nDescription: Why is this an issue?\nWhen using POSIX classes like\n\\p{Alpha}\nwithout the\nUNICODE_CHARACTER_CLASS\nflag or when using hard-coded character\nclasses like\n\"[a-zA-Z]\"\n, letters outside of the ASCII range, such as umlauts, accented letters or letter from non-Latin languages, won\u2019t\nbe matched. This may cause code to incorrectly handle input containing such letters.\nTo correctly handle non-ASCII input, it is recommended to use Unicode classes like\n\\p{IsAlphabetic}\n. When using POSIX classes, Unicode\nsupport should be enabled by either passing\nPattern.UNICODE_CHARACTER_CLASS\nas a flag to\nPattern.compile\nor by using\n(?U)\ninside the regex.\nNoncompliant code example\n```java\nPattern.compile(\"[a-zA-Z]\");\nPattern.compile(\"\\\\p{Alpha}\");\n```\nCompliant solution\n```java\nPattern.compile(\"\\\\p{IsAlphabetic}\"); // matches all letters from all languages\nPattern.compile(\"\\\\p{IsLatin}\"); // matches latin letters, including umlauts and other non-ASCII variations\nPattern.compile(\"\\\\p{Alpha}\", Pattern.UNICODE_CHARACTER_CLASS);\nPattern.compile(\"(?U)\\\\p{Alpha}\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5860": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Names of regular expressions named groups should be used\nDescription: Why is this an issue?\nWhy use named groups only to never use any of them later on in the code?\nThis rule raises issues every time named groups are:\n1. defined but never called anywhere in the code through their name;\n2. defined but called elsewhere in the code by their number instead;\n3. referenced while not defined.\nNoncompliant code example\n```java\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?<month>[0-9]{2})/(?<year>[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(1), dateMatcher.group(2));  // Noncompliant - numbers instead of names of groups are used\n  checkValidity(dateMatcher.group(\"day\")); // Noncompliant - there is no group called \"day\"\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?<player1>[0-9]+):(?<player2>[0-9]+)\"); // Noncompliant - named groups are never used\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n```\nCompliant solution\n```java\nString date = \"01/02\";\n\nPattern datePattern = Pattern.compile(\"(?<month>[0-9]{2})/(?<year>[0-9]{2})\");\nMatcher dateMatcher = datePattern.matcher(date);\n\nif (dateMatcher.matches()) {\n  checkValidity(dateMatcher.group(\"month\"), dateMatcher.group(\"year\"));\n}\n\n// ...\n\nString score = \"14:1\";\n\nPattern scorePattern = Pattern.compile(\"(?<player1>[0-9]+):(?<player2>[0-9]+)\");\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(scoreMatcher.group(\"player1\"));\n  checkScore(scoreMatcher.group(\"player2\"));\n}\n```\nOr, using dedicated variables instead of group names:\n```java\nString score = \"14:1\";\n\nString player = \"([0-9]+)\";\nString gameScore = player + \":\" + player;\n\nPattern scorePattern = Pattern.compile(gameScore);\nMatcher scoreMatcher = scorePattern.matcher(score);\n\nif (scoreMatcher.matches()) {\n  checkScore(score);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5857": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Character classes should be preferred over reluctant quantifiers in regular expressions\nDescription: Why is this an issue?\nUsing reluctant quantifiers (also known as lazy or non-greedy quantifiers) in patterns can often lead to needless backtracking, making the regex\nneedlessly inefficient and potentially vulnerable to\ncatastrophic backtracking\n.\nParticularly when using\n.*?\nor\n.+?\nto match anything up to some terminating character, it is usually a better idea to\ninstead use a greedily or possessively quantified negated character class containing the terminating character. For example\n<.+?>\nshould be replaced with\n<[^>]++>\n.\nNoncompliant code example\n```java\n<.+?>\n\".*?\"\n```\nCompliant solution\n```java\n<[^>]++>\n\"[^\"]*+\"\n```\nor\n```java\n<[^>]+>\n\"[^\"]*\"\n```\nExceptions\nThis rule only applies in cases where the reluctant quantifier can easily be replaced with a negated character class. That means the repetition has\nto be terminated by a single character or character class. Patterns such as the following, where the alternatives without reluctant quantifiers are\nmore complicated, are therefore not subject to this rule:\n```java\n<!--.*?-->\n/\\*.*?\\*/\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5854": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regexes containing characters subject to normalization should use the CANON_EQ flag\nDescription: Why is this an issue?\nCharacters like\n'e\u0301'\ncan be expressed either as a single code point or as a cluster of the letter\n'e'\nand a combining\naccent mark. Without the\nCANON_EQ\nflag, a regex will only match a string in which the characters are expressed in the same way.\nNoncompliant code example\n```java\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"\u00e9|\u00eb|\u00e8\"); // Noncompliant\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // print '\u00e8'\n```\nCompliant solution\n```java\nString s = \"e\\u0300\";\nPattern p = Pattern.compile(\"\u00e9|\u00eb|\u00e8\", Pattern.CANON_EQ);\nSystem.out.println(p.matcher(s).replaceAll(\"e\")); // print 'e'\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5853": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Consecutive AssertJ \"assertThat\" statements should be chained\nDescription: Why is this an issue?\nAssertJ assertions methods targeting the same object can be chained instead of using multiple\nassertThat\n. It avoids duplication and\nincreases the clarity of the code.\nThis rule raises an issue when multiples\nassertThat\ntarget the same tested value.\nNoncompliant code example\n```java\nassertThat(someList).hasSize(3);\nassertThat(someList).contains(\"something\");\n```\nCompliant solution\n```java\nassertThat(someList)\n  .hasSize(3)\n  .contains(\"something\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5846": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Empty lines should not be tested with regex MULTILINE flag\nDescription: Why is this an issue?\nOne way to test for empty lines is to use the regex\n\"^$\"\n, which can be extremely handy when filtering out empty lines from collections\nof Strings, for instance. With regard to this, the Javadoc for\nPattern (Line Terminators)\nstates the\nfollowing:\nBy default, the regular expressions ^ and\n$\nignore line terminators and only match at the beginning and the end, respectively, of\n  the entire input sequence. If\nMULTILINE\nmode is activated then ^ matches at the beginning of input and after any line terminator\nexcept at the end of input\n. When in\nMULTILINE\nmode\n$\nmatches just before a line terminator or the end of\n  the input sequence.\nAs emphasized, ^ is not going to match at the end of an input, and the end of the input is necessarily included in the empty string, which might\nlead to completely missing empty lines, while it would be the initial reason for using such regex.\nTherefore, when searching for empty lines using a multi-line regular expression, you should also check whether the string is empty.\nThis rule is raising an issue every time a pattern that can match the empty string is used with\nMULTILINE\nflag and without calling\nisEmpty()\non the string.\nNoncompliant code example\n```java\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE); // Noncompliant\n\n// Alternatively\nstatic final Pattern p = Pattern.compile(\"(?m)^$\"); // Noncompliant\n\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // correctly prints 'true'\nSystem.out.println(containsEmptyLines(\"\")); // incorrectly prints 'false'\n```\nCompliant solution\n```java\nstatic final Pattern p = Pattern.compile(\"^$\", Pattern.MULTILINE);\n\nboolean containsEmptyLines(String str) {\n    return p.matcher(str).find() || str.isEmpty();\n}\n\n// ...\nSystem.out.println(containsEmptyLines(\"a\\n\\nb\")); // correctly prints 'true'\nSystem.out.println(containsEmptyLines(\"\")); // also correctly prints 'true'\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5843": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regular expressions should not be too complicated\nDescription: Why is this an issue?\nOverly complicated regular expressions are hard to read and to maintain and can easily cause hard-to-find bugs. If a regex is too complicated, you\nshould consider replacing it or parts of it with regular code or splitting it apart into multiple patterns at least.\nThe complexity of a regular expression is determined as follows:\nEach of the following operators increases the complexity by an amount equal to the current nesting level and also increases the current nesting\nlevel by one for its arguments:\n1. |- when multiple|operators are used together, the subsequent ones only increase the complexity by 1\n2. &&(inside character classes) - when multiple&&operators are used together, the subsequent ones\n  only increase the complexity by 1\n3. Quantifiers (*,+,?,{n,m},{n,}or{n})\n4. Non-capturing groups that set flags (such as(?i:some_pattern)or(?i)some_pattern)\n5. Lookahead and lookbehind assertions\nAdditionally, each use of the following features increase the complexity by 1 regardless of nesting:\n1. character classes\n2. back references\nIf a regular expression is split among multiple variables, the complexity is calculated for each variable individually, not for the whole regular\nexpression. If a regular expression is split over multiple lines, each line is treated individually if it is accompanied by a comment (either a Java\ncomment or a comment within the regular expression), otherwise the regular expression is analyzed as a whole.\nNoncompliant code example\n```java\nif (dateString.matches(\"^(?:(?:31(\\\\/|-|\\\\.)(?:0?[13578]|1[02]))\\\\1|(?:(?:29|30)(\\\\/|-|\\\\.)(?:0?[13-9]|1[0-2])\\\\2))(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$|^(?:29(\\\\/|-|\\\\.)0?2\\\\3(?:(?:(?:1[6-9]|[2-9]\\\\d)?(?:0[48]|[2468][048]|[13579][26])|(?:(?:16|[2468][048]|[3579][26])00))))$|^(?:0?[1-9]|1\\\\d|2[0-8])(\\\\/|-|\\\\.)(?:(?:0?[1-9])|(?:1[0-2]))\\\\4(?:(?:1[6-9]|[2-9]\\\\d)?\\\\d{2})$\")) {\n    handleDate(dateString);\n}\n```\nCompliant solution\n```java\nif (dateString.matches(\"^\\\\d{1,2}([-/.])\\\\d{1,2}\\\\1\\\\d{1,4}$\")) {\n    String dateParts[] = dateString.split(\"[-/.]\");\n    int day = Integer.parseInt(dateParts[0]);\n    int month = Integer.parseInt(dateParts[1]);\n    int year = Integer.parseInt(dateParts[2]);\n    // Put logic to validate and process the date based on its integer parts here\n}\n```\nExceptions\nRegular expressions are only analyzed if all parts of the regular expression are either string literals, effectively final local variables or\nstatic final\nfields, all of which can be combined using the '\n+\n' operator.\nWhen a regular expression is split among multiple variables or commented lines, each part is only analyzed if it is syntactically valid by\nitself.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5838": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Chained AssertJ assertions should be simplified to the corresponding dedicated assertion\nDescription: Why is this an issue?\nAssertJ contains many assertions methods specific to common types. Both versions will test the same things, but the dedicated one will provide a\nbetter error message, simplifying the debugging process.\nThis rule reports an issue when an assertion can be simplified to a dedicated one.\nThe array below gives a non-exhaustive list of assertion reported by the rule. Code behaving similarly, or with a negation will also be\nreported.\nOriginal\nDedicated\nRelated to Object\nassertThat(getObject()).isEqualTo(null)\nassertThat(getObject()).isNull()\nassertThat(getBoolean()).isEqualTo(true)\nassertThat(getBoolean()).isTrue()\nassertThat(getBoolean()).isEqualTo(false)\nassertThat(getBoolean()).isFalse()\nassertThat(x.equals(y)).isTrue()\nassertThat(x).isEqualTo(y)\nassertThat(x == y).isTrue()\nassertThat(x).isSameAs(y)\nassertThat(x == null).isTrue()\nassertThat(x).isNull()\nassertThat(x.toString()).isEqualTo(y)\nassertThat(x).hasToString(y)\nassertThat(x.hashCode()).isEqualTo(y.hashCode())\nassertThat(x).hasSameHashCodeAs(y)\nassertThat(getObject() instanceof MyClass).isTrue()\nassertThat(getObject()).isInstanceOf(MyClass.class)\nRelated to\nComparable\nassertThat(x.compareTo(y)).isZero()\nassertThat(x).isEqualByComparingTo(y)\nassertThat(x >= y).isTrue()\nassertThat(x).isGreaterThanOrEqualTo(y)\nassertThat(x > y).isTrue()\nassertThat(x).isGreaterThan(y)\nassertThat(x <= y).isTrue()\nassertThat(x).isLessThanOrEqualTo(y)\nassertThat(x < y).isTrue()\nassertThat(x).isLessThan(y)\nRelated to\nString\nassertThat(getString().isEmpty()).isTrue()\nassertThat(getString()).isEmpty()\nassertThat(getString()).hasSize(0)\nassertThat(getString()).isEmpty()\nassertThat(getString().equals(expected)).isTrue()\nassertThat(getString()).isEqualTo(expected)\nassertThat(getString().equalsIgnoreCase(expected)).isTrue()\nassertThat(getString()).isEqualToIgnoringCase(expected)\nassertThat(getString().contains(expected)).isTrue()\nassertThat(getString()).contains(expected)\nassertThat(getString().startsWith(expected)).isTrue()\nassertThat(getString()).startsWith(expected)\nassertThat(getString().endsWith(expected)).isTrue()\nassertThat(getString()).endsWith(expected)\nassertThat(getString().matches(expected)).isTrue()\nassertThat(getString()).matches(expected)\nassertThat(getString().trim()).isEmpty()\nassertThat(getString()).isBlank()\nassertThat(getString().length()).isEqualTo(length)\nassertThat(getString()).hasSize(length)\nassertThat(getString().length()).hasSize(expected.length())\nassertThat(getString()).hasSameSizeAs(expected)\nRelated to\nFile\nassertThat(getFile()).hasSize(0)\nassertThat(getFile()).isEmpty()\nassertThat(getFile().length()).isZero()\nassertThat(getFile()).isEmpty()\nassertThat(getFile().length()).isEqualTo(length)\nassertThat(getFile()).hasSize(length)\nassertThat(getFile().canRead()).isTrue()\nassertThat(getFile()).canRead()\nassertThat(getFile().canWrite()).isTrue()\nassertThat(getFile()).canWrite()\nassertThat(getFile().exists()).isTrue()\nassertThat(getFile()).exists()\nassertThat(getFile().getName()).isEqualTo(name)\nassertThat(getFile()).hasName(name)\nassertThat(getFile().getParent()).isEqualTo(pathname)\nassertThat(getFile()).hasParent(pathname)\nassertThat(getFile().getParentFile()).isNull()\nassertThat(getFile()).hasNoParent()\nassertThat(getFile().isAbsolute()).isTrue()\nassertThat(getFile()).isAbsolute()\nassertThat(getFile().isAbsolute()).isFalse()\nassertThat(getFile()).isRelative()\nassertThat(getFile().isDirectory()).isTrue()\nassertThat(getFile()).isDirectory()\nassertThat(getFile().isFile()).isTrue()\nassertThat(getFile()).isFile()\nassertThat(getFile().list()).isEmpty()\nassertThat(getFile()).isEmptyDirectory()\nRelated to\nPath\nassertThat(getPath().startsWith(path)).isTrue()\nassertThat(getPath()).startsWithRaw(path)\nassertThat(getPath().endsWith(path)).isTrue()\nassertThat(getPath()).endsWithRaw(path)\nassertThat(getPath().getParent()).isEqualTo(name)\nassertThat(getPath()).hasParentRaw(name)\nassertThat(getPath().getParent()).isNull()\nassertThat(getPath()).hasNoParentRaw()\nassertThat(getPath().isAbsolute()).isTrue()\nassertThat(getPath()).isAbsolute()\nassertThat(getPath().isAbsolute()).isFalse()\nassertThat(getPath()).isRelative()\nRelated to\nArray\nassertThat(getArray().length).isZero()\nassertThat(getArray()).isEmpty()\nassertThat(getArray().length).isEqualTo(length)\nassertThat(getArray()).hasSize(length)\nassertThat(getArray().length).isEqualTo(anotherArray.length)\nassertThat(getArray()).hasSameSizeAs(anotherArray)\nassertThat(getArray().length).isLessThanOrEqualTo(expression)\nassertThat(getArray()).hasSizeLessThanOrEqualTo(expression)\nassertThat(getArray().length).isLessThan(expression)\nassertThat(getArray()).hasSizeLessThan(expression)\nassertThat(getArray().length).isGreaterThan(expression)\nassertThat(getArray()).hasSizeGreaterThan(expression)\nassertThat(getArray().length).isGreaterThanOrEqualTo(expression)\nassertThat(getArray()).hasSizeGreaterThanOrEqualTo(expression)\nRelated to\nCollection\nassertThat(getCollection().isEmpty()).isTrue()\nassertThat(getCollection()).isEmpty()\nassertThat(getCollection().size()).isZero()\nassertThat(getCollection()).isEmpty()\nassertThat(getCollection().contains(something)).isTrue()\nassertThat(getCollection()).contains(something)\nassertThat(getCollection().containsAll(otherCollection)).isTrue()\nassertThat(getCollection()).containsAll(otherCollection)\nRelated to\nMap\nassertThat(getMap().size()).isEqualTo(otherMap().size()\nassertThat(getMap()).hasSameSizeAs(otherMap())\nassertThat(getMap().containsKey(key)).isTrue()\nassertThat(getMap()).containsKey(key)\nassertThat(getMap().keySet()).contains(key)\nassertThat(getMap()).containsKey(key)\nassertThat(getMap().keySet()).containsOnlyKey(key)\nassertThat(getMap()).containsOnlyKey(key)\nassertThat(getMap().containsValue(value)).isTrue()\nassertThat(getMap()).containsValue(value)\nassertThat(getMap().values()).contains(value)\nassertThat(getMap()).containsValue(value)\nassertThat(getMap().get(key)).isEqualTo(value)\nassertThat(getMap()).containsEntry(key, value)\nRelated to\nOptional\nassertThat(getOptional().isPresent()).isTrue()\nassertThat(getOptional()).isPresent()\nassertThat(getOptional().get()).isEqualTo(something)\nassertThat(getOptional()).contains(something)\nassertThat(getOptional().get()).isSameAs(something)\nassertThat(getOptional()).containsSame(something)\nNoncompliant code example\n```java\nassertThat(getObject()).isEqualTo(null); // Noncompliant\nassertThat(getObject()).isNotEqualTo(null); // Noncompliant - not listed above but also supported\n\nassertThat(getString().trim()).isEmpty();\nassertThat(getFile().canRead()).isTrue();\nassertThat(getPath().getParent()).isNull();\n```\nCompliant solution\n```java\nassertThat(getObject()).isNull();\nassertThat(getObject()).isNotNull();\n\nassertThat(getString()).isBlank();\nassertThat(getFile()).canRead();\nassertThat(getPath()).hasNoParentRaw();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5826": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods setUp() and tearDown() should be correctly annotated starting with JUnit4\nDescription: Why is this an issue?\nThe\nsetUp()\nand\ntearDown()\nmethods (initially introduced with JUnit3 to execute a block of code before and after each\ntest) need to be correctly annotated with the equivalent annotation in order to preserve the same behavior when migrating from JUnit3 to JUnit4 or\nJUnit5.\nThis rule consequently raise issues on\nsetUp()\nand\ntearDown()\nmethods which are not annotated in test classes.\nNoncompliant code example\n1. JUnit4:\n```java\npublic void setUp() { ... } // Noncompliant; should be annotated with @Before\npublic void tearDown() { ... }  // Noncompliant; should be annotated with @After\n```\n1. JUnit5:\n```java\npublic void setUp() { ... } // Noncompliant; should be annotated with @BeforeEach\npublic void tearDown() { ... }  // Noncompliant; should be annotated with @AfterEach\n```\nCompliant solution\n1. JUnit4:\n```java\n@Before\npublic void setUp() { ... }\n\n@After\npublic void tearDown() { ... }\n```\n1. JUnit5:\n```java\n@BeforeEach\nvoid setUp() { ... }\n\n@AfterEach\nvoid tearDown() { ... }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5803": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class members annotated with \"@VisibleForTesting\" should not be accessed from production code\nDescription: Why is this an issue?\n@VisibleForTesting can be used to mark methods, fields and classes whose visibility restrictions have been relaxed more than necessary for the API\nto allow for easier unit testing.\nAccess to such methods, fields and classes only possible thanks to this relaxed visibility is fine for test code, but it should be avoided in\nproduction code. In production code these methods should be treated as if they are private.\nSupported framework:\n1. Guava:com.google.common.annotations.VisibleForTesting\n2. AssertJ:org.assertj.core.util.VisibleForTesting\n3. Android:androidx.annotation.VisibleForTesting\n4. Apache Flink:org.apache.flink.annotation.VisibleForTesting\nor any other annotation named\nVisibleForTesting\nNoncompliant code example\n```java\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/main/java/Service.java */\n\nnew MyObject().foo; // Noncompliant, foo is accessed from production code\n```\nCompliant solution\n```java\n/** src/main/java/MyObject.java */\n\n@VisibleForTesting String foo;\n\n/** src/test/java/MyObjectTest.java */\n\nnew MyObject().foo; // Compliant, foo is accessed from test code\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5793": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Migrate your tests from JUnit4 to the new JUnit5 annotations\nDescription: Why is this an issue?\nAs mentioned in JUnit5 documentation, it is possible to integrate JUnit4 with JUnit5:\nJUnit provides a gentle migration path via a JUnit Vintage test engine which allows existing tests based on JUnit 3 and JUnit 4 to be executed\n  using the JUnit Platform infrastructure. Since all classes and annotations specific to JUnit Jupiter reside under a new org.junit.jupiter base\n  package, having both JUnit 4 and JUnit Jupiter in the classpath does not lead to any conflicts.\nHowever, maintaining both systems is a temporary solution. This rule flags all the annotations from JUnit4 which would need to be migrated to\nJUnit5, hence helping migration of a project.\nHere is the list of JUnit4 annotations tracked by the rule, with their corresponding annotations in JUnit5:\nJUnit4\nJUnit5\norg.junit.Test\norg.junit.jupiter.api.Test\norg.junit.Before\norg.junit.jupiter.api.BeforeEach\norg.junit.After\norg.junit.jupiter.api.AfterEach\norg.junit.BeforeClass\norg.junit.jupiter.api.BeforeAll\norg.junit.AfterClass\norg.junit.jupiter.api.AfterAll\norg.junit.Ignore\norg.junit.jupiter.api.Disabled\nNote that the following annotations might requires some rework of the tests to have JUnit5 equivalent behavior. A simple replacement of the\nannotation won\u2019t work immediately:\nJUnit4\nJUnit5\norg.junit.experimental.categories.Category\norg.junit.jupiter.api.Tag\norg.junit.Rule\norg.junit.jupiter.api.extension.ExtendWith\norg.junit.ClassRule\norg.junit.jupiter.api.extension.RegisterExtension\norg.junit.runner.RunWith\norg.junit.jupiter.api.extension.ExtendWith\nNoncompliant code example\n```java\npackage org.foo;\n\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\n\n@RunWith(MyJUnit4Runner.class)\npublic class MyJUnit4Test {\n\n  @BeforeClass\n  public static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterClass\n  public static void afterAll() {\n    System.out.println(\"AfterAll\");\n  }\n\n  @Before\n  public void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @After\n  public void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  public void test1() throws Exception {\n    System.out.println(\"test1\");\n  }\n\n  public interface SomeTests { /* category marker */ }\n\n  @Test\n  @Category(SomeTests.class)\n  public void test2() throws Exception {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Ignore(\"Requires fix of #42\")\n  public void ignored() throws Exception {\n    System.out.println(\"ignored\");\n  }\n}\n```\nCompliant solution\n```java\npackage org.foo;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Tag;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\n\n@ExtendWith(MyJUnit5Extension.class)\nclass MyJUnit5Test {\n\n  @BeforeAll\n  static void beforeAll() {\n    System.out.println(\"beforeAll\");\n  }\n\n  @AfterAll\n  static void afterAll() {\n    System.out.println(\"afterAll\");\n  }\n\n  @BeforeEach\n  void beforeEach() {\n    System.out.println(\"beforeEach\");\n  }\n\n  @AfterEach\n  void afterEach() {\n    System.out.println(\"afterEach\");\n  }\n\n  @Test\n  void test1() {\n    System.out.println(\"test1\");\n  }\n\n  @Test\n  @Tag(\"SomeTests\")\n  void test2() {\n    System.out.println(\"test2\");\n  }\n\n  @Test\n  @Disabled(\"Requires fix of #42\")\n  void disabled() {\n    System.out.println(\"ignored\");\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5786": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit5 test classes and methods should have default package visibility\nDescription: JUnit5 test classes and methods should generally have package visibility. To fix this issue, change their visibility to the default package\nvisibility.\nWhy is this an issue?\nJUnit5 is more tolerant regarding the visibility of test classes and methods than JUnit4, which required everything to be\npublic\n. Test\nclasses and methods can have any visibility except\nprivate\n. It is however recommended to use the default package visibility to improve\nreadability.\nTest classes, test methods, and lifecycle methods are not required to be\npublic\n, but they must not be\nprivate\n.\nIt is generally recommended to omit the public modifier for test classes, test methods, and lifecycle methods unless there is a technical reason\n  for doing so \u2013 for example, when a test class is extended by a test class in another package. Another technical reason for making classes and\n  methods public is to simplify testing on the module path when using the Java Module System.\n\u2014 JUnit5 User Guide\nWhat is the potential impact?\nThe code will be non-conventional and readability can be slightly affected.\nExceptions\nThis rule does not raise an issue when the visibility is set to\nprivate\n, because\nprivate\ntest methods and classes are\nsystematically ignored by JUnit5, without a proper warning. In this case, there is also an impact on reliability and so it is handled by the rule\n{rule:java:S5810}.\nHow to fix it\nYou can simply change the visibility by removing the\npublic\nor\nprotected\nkeywords.\nCode examples\nNoncompliant code example\n```java\nimport org.junit.jupiter.api.Test;\n\npublic class MyClassTest { // Noncompliant - modifier can be removed\n  @Test\n  protected void test() { // Noncompliant - modifier can be removed\n    // ...\n  }\n}\n```\nCompliant solution\n```java\nimport org.junit.jupiter.api.Test;\n\nclass MyClassTest {\n  @Test\n  void test() {\n    // ...\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5785": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit assertTrue/assertFalse should be simplified to the corresponding dedicated assertion\nDescription: Why is this an issue?\nTesting equality or nullness with JUnit\u2019s\nassertTrue()\nor\nassertFalse()\nshould be simplified to the corresponding\ndedicated assertion.\nNoncompliant code example\n```java\nAssert.assertTrue(a.equals(b));\nAssert.assertTrue(a == b);\nAssert.assertTrue(a == null);\nAssert.assertTrue(a != null);\nAssert.assertFalse(a.equals(b));\n```\nCompliant solution\n```java\nAssert.assertEquals(a, b);\nAssert.assertSame(a, b);\nAssert.assertNull(a);\nAssert.assertNotNull(a);\nAssert.assertNotEquals(a, b);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5778": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Only one method invocation is expected when testing runtime exceptions\nDescription: Why is this an issue?\nWhen verifying that code raises a runtime exception, a good practice is to avoid having multiple method calls inside the tested code, to be\nexplicit about which method call is expected to raise the exception.\nIt increases the clarity of the test, and avoid incorrect testing when another method is actually raising the exception.\nNoncompliant code example\n```java\n@Test\npublic void testToString() {\n  // Do you expect get() or toString() throwing the exception?\n  org.junit.Assert.assertThrows(IndexOutOfBoundsException.class, () -> get().toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  try {\n    // Do you expect get() or toString() throwing the exception?\n    get().toString();\n    Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n  } catch (IndexOutOfBoundsException e) {\n    // Test exception message...\n  }\n}\n```\nCompliant solution\n```java\n@Test\npublic void testToString() {\n   Object obj = get();\n   Assert.assertThrows(IndexOutOfBoundsException.class, () -> obj.toString());\n}\n\n@Test\npublic void testToStringTryCatchIdiom() {\n  Object obj = get();\n  try {\n    obj.toString();\n    Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n  } catch (IndexOutOfBoundsException e) {\n    // Test exception message...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5777": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception testing via JUnit @Test annotation should be avoided\nDescription: Why is this an issue?\nWhen testing exception via\n@Test\nannotation, having additional assertions inside that test method can be problematic because any code\nafter the raised exception will not be executed. It will prevent you to test the state of the program after the raised exception and, at worst, make\nyou\u00a0misleadingly think that it is executed.\nYou should consider moving any assertions into a separate test method where possible, or using\norg.junit.Assert.assertThrows\ninstead.\nAlternatively, you could use\ntry-catch idiom\nfor JUnit\nversion < 4.13 or if your project does not support lambdas.\nNoncompliant code example\n```java\n@Test(expected = IndexOutOfBoundsException.class)\npublic void testShouldFail() {\n  get();\n  // This test pass since execution will never get past this line.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n```\nCompliant solution\n1. For JUnit >= 4.13, useorg.junit.Assert.assertThrows:\n```java\n// This test correctly fails.\n@Test\npublic void testToString() {\n    Object obj = get();\n    Assert.assertThrows(IndexOutOfBoundsException.class, () -> obj.toString());\n    Assert.assertEquals(0, 1);\n}\n```\n1. For JUnit < 4.13, use thetry-catch idiom:\n```java\n@Test\npublic void testShouldFail() {\n    Object obj = get();\n    try {\n        obj.toString();\n        Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n    } catch (IndexOutOfBoundsException e) {}\n    Assert.assertEquals(0, 1); // Correctly fails.\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5776": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception testing via JUnit ExpectedException rule should not be mixed with other assertions\nDescription: Why is this an issue?\nWhen testing exception via\norg.junit.rules.ExpectedException\nany code after the raised exception will not be executed, so adding\nsubsequent assertions is wrong and misleading. This rule raises an issue when an assertion is done after the \"expect(\u2026\u200b)\" invocation, only the code\nthrowing the expected exception should be after \"expect(\u2026\u200b)\".\nYou should consider using\norg.junit.Assert.assertThrows\ninstead, it\u2019s available\nsince JUnit 4.13 and it allows additional subsequent assertions.\nAlternatively, you could use\ntry-catch idiom\nfor JUnit\nversion < 4.13 or if your project does not support lambdas.\nNoncompliant code example\n```java\n@Rule\npublic ExpectedException thrown = ExpectedException.none();\n\n@Test\npublic void test() throws IndexOutOfBoundsException {\n  thrown.expect(IndexOutOfBoundsException.class); // Noncompliant\n  Object o = get();\n  // This test pass since execution will never get past this line.\n  Assert.assertEquals(0, 1);\n}\n\nprivate Object get() {\n  throw new IndexOutOfBoundsException();\n}\n```\nCompliant solution\n1. For JUnit >= 4.13, useorg.junit.Assert.assertThrows:\n```java\nAssert.assertThrows(IndexOutOfBoundsException.class, () -> get());\n// This test correctly fails.\nAssert.assertEquals(0, 1);\n```\n1. For JUnit < 4.13, use thetry-catch idiom:\n```java\ntry {\n  get();\n  Assert.fail(\"Expected an IndexOutOfBoundsException to be thrown\");\n} catch (IndexOutOfBoundsException e) {}\nAssert.assertEquals(0, 1); // Correctly fails.\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5738": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Deprecated\" code marked for removal should never be used\nDescription: Why is this an issue?\nWith the introduction of Java 9, the standard annotation class\njava.lang.Deprecated\nhas been updated with new parameters. Notably, a\nboolean parameter\nforRemoval\nhas been added to clearly signify whether the deprecated code is intended to be removed in the future. This\nis indicated with\nforRemoval=true\n. The javadoc of the annotation explicitly mentions the following:\nThis annotation type has a boolean-valued element\nforRemoval\n. A value of\ntrue\nindicates intent to remove the annotated\n  program element in a future version. A value of\nfalse\nindicates that use of the annotated program element is discouraged, but at the\n  time the program element was annotated, there was no specific intent to remove it.\nWhile it is generally recommended for developers to steer clear of using deprecated classes, interfaces, and their deprecated members, those\nalready marked for removal will surely block you from upgrading your dependency. Usage of deprecated code should be avoided or eliminated as soon as\npossible to prevent accumulation and allow a smooth upgrade of dependencies.\nThe deprecated code is usually no longer maintained, can contain some bugs or vulnerabilities, and usually indicates that there is a better way to\ndo the same thing. Removing it can even lead to significant improvement of your software.\nHow to fix it\nUsage of deprecated classes, interfaces, and their methods explicitly marked for removal is discouraged. A developer should either migrate to\nalternative methods or refactor the code to avoid the deprecated ones.\nCode examples\nNoncompliant code example\n```java\n/**\n * @deprecated As of release 1.3, replaced by {@link #Fee}. Will be dropped with release 1.4.\n */\n@Deprecated(forRemoval=true)\npublic class Foo { ... }\n\npublic class Bar {\n  /**\n   * @deprecated  As of release 1.7, replaced by {@link #doTheThingBetter()}\n   */\n  @Deprecated(forRemoval=true)\n  public void doTheThing() { ... }\n\n  public void doTheThingBetter() { ... }\n\n  /**\n   * @deprecated As of release 1.14 due to poor performances.\n   */\n  @Deprecated(forRemoval=false)\n  public void doTheOtherThing() { ... }\n}\n\npublic class Qix extends Bar {\n  @Override\n  public void doTheThing() { ... } // Noncompliant; don't override a deprecated method marked for removal\n}\n\npublic class Bar extends Foo {  // Noncompliant; Foo is deprecated and will be removed\n\n  public void myMethod() {\n    Bar bar = new Bar();  // okay; the class isn't deprecated\n    bar.doTheThing();  // Noncompliant; doTheThing method is deprecated and will be removed\n\n    bar.doTheOtherThing(); // Okay; deprecated, but not marked for removal\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5669": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Vararg method arguments should not be confusing\nDescription: Why is this an issue?\nPassing single\nnull\nor primitive array argument to the variable arity method may not work as expected. In the case of\nnull\n, it is not passed as array with single element, but the argument itself is\nnull\n. In the case of a primitive array, if\nthe formal parameter is\nObject...\n, it is passed as a single element array. This may not be obvious to someone not familiar with such\ncorner cases, and it is probably better to avoid such ambiguities by explicitly casting the argument to the desired type.\nNoncompliant code example\n```java\nclass A {\n  public static void main(String[] args) {\n    vararg(null);  // Noncompliant, prints \"null\"\n    int[] arr = {1,2,3};\n    vararg(arr);  // Noncompliant, prints \"length: 1\"\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\");\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n```\nCompliant solution\n```java\nclass A {\n  public static void main(String[] args) {\n    vararg((Object) null); // prints 1\n    Object[] arr = {1,2,3};\n    vararg(arr); // prints 3\n  }\n\n  static void vararg(Object... s) {\n    if (s == null) {\n      System.out.println(\"null\"); // not reached\n    } else {\n      System.out.println(\"length: \" + s.length);\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5665": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Escape sequences should not be used in text blocks\nDescription: Why is this an issue?\nThe use of escape sequences is mostly unnecessary in text blocks.\nNoncompliant code example\n\\n\ncan be replaced by simply introducing the newline,\n\\\"\\\"\\\"\nit is sufficient to escape only the first qoute.\n```java\nString textBlock = \"\"\"\n        \\\"\\\"\\\" this \\nis\n        text  block!\n        !!!!\n      \"\"\";\n```\nCompliant solution\n```java\nString textBlock = \"\"\"\n        \\\"\"\" this\n        is\n        text  block!\n        !!!!\n      \"\"\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5664": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Whitespace for text block indent should be consistent\nDescription: Why is this an issue?\nEither use only spaces or only tabs for the indentation of a text block. Mixing white space will lead to a result with irregular indentation.\nNoncompliant code example\n```java\nString textBlock = \"\"\"\n        this is\n<tab>text block!\n        !!!!\n      \"\"\";\n```\nCompliant solution\n```java\nString textBlock = \"\"\"\n        this is\n        text block!\n        !!!!\n      \"\"\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5663": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Simple string literal should be used for single line strings\nDescription: Why is this an issue?\nIf a string fits on a single line, without concatenation and escaped newlines, you should probably continue to use a string literal.\nNoncompliant code example\n```java\nString question = \"\"\"\n              What's the point, really?\"\"\";\n```\nCompliant solution\n```java\nString question = \"What's the point, really?\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5612": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas should not have too many lines\nDescription: Why is this an issue?\nLambdas (introduced with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class or method.\nBut those lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly\nbecome unreadable.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5413": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: 'List.remove()' should not be used in ascending 'for' loops\nDescription: Why is this an issue?\nWhen\nList.remove()\nis called, the list shrinks, and the indices of all elements following the removed element are decremented by one.\nIf this operation is performed within a loop that iterates through the elements in ascending order, it will cause the loop to skip the element\nimmediately following the removed element.\nHow to fix it\nThere are three ways how to fix this issue:\nReplace the loop with a call to\nCollection.removeIf()\n. This is the preferred solution.\nReplace the ascending loop with a descending loop. Use this approach if the preferred solution is not possible due to side effects of the loop.\nAdjust the loop counter within the loop body after the call to\nCollection.remove()\n.\nThis approach is not\n  recommended\n, because it will raise an issue with rule\n{rule:java:S127} - \"for\" loop stop conditions should be invariant\nCode examples\nNoncompliant code example\nIf the loop can be replaced with Java 8\u2019s\nCollection.removeIf\nmethod, depending on the side effects of the loop and your Java target\nversion, then this is the preferred solution for this issue.\n```java\nvoid removeFrom(List<String> list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i < list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n```\nCompliant solution\n```java\nvoid removeFrom(List<String> list) {\n  list.removeIf(String::isEmpty); // Compliant\n}\n```\nNoncompliant code example\nIf this is not possible due to side effects of the loop, replace the ascending loop with a descending loop. Descending loops are not affected by\ndecrementing the element indices after the removed element, because they have already been iterated.\n```java\nvoid removeFrom(List<String> list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i < list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n```\nCompliant solution\n```java\nvoid removeFrom(List<String> list) {\n    // expected: iterate over all list elements\n    for (int i = list.size() - 1; i >= 0; i--) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Compliant, elements after removed one have already been iterated\n    }\n  }\n}\n```\nNoncompliant code example\nAnother way to solve this issue is to adjust the loop counter after the call to\nCollection.remove\nto account for the index\ndecrement.\n```java\nvoid removeFrom(List<String> list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i < list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Noncompliant, next element is skipped\n    }\n  }\n}\n```\nCompliant solution\nThis is not recommanded\nbecause it raises an issue with rule {rule:java:S127}.\n```java\nvoid removeFrom(List<String> list) {\n  // expected: iterate over all list elements\n  for (int i = 0; i < list.size(); i++) {\n    if (list.get(i).isEmpty()) {\n      list.remove(i); // Compliant due to counter adjust in next line\n      i--; // Noncompliant with S127!\n    }\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5411": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Avoid using boxed \"Boolean\" types directly in boolean expressions\nDescription: Why is this an issue?\nWhen boxed type\njava.lang.Boolean\nis used as an expression to determine the control flow (as described in\nJava Language Specification \u00a74.2.5 The\nboolean\nType and\nboolean Values\n) it will throw a\nNullPointerException\nif the value is\nnull\n(as defined in\nJava Language Specification \u00a75.1.8 Unboxing Conversion\n).\nIt is safer to avoid such conversion altogether and handle the\nnull\nvalue explicitly.\nNote, however, that no issues will be raised for Booleans that have already been null-checked or are marked\n@NonNull/@NotNull\n.\nNoncompliant code example\n```java\nBoolean b = getBoolean();\nif (b) {  // Noncompliant, it will throw NPE when b == null\n  foo();\n} else {\n  bar();\n}\n```\nCompliant solution\n```java\nBoolean b = getBoolean();\nif (Boolean.TRUE.equals(b)) {\n  foo();\n} else {\n  bar();  // will be invoked for both b == false and b == null\n}\n\n\nBoolean b = getBoolean();\nif(b != null){\n  String test = b ? \"test\" : \"\";\n}\n```\nExceptions\nThe issue is not raised if the expression is annotated\n@NonNull\n/\n@NotNull\n. This is useful if a boxed type is an\ninstantiation of a generic type parameter and cannot be avoided.\n```java\nList<Boolean> list = new ArrayList<>();\nlist.add(true);\nlist.add(false);\nlist.forEach((@NonNull Boolean value) -> {\n  // Compliant\n  if(value) {\n    System.out.println(\"yes\");\n  }\n});\n\n@NonNull Boolean someMethod() { /* ... */ }\n\n// Compliant\nif(someMethod()) { /* ... */ }\n\n@NonNull Boolean boxedNonNull = Boolean.TRUE;\n\n// Compliant\nif(boxedNonNull) { /* ... */ }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5361": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"String#replace\" should be preferred to \"String#replaceAll\"\nDescription: Why is this an issue?\nThe underlying implementation of\nString::replaceAll\ncalls the\njava.util.regex.Pattern.compile()\nmethod each time it is\ncalled even if the first argument is not a regular expression. This has a significant performance cost and therefore should be used with care.\nWhen\nString::replaceAll\nis used, the first argument should be a real regular expression. If it\u2019s not the case,\nString::replace\ndoes exactly the same thing as\nString::replaceAll\nwithout the performance drawback of the regex.\nThis rule raises an issue for each\nString::replaceAll\nused with a\nString\nas first parameter which doesn\u2019t contains\nspecial regex character or pattern.\nNoncompliant code example\n```java\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"Bob is\", \"It's\"); // Noncompliant\nchanged = changed.replaceAll(\"\\\\.\\\\.\\\\.\", \";\"); // Noncompliant\n```\nCompliant solution\n```java\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replace(\"Bob is\", \"It's\");\nchanged = changed.replace(\"...\", \";\");\n```\nOr, with a regex:\n```java\nString init = \"Bob is a Bird... Bob is a Plane... Bob is Superman!\";\nString changed = init.replaceAll(\"\\\\w*\\\\sis\", \"It's\");\nchanged = changed.replaceAll(\"\\\\.{3}\", \";\");\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5329": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Collection constructors should not be used as java.util.function.Function\nDescription: Why is this an issue?\nIt is very common to pass a collection constructor reference as an argument, for example\nCollectors.toCollection(ArrayList::new)\ntakes\nthe\nArrayList::new\nconstructor. When the method expects a\njava.util.function.Supplier\nit is perfectly fine. However when the\nmethod argument type is\njava.util.function.Function\nit means that an argument will be passed to the constructor.\nThe first argument of Collections constructors is usually an integer representing its \"initial capacity\". This is generally not what the developer\nexpects, but the memory allocation is not visible at first glance.\nThis rule raises an issue when a collection constructor is passed by reference as a\njava.util.function.Function\nargument.\nNoncompliant code example\n```java\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), ArrayList::new)); // Noncompliant, \"ArrayList::new\" unintentionally refers to \"ArrayList(int initialCapacity)\" instead of \"ArrayList()\"\n```\nCompliant solution\n```java\nArrays.asList(1, 2, 54000).stream().collect(Collectors.toMap(Function.identity(), id -> new ArrayList<>())); // Compliant, explicitly show the usage of \"id -> new ArrayList<>()\" or \"id -> new ArrayList<>(id)\"\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5261": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"else\" statements should be clearly matched with an \"if\"\nDescription: Why is this an issue?\nThe dangling\nelse\nproblem appears when nested\nif\n/\nelse\nstatements are written without curly braces. In\nthis case,\nelse\nis associated with the nearest\nif\nbut that is not always obvious and sometimes the indentation can also\nbe misleading.\nThis rules reports\nelse\nstatements that are difficult to understand, because they are inside nested\nif\nstatements without\ncurly braces.\nAdding curly braces can generally make the code clearer (see rule {rule:java:S121} ), and in this situation of dangling\nelse\n, it\nreally clarifies the intention of the code.\nNoncompliant code example\n```java\nif (a)\n   if (b)\n     d++;\n else     // Noncompliant, is the \"else\" associated with \"if(a)\" or \"if (b)\"? (the answer is \"if(b)\")\n   e++;\n```\nCompliant solution\n```java\nif (a) {\n   if (b) {\n     d++;\n   }\n } else { // Compliant, there is no doubt the \"else\" is associated with \"if(a)\"\n   e++;\n }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5194": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Use Java 14 \"switch\" expression\nDescription: Why is this an issue?\nMany existing switch statements are essentially simulations of switch expressions, where each arm either assigns to a common target variable or\nreturns a value. Expressing this as a statement is roundabout, repetitive, and error-prone.\nJava 14 added support for switch expressions, which provide more succinct and less error-prone version of switch.\nNoncompliant code example\n```java\nvoid day_of_week(DoW day) {\n    int numLetters;\n    switch (day) {  // Noncompliant\n      case MONDAY:\n      case FRIDAY:\n      case SUNDAY:\n        numLetters = 6;\n        break;\n      case TUESDAY:\n        numLetters = 7;\n        break;\n      case THURSDAY:\n      case SATURDAY:\n        numLetters = 8;\n        break;\n      case WEDNESDAY:\n        numLetters = 9;\n        break;\n      default:\n        throw new IllegalStateException(\"Wat: \" + day);\n    }\n}\n\nint return_switch(int x) {\n    switch (x) { // Noncompliant\n      case 1:\n        return 1;\n      case 2:\n        return 2;\n      default:\n        throw new IllegalStateException();\n    }\n}\n```\nCompliant solution\n```java\nint numLetters = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -> 6;\n    case TUESDAY                -> 7;\n    case THURSDAY, SATURDAY     -> 8;\n    case WEDNESDAY              -> 9;\n};\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-5128": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Bean Validation\" (JSR 380) should be properly configured\nDescription: Why is this an issue?\nBean Validation\nas per defined by JSR 380 can be triggered programmatically or also executed by the\nBean Validation\nproviders. However something should tell the\nBean Validation\nprovider that a variable must be validated otherwise no validation will\nhappen. This can be achieved by annotating a variable with\njavax.validation.Valid\nand unfortunally it\u2019s easy to forget to add this\nannotation on complex Beans.\nNot annotating a variable with\n@Valid\nmeans\nBean Validation\nwill not be triggered for this variable, but readers may\noverlook this omission and assume the variable will be validated.\nThis rule will run by default on all\nClass\n'es and therefore can generate a lot of noise. This rule should be restricted to run only on\ncertain layers. For this reason, the \"Restrict Scope of Coding Rules\" feature should be used to check for missing\n@Valid\nannotations only\non some packages of the application.\nNoncompliant code example\n```java\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @NotNull\n  private List<User> users; // Noncompliant; User instances are not validated\n}\n\npublic class MyService {\n  public void login(User user) { // Noncompliant; parameter \"user\" is not validated\n  }\n}\n```\nCompliant solution\n```java\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\n\npublic class User {\n  @NotNull\n  private String name;\n}\n\npublic class Group {\n  @Valid\n  @NotNull\n  private List<User> users; // Compliant; User instances are validated\n\n  @NotNull\n  // preferred style as of Bean Validation 2.0\n  private List<@Valid User> users2; // Compliant; User instances are validated\n}\n\npublic class MyService {\n  public void login(@Valid User user) { // Compliant\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4977": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Type parameters should not shadow other type parameters\nDescription: Why is this an issue?\nShadowing makes it impossible to use the type parameter from the outer scope. Also, it can be confusing to distinguish which type parameter is\nbeing used.\nThis rule raises an issue when a type parameter from an inner scope uses the same name as one in an outer scope.\nNoncompliant code example\n```java\npublic class TypeParameterHidesAnotherType<T> {\n\n    public class Inner<T> { // Noncompliant\n      //...\n    }\n\n    private <T> T method() { // Noncompliant\n      return null;\n    }\n\n  }\n```\nCompliant solution\n```java\npublic class NoTypeParameterHiding<T> {\n\n    public class Inner<S> { // Compliant\n      List<S> listOfS;\n    }\n\n    private <V> V method() { // Compliant\n      return null;\n    }\n\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4970": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Derived exceptions should not hide their parents' catch blocks\nDescription: Why is this an issue?\nThe\ncatch\nblock of a checked exception \"E\" may be hidden because the corresponding\ntry\nblock only throws exceptions\nderived from E.\nThese derived exceptions are handled in dedicated\ncatch\nblocks prior to the\ncatch\nblock of the base exception E.\nThe\ncatch\nblock of E is unreachable and should be considered dead code. It should be removed, or the entire try-catch structure should\nbe refactored.\nIt is also possible that a single exception type in a multi-catch block may be hidden while the catch block itself is still reachable. In that case\nit is enough to only remove the hidden exception type or to replace it with another type.\nNoncompliant code example\n```java\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) {\n      // ...\n    } catch(CustomException e) { // Noncompliant; this code is unreachable\n      // ...\n    }\n  }\n\n  private static void throwCustomDerivedException() throws CustomDerivedException {\n    throw new CustomDerivedException();\n  }\n}\n```\nCompliant solution\n```java\npublic class HiddenCatchBlock {\n\n  public static class CustomException extends Exception {\n  }\n\n  public static class CustomDerivedException extends CustomException {\n  }\n\n  public static void main(String[] args) {\n    try {\n      throwCustomDerivedException();\n    } catch(CustomDerivedException e) { // Compliant; try-catch block is \"catching\" only the Exception that can be thrown in the \"try\"\n      //...\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4968": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The upper bound of type variables and wildcards should not be \"final\" \nDescription: Why is this an issue?\nWhen a type variable or a wildcard declares an upper bound that is\nfinal\n, the parametrization is not generic at all because it accepts\none and only one type at runtime: the one that is\nfinal\n. Instead of using\nGenerics\n, it\u2019s simpler to directly use the\nconcrete\nfinal\nclass.\nNoncompliant code example\n```java\npublic static <T extends String> T getMyString() { // Noncompliant; String is a \"final\" class and so can't be extended\n [...]\n}\n```\nCompliant solution\n```java\npublic static String getMyString() { // Compliant\n  [...]\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4929": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"read(byte[],int,int)\" should be overridden\nDescription: Why is this an issue?\nWhen directly subclassing\njava.io.InputStream\nor\njava.io.FilterInputStream\n, the only requirement is that you implement\nthe method\nread()\n. However most uses for such streams don\u2019t read a single byte at a time and the default implementation for\nread(byte[],int,int)\nwill call\nread(int)\nfor every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\nread(byte[],int,int)\n.\nThis rule raises an issue when a direct subclass of\njava.io.InputStream\nor\njava.io.FilterInputStream\ndoesn\u2019t provide an\noverride of\nread(byte[],int,int)\n.\nNoncompliant code example\n```java\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n}\n```\nCompliant solution\n```java\npublic class MyInputStream extends java.io.InputStream {\n  private FileInputStream fin;\n\n  public MyInputStream(File file) throws IOException {\n    fin = new FileInputStream(file);\n  }\n\n  @Override\n  public int read() throws IOException {\n    return fin.read();\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    return fin.read(b, off, len);\n  }\n}\n```\nExceptions\nThis rule doesn\u2019t raise an issue when the class is declared\nabstract\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4926": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"serialVersionUID\" should not be declared blindly\nDescription: Why is this an issue?\nProviding a\nserialVersionUID\nfield on\nSerializable\nclasses is strongly recommended by the\nSerializable\ndocumentation but blindly following that recommendation can be harmful.\nserialVersionUID\nvalue is stored with the serialized data and this field is verified when deserializing the data to ensure that the\ncode reading the data is compatible with the serialized data. In case of failure, it means the serialized data and the code are not in sync and this\nfine because you know what\u2019s wrong.\nWhen the\nserialVersionUID\nis generated by an IDE or blindly hard-coded, there is a high probability that one will forget to update the\nserialVersionUID\nvalue when the\nSerializable\nclass is later enriched with additional fields. As a consequence, old\nserialized data will incorrectly be considered compatible with the newer version of the code creating situations which are hard to debug.\nTherefore, defining\nserialVersionUID\nshould be done with care. This rule raises an issue on each\nserialVersionUID\nfield\ndeclared on classes implementing\nSerializable\nto be sure the presence and the value of the\nserialVersionUID\nfield is\nchallenged and validated by the team.\nNoncompliant code example\n```java\npublic class Foo implements Serializable {\n  private static final long serialVersionUID = 1;\n}\n\npublic class BarException extends RuntimeException {\n  private static final long serialVersionUID = 8582433437601788991L;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4925": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Class.forName()\" should not load JDBC 4.0+ drivers\nDescription: Why is this an issue?\nIn the past, it was required to load a JDBC driver before creating a\njava.sql.Connection\n. Nowadays, when using JDBC 4.0 drivers, this\nis no longer required and\nClass.forName()\ncan be safely removed because JDBC 4.0 (JDK 6) drivers available in the classpath are\nautomatically loaded.\nThis rule raises an issue when\nClass.forName()\nis used with one of the following values:\n1. com.mysql.jdbc.Driver\n2. oracle.jdbc.driver.OracleDriver\n3. com.ibm.db2.jdbc.app.DB2Driver\n4. com.ibm.db2.jdbc.net.DB2Driver\n5. com.sybase.jdbc.SybDriver\n6. com.sybase.jdbc2.jdbc.SybDriver\n7. com.teradata.jdbc.TeraDriver\n8. com.microsoft.sqlserver.jdbc.SQLServerDriver\n9. org.postgresql.Driver\n10. sun.jdbc.odbc.JdbcOdbcDriver\n11. org.hsqldb.jdbc.JDBCDriver\n12. org.h2.Driver\n13. org.firebirdsql.jdbc.FBDriver\n14. net.sourceforge.jtds.jdbc.Driver\n15. com.ibm.db2.jcc.DB2Driver\nNoncompliant code example\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n  private static final String DRIVER_CLASS_NAME = \"org.postgresql.Driver\";\n  private final Connection connection;\n\n  public Demo(String serverURI) throws SQLException, ClassNotFoundException {\n    Class.forName(DRIVER_CLASS_NAME); // Noncompliant; no longer required to load the JDBC Driver using Class.forName()\n    connection = DriverManager.getConnection(serverURI);\n  }\n}\n```\nCompliant solution\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Demo {\n    private final Connection connection;\n\n    public Demo(String serverURI) throws SQLException {\n        connection = DriverManager.getConnection(serverURI);\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4838": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An iteration on a Collection should be performed on the type handled by the Collection\nDescription: Why is this an issue?\nWhen iterating over an\nIterable\nwith a\nfor\nloop, the iteration variable could have the same type as the type returned by\nthe iterator (the item type of the\nIterable\n). This rule reports when a supertype of the item type is used for the variable instead, but\nthe variable is then explicitly downcast in the loop body.\nUsing explicit type casts instead of leveraging the language\u2019s type system is a bad practice. It disables static type checking by the compiler for\nthe cast expressions, but potential errors will throw a\nClassCastException\nduring runtime instead.\nHow to fix it\nCode examples\nNoncompliant code example\nWhen declaring the iteration variable, use the item type for it instead of a supertype. Remove the explicit downcasts in the loop body.\n```java\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n```\nCompliant solution\n```java\nfor (Person person : getPersons()) { // Compliant\n  person.getAddress();\n}\n```\nNoncompliant code example\nAlternatively, use the\nvar\nkeyword to automatically infer the variable type (since Java 10).\n```java\nfor (Object item : getPersons()) { // Noncompliant, iteration element is implicitly upcast here\n  Person person = (Person) item; // Noncompliant, item is explicitly downcast here\n  person.getAddress();\n}\n```\nCompliant solution\n```java\nfor (var person : getPersons()) { // Compliant\n  person.getAddress();\n}\n```\nCompliant solution\nThe implicit upcast in the loop header is not reported when there is no downcast in the loop body.\n```java\nfor (Object item : getPersons()) { // Compliant\n  System.out.println(item);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4738": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Java features should be preferred to Guava\nDescription: Why is this an issue?\nSome Guava features were really useful for Java 7 application because Guava was bringing APIs missing in the JDK. Java 8 fixed some of these\nlimitations. When migrating an application to Java 8 or even when starting a new one, it\u2019s recommended to prefer Java 8 APIs over Guava ones to ease\nits maintenance: developers don\u2019t need to learn how to use two APIs and can stick to the standard one.\nJava 9 brought even more useful methods to the standard Java library and if Java version is equal to or higher than 9, these standard methods\nshould be used.\nThis rule raises an issue when the following Guava APIs are used:\nGuava API\nJava 8 API\ncom.google.common.io.BaseEncoding#base64()\njava.util.Base64\ncom.google.common.io.BaseEncoding#base64Url()\njava.util.Base64\ncom.google.common.base.Joiner.on()\njava.lang.String#join() or java.util.stream.Collectors#joining()\ncom.google.common.base.Optional#of()\njava.util.Optional#of()\ncom.google.common.base.Optional#absent()\njava.util.Optional#empty()\ncom.google.common.base.Optional#fromNullable()\njava.util.Optional#ofNullable()\ncom.google.common.base.Optional\njava.util.Optional\ncom.google.common.base.Predicate\njava.util.function.Predicate\ncom.google.common.base.Function\njava.util.function.Function\ncom.google.common.base.Supplier\njava.util.function.Supplier\ncom.google.common.io.Files.createTempDir\njava.nio.file.Files.createTempDirectory\nGuava API\nJava 9 API\ncom.google.common.collect.ImmutableSet#of()\njava.util.Set#of()\ncom.google.common.collect.ImmutableList#of()\njava.util.List#of()\ncom.google.common.collect.ImmutableMap#of()\njava.util.Map#of() or java.util.Map#ofEntries()\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4719": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"StandardCharsets\" constants should be preferred\nDescription: Why is this an issue?\nJDK7 introduced the class\njava.nio.charset.StandardCharsets\n. It provides constants for all charsets that are guaranteed to be\navailable on every implementation of the Java platform.\n1. ISO_8859_1\n2. US_ASCII\n3. UTF_16\n4. UTF_16BE\n5. UTF_16LE\n6. UTF_8\nThese constants should be preferred to:\n1. the use of a String such as \"UTF-8\" which has the drawback of requiring thecatch/throwof anUnsupportedEncodingExceptionthat will never actually happen\n2. the use of Guava\u2019sCharsetsclass, which has been obsolete since JDK7\nNoncompliant code example\n```java\ntry {\n  byte[] bytes = string.getBytes(\"UTF-8\"); // Noncompliant; use a String instead of StandardCharsets.UTF_8\n} catch (UnsupportedEncodingException e) {\n  throw new AssertionError(e);\n}\n// ...\nbyte[] bytes = string.getBytes(Charsets.UTF_8); // Noncompliant; Guava way obsolete since JDK7\n```\nCompliant solution\n```java\nbyte[] bytes = string.getBytes(StandardCharsets.UTF_8)\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4682": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@CheckForNull\" or \"@Nullable\" should not be used on primitive types\nDescription: Why is this an issue?\nBy definition, primitive types are not Objects and so they cannot be\nnull\n. Adding\n@CheckForNull\nor\n@Nullable\non primitive types is redundant and may lead to misunderstandings.\nThis rule raises an issue when\n@CheckForNull\nor\n@Nullable\nis set on a method returning a primitive type: byte, short,\nint, long, float, double, boolean, char.\nNoncompliant code example\n```java\n@CheckForNull\nboolean isFoo() {\n ...\n}\n```\nCompliant solution\n```java\nboolean isFoo() {\n ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4635": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: String offset-based methods should be preferred for finding substrings from offsets\nDescription: Why is this an issue?\nLooking for a given substring starting from a specified offset can be achieved by such code:\nstr.substring(beginIndex).indexOf(char1)\n.\nThis works well, but it creates a new\nString\nfor each call to the\nsubstring\nmethod. When this is done in a loop, a lot of\nStrings\nare created for nothing, which can lead to performance problems if\nstr\nis large.\nTo avoid performance problems,\nString.substring(beginIndex)\nshould not be chained with the following methods:\n1. indexOf(int ch)\n2. indexOf(String str)\n3. lastIndexOf(int ch)\n4. lastIndexOf(String str)\n5. startsWith(String prefix)\nFor each of these methods, another method with an additional parameter is available to specify an offset.\nUsing these methods will avoid the creation of additional\nString\ninstances. For indexOf methods, adjust the returned value by\nsubtracting the substring index parameter to obtain the same result.\nNoncompliant code example\n```java\nstr.substring(beginIndex).indexOf(char1); // Noncompliant; a new String is going to be created by \"substring\"\n```\nCompliant solution\n```java\nstr.indexOf(char1, beginIndex) - beginIndex; // index for char1 not found is (-1-beginIndex)\n```\nBenchmarks\nMethod\nstringSize\nRuntime\nAverage time\nError margin\nindexOfOnly\n10\nTemurin 21\n1.55 ns/op\n\u00b10.12 ns/op\nindexOfOnly\n100\nTemurin 21\n1.78 ns/op\n\u00b10.05 ns/op\nindexOfOnly\n1000\nTemurin 21\n1.82 ns/op\n\u00b10.18 ns/op\nindexOfOnly\n10000\nTemurin 21\n1.77 ns/op\n\u00b10.08 ns/op\nsubstringThenIndexOf\n10\nTemurin 21\n4.85 ns/op\n\u00b10.41 ns/op\nsubstringThenIndexOf\n100\nTemurin 21\n6.22 ns/op\n\u00b10.40 ns/op\nsubstringThenIndexOf\n1000\nTemurin 21\n14.22 ns/op\n\u00b11.66 ns/op\nsubstringThenIndexOf\n10000\nTemurin 21\n275.00 ns/op\n\u00b120.49 ns/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S4635 {\n  @Param({\"10\", \"100\", \"1000\", \"10000\"})\n  int stringSize;\n\n  String input;\n\n  @Setup\n  public void setup() {\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < stringSize; i++) {\n      builder.append('a');\n    }\n    input = builder.toString();\n  }\n\n  @Benchmark\n  public int substringThenIndexOf() {\n    return stringSize / 2 + input.substring(stringSize / 2).indexOf('a');\n  }\n\n  @Benchmark\n  public int indexOfOnly() {\n    return input.indexOf('a', stringSize / 2);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4605": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Spring beans should be considered by \"@ComponentScan\"\nDescription: Why is this an issue?\nSpring beans belonging to packages that are not included in a\n@ComponentScan\nconfiguration will not be accessible in the Spring\nApplication Context. Therefore, it\u2019s likely to be a configuration mistake that will be detected by this rule.\nNote:\nthe\n@ComponentScan\nis implicit in the\n@SpringBootApplication\nannotation, case in which Spring Boot\nwill auto scan for components in the package containing the Spring Boot main class and its sub-packages.\nNoncompliant code example\n```java\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan(\"com.mycompany.app.beans\")\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // Noncompliant; MyController belong to \"com.mycompany.app.web\" while the ComponentScan is looking for beans in \"com.mycompany.app.beans\" package\n...\n}\n```\nCompliant solution\n```java\npackage com.mycompany.app;\n\n@Configuration\n@ComponentScan({\"com.mycompany.app.beans\",\"com.mycompany.app.web\"})\nor\n@ComponentScan(\"com.mycompany.app\")\nor\n@ComponentScan\npublic class Application {\n...\n}\n\npackage com.mycompany.app.web;\n\n@Controller\npublic class MyController { // \"com.mycompany.app.web\" is referenced by a @ComponentScan annotated class\n...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4604": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@EnableAutoConfiguration\" should be fine-tuned\nDescription: This rule is deprecated, and will eventually be removed.\nWhy is this an issue?\n\"@EnableAutoConfiguration\" is a convenient feature to configure the Spring Application Context by attempting to guess the beans that you are likely\nto need. The drawback is that it may load and configure beans the application will never use and therefore consume more CPU and RAM than really\nrequired.\n@EnableAutoConfiguration\nshould be configured to exclude all the beans not required by the application. Alternatively, use the\n@Import\nannotation instead of\n@EnableAutoConfiguration\n, to explicitly import the useful AutoConfiguration classes.\nThis rule applies for\n@SpringBootApplication\nas well.\nNoncompliant code example\n```java\n@SpringBootApplication\npublic class MyApplication {\n...\n}\n```\n```java\n@Configuration\n@EnableAutoConfiguration\npublic class MyApplication {\n...\n}\n```\nCompliant solution\n```java\n@SpringBootApplication(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n```\n```java\n@Configuration\n@EnableAutoConfiguration(exclude = {\n  MultipartAutoConfiguration.class,\n  JmxAutoConfiguration.class,\n})\npublic class MyApplication {\n...\n}\n```\n```java\n@Configuration\n@Import({\n        DispatcherServletAutoConfiguration.class,\n        EmbeddedServletContainerAutoConfiguration.class,\n        ErrorMvcAutoConfiguration.class,\n        HttpEncodingAutoConfiguration.class,\n        HttpMessageConvertersAutoConfiguration.class,\n        JacksonAutoConfiguration.class,\n        ServerPropertiesAutoConfiguration.class,\n        PropertyPlaceholderAutoConfiguration.class,\n        ThymeleafAutoConfiguration.class,\n        WebMvcAutoConfiguration.class\n})\npublic class MyApplication {\n...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4551": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Enum values should be compared with \"==\"\nDescription: Why is this an issue?\nTesting equality of an enum value with\nequals\nis perfectly valid because an enum is an Object and every Java developer knows \"==\"\nshould not be used to compare the content of an Object. At the same time, using \"==\" on enums:\n1. provides the same expected comparison (content) asequals\n2. is more null-safe than equals()\n3. provides compile-time (static) checking rather than runtime checking\nFor these reasons, use of \"==\" should be preferred to\nequals\n.\nNoncompliant code example\n```java\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\n\npublic enum Cake {\n  LEMON_TART, CHEESE_CAKE\n}\n\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // Noncompliant; this will raise an NPE if candidateFruit is NULL\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit.equals(Fruit.GRAPE); // Noncompliant; always returns false\n}\n```\nCompliant solution\n```java\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // Compliant; there is only one instance of Fruit.GRAPE - if candidateFruit is a GRAPE it will have the same reference as Fruit.GRAPE\n}\n\npublic boolean isFruitGrape(Cake candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // Compliant; compilation time failure\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4524": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"default\" clauses should be last\nDescription: Why is this an issue?\nswitch\ncan contain a\ndefault\nclause for various reasons: to handle unexpected values, to show that all the cases were\nproperly considered, etc.\nFor readability purposes, to help a developer quickly spot the default behavior of a\nswitch\nstatement, it is recommended to put the\ndefault\nclause at the end of the\nswitch\nstatement.\nThis rule raises an issue if the\ndefault\nclause is not the last one of the\nswitch\n's cases.\n```java\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  default: // Noncompliant: default clause should be the last one\n    error();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4488": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Composed \"@RequestMapping\" variants should be preferred\nDescription: Why is this an issue?\nSpring framework 4.3 introduced variants of the\n@RequestMapping\nannotation to better represent the semantics of the annotated methods.\nThe use of\n@GetMapping\n,\n@PostMapping\n,\n@PutMapping\n,\n@PatchMapping\nand\n@DeleteMapping\nshould be preferred to the use of the raw\n@RequestMapping(method = RequestMethod.XYZ)\n.\nNoncompliant code example\n```java\n@RequestMapping(path = \"/greeting\", method = RequestMethod.GET) // Noncompliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n```\nCompliant solution\n```java\n@GetMapping(path = \"/greeting\") // Compliant\npublic Greeting greeting(@RequestParam(value = \"name\", defaultValue = \"World\") String name) {\n...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4454": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"equals\" method parameters should not be marked \"@Nonnull\"\nDescription: Why is this an issue?\nBy contract, the\nequals(Object)\nmethod, from\njava.lang.Object\n, should accept a\nnull\nargument. Among all the\nother cases, the\nnull\ncase is even explicitly detailed in the\nObject.equals(...)\nJavadoc, stating\n\"For any non-null\nreference value x, x.equals(null) should return false.\"\nAssuming that the argument to\nequals\nis always non-null, and enforcing that assumption with an annotation is not only a fundamental\nviolation of the contract of\nequals\n, but it is also likely to cause problems in the future as the use of the class evolves over time.\nThe rule raises an issue when the\nequals\nmethod is overridden and its parameter annotated with any kind of\n@Nonnull\nannotation.\nNoncompliant code example\n```java\npublic boolean equals(@javax.annotation.Nonnull Object obj) { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\npublic boolean equals(Object obj) {\n  if (obj == null) {\n    return false;\n  }\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4449": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nullness of parameters should be guaranteed\nDescription: Why is this an issue?\nWhen using null-related annotations at global scope level, for instance using\njavax.annotation.ParametersAreNonnullByDefault\n(from\nJSR-305) at package level, it means that all the parameters to all the methods included in the package will, or should, be considered\nNon-\nnull\n. It is equivalent to annotating every parameter in every method with non-null annotations (such as\n@Nonnull\n).\nThe rule raises an issue every time a parameter could be\nnull\nfor a method invocation, where the method is annotated as forbidding\nnull parameters.\nNoncompliant code example\n```java\n@javax.annotation.ParametersAreNonnullByDefault\nclass A {\n\n  void foo() {\n    bar(getValue()); // Noncompliant - method 'bar' do not expect 'null' values as parameter\n  }\n\n  void bar(Object o) { // 'o' is by contract expected never to be null\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n```\nCompliant solution\nTwo solutions are possible:\n1. The signature of the method is correct, and null check should be done prior to the call.\n2. The signature of the method is not coherent and should be annotated to allow null values being passed as parameter\n```java\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n      Object o = getValue();\n      if (o != null) {\n        bar(o); // Compliant - 'o' can not be null\n      }\n  }\n\n  void bar(Object o) {\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n```\nor\n```java\n@javax.annotation.ParametersAreNonnullByDefault\nabstract class A {\n\n  void foo() {\n    bar(getValue());\n  }\n\n  void bar(@javax.annotation.Nullable Object o) { // annotation was missing\n    // ...\n  }\n\n  @javax.annotation.CheckForNull\n  abstract Object getValue();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4425": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Integer.toHexString\" should not be used to build hexadecimal strings\nDescription: Why is this an issue?\nUsing\nInteger.toHexString\nis a common mistake when converting sequences of bytes into hexadecimal string representations. The problem\nis that the method trims leading zeroes, which can lead to wrong conversions. For instance a two bytes value of\n0x4508\nwould be converted\ninto\n45\nand\n8\nwhich once concatenated would give\n0x458\n.\nThis is particularly damaging when converting hash-codes and could lead to a security vulnerability.\nThis rule raises an issue when\nInteger.toHexString\nis used in any kind of string concatenations.\nNoncompliant code example\n```java\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(Integer.toHexString( b & 0xFF )); // Noncompliant\n}\n```\nCompliant solution\n```java\nMessageDigest md = MessageDigest.getInstance(\"SHA-256\");\nbyte[] bytes = md.digest(password.getBytes(\"UTF-8\"));\n\nStringBuilder sb = new StringBuilder();\nfor (byte b : bytes) {\n    sb.append(String.format(\"%02X\", b));\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4349": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"write(byte[],int,int)\" should be overridden\nDescription: Why is this an issue?\nWhen directly subclassing\njava.io.OutputStream\nor\njava.io.FilterOutputStream\n, the only requirement is that you implement\nthe method\nwrite(int)\n. However most uses for such streams don\u2019t write a single byte at a time and the default implementation for\nwrite(byte[],int,int)\nwill call\nwrite(int)\nfor every single byte in the array which can create a lot of overhead and is\nutterly inefficient. It is therefore strongly recommended that subclasses provide an efficient implementation of\nwrite(byte[],int,int)\n.\nThis rule raises an issue when a direct subclass of\njava.io.OutputStream\nor\njava.io.FilterOutputStream\ndoesn\u2019t provide an\noverride of\nwrite(byte[],int,int)\n.\nNoncompliant code example\n```java\npublic class MyStream extends OutputStream { // Noncompliant\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n```\nCompliant solution\n```java\npublic class MyStream extends OutputStream {\n    private FileOutputStream fout;\n\n    public MyStream(File file) throws IOException {\n        fout = new FileOutputStream(file);\n    }\n\n    @Override\n    public void write(int b) throws IOException {\n        fout.write(b);\n    }\n\n    @Override\n    public void write(byte[] b, int off, int len) throws IOException {\n        fout.write(b, off, len);\n    }\n\n    @Override\n    public void close() throws IOException {\n        fout.write(\"\\n\\n\".getBytes());\n        fout.close();\n        super.close();\n    }\n}\n```\nExceptions\nThis rule doesn\u2019t raise an issue when the class is declared\nabstract\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4288": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Spring components should use constructor injection\nDescription: Why is this an issue?\nSpring\n@Controller\n,\n@Service\n, and\n@Repository\nclasses are singletons by default, meaning only one instance\nof the class is ever instantiated in the application. Typically such a class might have a few\nstatic\nmembers, such as a logger, but all\nnon-static members should be managed by Spring and supplied via constructor injection rather than by field injection.\nThis rule raise an issue when any non-\nstatic\nmember of a Spring component has an injection annotation.\nNoncompliant code example\n```java\n@Controller\npublic class HelloWorld {\n\n  @Autowired\n  private String name = null; // Noncompliant\n\n}\n```\nCompliant solution\nAs of Spring 4.3\n```java\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n```\nBefore Spring 4.3\n```java\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @Autowired\n  HelloWorld(String name) {\n    this.name = name;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4276": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Functional Interfaces should be as specialised as possible\nDescription: Why is this an issue?\nThe\njava.util.function\npackage provides a large array of functional interface definitions for use in lambda expressions and method\nreferences. In general it is recommended to use the more specialised form to avoid auto-boxing. For instance\nIntFunction<Foo>\nshould be preferred over\nFunction<Integer, Foo>\n.\nThis rule raises an issue when any of the following substitution is possible:\nCurrent Interface\nPreferred Interface\nFunction<Integer, R>\nIntFunction<R>\nFunction<Long, R>\nLongFunction<R>\nFunction<Double, R>\nDoubleFunction<R>\nFunction<Double,Integer>\nDoubleToIntFunction\nFunction<Double,Long>\nDoubleToLongFunction\nFunction<Long,Double>\nLongToDoubleFunction\nFunction<Long,Integer>\nLongToIntFunction\nFunction<R,Integer>\nToIntFunction<R>\nFunction<R,Long>\nToLongFunction<R>\nFunction<R,Double>\nToDoubleFunction<R>\nFunction<T,T>\nUnaryOperator<T>\nBiFunction<T,T,T>\nBinaryOperator<T>\nConsumer<Integer>\nIntConsumer\nConsumer<Double>\nDoubleConsumer\nConsumer<Long>\nLongConsumer\nBiConsumer<T,Integer>\nObjIntConsumer<T>\nBiConsumer<T,Long>\nObjLongConsumer<T>\nBiConsumer<T,Double>\nObjDoubleConsumer<T>\nPredicate<Integer>\nIntPredicate\nPredicate<Double>\nDoublePredicate\nPredicate<Long>\nLongPredicate\nSupplier<Integer>\nIntSupplier\nSupplier<Double>\nDoubleSupplier\nSupplier<Long>\nLongSupplier\nSupplier<Boolean>\nBooleanSupplier\nUnaryOperator<Integer>\nIntUnaryOperator\nUnaryOperator<Double>\nDoubleUnaryOperator\nUnaryOperator<Long>\nLongUnaryOperator\nBinaryOperator<Integer>\nIntBinaryOperator\nBinaryOperator<Long>\nLongBinaryOperator\nBinaryOperator<Double>\nDoubleBinaryOperator\nFunction<T, Boolean>\nPredicate<T>\nBiFunction<T,U,Boolean>\nBiPredicate<T,U>\nNoncompliant code example\n```java\npublic class Foo implements Supplier<Integer> {  // Noncompliant\n    @Override\n    public Integer get() {\n      // ...\n    }\n}\n```\nCompliant solution\n```java\npublic class Foo implements IntSupplier {\n\n  @Override\n  public int getAsInt() {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4274": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Asserts should not be used to check the parameters of a public method\nDescription: Why is this an issue?\nAn\nassert\nis inappropriate for parameter validation because assertions can be disabled at runtime in the JVM, meaning that a bad\noperational setting would completely eliminate the intended checks. Further,\nassert\ns that fail throw\nAssertionError\ns, rather\nthan throwing some type of\nException\n. Throwing\nError\ns is completely outside of the normal realm of expected\ncatch\n/\nthrow\nbehavior in normal programs.\nThis rule raises an issue when a\npublic\nmethod uses one or more of its parameters with\nassert\ns.\nNoncompliant code example\n```java\npublic void setPrice(int price) {\n  assert price >= 0 && price <= MAX_PRICE;\n  // Set the price\n }\n```\nCompliant solution\n```java\npublic void setPrice(int price) {\n  if (price < 0 || price > MAX_PRICE) {\n    throw new IllegalArgumentException(\"Invalid price: \" + price);\n  }\n  // Set the price\n }\n```\nProgramming With Assertions\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4266": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream.collect()\" calls should not be redundant\nDescription: Why is this an issue?\nWhen using the\nStream\nAPI, call chains should be simplified as much as possible to improve readability and maintainability.\nThis rule raises an issue when one of the following substitution can be made:\nOriginal\nPreferred\nstream.collect(counting())\nstream.count()\nstream.collect(maxBy(comparator))\nstream.max(comparator)\nstream.collect(minBy(comparator))\nstream.min(comparator)\nstream.collect(mapping(mapper))\nstream.map(mapper).collect()\nstream.collect(reducing(...))\nstream.reduce(...)\nstream.collect(summingInt(mapper))\nstream.mapToInt(mapper).sum()\nstream.collect(summingLong(mapper))\nstream.mapToLong(mapper).sum()\nstream.collect(summingDouble(mapper))\nstream.mapToDouble(mapper).sum()\nNoncompliant code example\n```java\nint count = stream.collect(counting());  // Noncompliant\n```\nCompliant solution\n```java\nint count = stream.count();\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4248": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Regex patterns should not be created needlessly\nDescription: Why is this an issue?\nThe\njava.util.regex.Pattern.compile()\nmethods have a significant performance cost, and therefore should be used sensibly.\nMoreover they are the only mechanism available to create instances of the Pattern class, which are necessary to do any pattern matching using\nregular expressions. Unfortunately that can be hidden behind convenience methods like\nString.matches()\nor\nString.split()\n.\nIt is therefore somewhat easy to inadvertently repeatedly compile the same regular expression at great performance cost with no valid reason.\nThis rule raises an issue when:\n1. APatternis compiled from aStringliteral or constant and is not stored in a static final reference.\n2. String.matches,String.split,String.replaceAllorString.replaceFirstare invoked with aStringliteral or constant. In which case the code should be refactored to use ajava.util.regex.Patternwhile respecting\n  the previous rule.\nNoncompliant code example\n```java\npublic void doingSomething(String stringToMatch) {\n  Pattern regex = Pattern.compile(\"myRegex\");  // Noncompliant\n  Matcher matcher = regex.matcher(\"s\");\n  // ...\n  if (stringToMatch.matches(\"myRegex2\")) {  // Noncompliant\n    // ...\n  }\n}\n```\nCompliant solution\n```java\nprivate static final Pattern myRegex = Pattern.compile(\"myRegex\");\nprivate static final Pattern myRegex2 = Pattern.compile(\"myRegex2\");\n\npublic void doingSomething(String stringToMatch) {\n  Matcher matcher = myRegex.matcher(\"s\");\n  // ...\n  if (myRegex2.matcher(stringToMatch).matches()) {\n    // ...\n  }\n}\n```\nExceptions\nString.split\ndoesn\u2019t create a regex when the string passed as argument meets either of these 2 conditions:\n1. It is a one-char String and this character is not one of the RegEx\u2019s meta characters \".$|()[{^?*+\\\"\n2. It is a two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter.\nIn which case no issue will be raised.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4201": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Null checks should not be used with \"instanceof\"\nDescription: Why is this an issue?\nThere\u2019s no need to null test in conjunction with an\ninstanceof\ntest.\nnull\nis not an\ninstanceof\nanything, so\na null check is redundant.\nNoncompliant code example\n```java\nif (x != null && x instanceof MyClass) { ... }  // Noncompliant\n\nif (x == null || ! x instanceof MyClass) { ... } // Noncompliant\n```\nCompliant solution\n```java\nif (x instanceof MyClass) { ... }\n\nif (! x instanceof MyClass) { ... }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4174": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local constants should follow naming conventions for constants\nDescription: Why is this an issue?\nShared coding conventions allow teams to collaborate efficiently. This rule checks that all local,\nfinal\n, initialized, primitive\nvariables, have names that match a provided regular expression.\nNoncompliant code example\nWith the default regular expression\n^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\n:\n```java\npublic void doSomething() {\n  final int local = 42;\n  ...\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  final int LOCAL = 42;\n  ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4165": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Assignments should not be redundant\nDescription: Why is this an issue?\nThe transitive property says that if\na == b\nand\nb == c\n, then\na == c\n. In such cases, there\u2019s no point in\nassigning\na\nto\nc\nor vice versa because they\u2019re already equivalent.\nThis rule raises an issue when an assignment is useless because the assigned-to variable already holds the value on all execution paths.\nNoncompliant code example\n```java\na = b;\nc = a;\nb = c; // Noncompliant: c and b are already the same\n```\nCompliant solution\n```java\na = b;\nc = a;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4144": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not have identical implementations\nDescription: Why is this an issue?\nTwo methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which\nbecomes a maintenance burden.\n```java\nprivate final static String CODE = \"bounteous\";\n\npublic String calculateCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() {  // Noncompliant: duplicates calculateCode\n  doTheThing();\n  return CODE;\n}\n```\nIf the identical logic is intentional, the code should be refactored to avoid duplication. For example, by having both methods call the same method\nor by having one implementation invoke the other.\n```java\nprivate final static String CODE = \"bounteous\";\n\npublic String getCode() {\n  doTheThing();\n  return CODE;\n}\n\npublic String getName() { // The intent is clear\n  return getCode();\n}\n```\nExceptions\nMethods that are not accessors (getters and setters), with fewer than 2 statements are ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4087": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"close()\" calls should not be redundant\nDescription: Why is this an issue?\nJava 7\u2019s try-with-resources structure automatically handles closing the resources that the\ntry\nitself opens. Thus, adding an explicit\nclose()\ncall is redundant and potentially confusing.\nNoncompliant code example\n```java\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n  writer.close();  // Noncompliant\n}\n```\nCompliant solution\n```java\ntry (PrintWriter writer = new PrintWriter(process.getOutputStream())) {\n  String contents = file.contents();\n  writer.write(new Gson().toJson(new MyObject(contents)));\n  writer.flush();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4065": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ThreadLocal.withInitial\" should be preferred\nDescription: Why is this an issue?\nJava 8 introduced\nThreadLocal.withInitial\nwhich is a simpler alternative to creating an anonymous inner class to initialise a\nThreadLocal\ninstance.\nThis rule raises an issue when a\nThreadLocal\nanonymous inner class can be replaced by a call to\nThreadLocal.withInitial\n.\nNoncompliant code example\n```java\nThreadLocal<List<String>> myThreadLocal =\n    new ThreadLocal<List<String>>() { // Noncompliant\n        @Override\n        protected List<String> initialValue() {\n            return new ArrayList<String>();\n        }\n    };\n```\nCompliant solution\n```java\nThreadLocal<List<String>> myThreadLocal = ThreadLocal.withInitial(ArrayList::new);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4042": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"java.nio.Files#delete\" should be preferred\nDescription: Why is this an issue?\nWhen\njava.io.File#delete\nfails, this\nboolean\nmethod simply returns\nfalse\nwith no indication of the cause. On\nthe other hand, when\njava.nio.file.Files#delete\nfails, this\nvoid\nmethod returns one of a series of exception types to better\nindicate the cause of the failure. And since more information is generally better in a debugging situation,\njava.nio.file.Files#delete\nis\nthe preferred option.\nNoncompliant code example\n```java\npublic void cleanUp(Path path) {\n  File file = new File(path);\n  if (!file.delete()) {  // Noncompliant\n    //...\n  }\n}\n```\nCompliant solution\n```java\npublic void cleanUp(Path path) throws NoSuchFileException, DirectoryNotEmptyException, IOException {\n  Files.delete(path);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4034": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream\" call chains should be simplified when possible\nDescription: Why is this an issue?\nWhen using the\nStream\nAPI, call chains should be simplified as much as possible. Not only does it make the code easier to read, it\nalso avoid creating unnecessary temporary objects.\nThis rule raises an issue when one of the following substitution is possible:\nOriginal\nPreferred\nstream.filter(predicate).findFirst().isPresent()\nstream.anyMatch(predicate)\nstream.filter(predicate).findAny().isPresent()\nstream.anyMatch(predicate)\n!stream.anyMatch(predicate)\nstream.noneMatch(predicate)\n!stream.anyMatch(x -> !(...))\nstream.allMatch(...)\nstream.map(mapper).anyMatch(Boolean::booleanValue)\nstream.anyMatch(predicate)\nNoncompliant code example\n```java\nboolean hasRed = widgets.stream().filter(w -> w.getColor() == RED).findFirst().isPresent(); // Noncompliant\n```\nCompliant solution\n```java\nboolean hasRed = widgets.stream().anyMatch(w -> w.getColor() == RED);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4032": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Packages containing only \"package-info.java\" should be removed\nDescription: Why is this an issue?\nThere is no reason to have a package that is empty except for \"package-info.java\". Such packages merely clutter a project, taking up space but\nadding no value.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4030": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Collection contents should be used\nDescription: Why is this an issue?\nIf a collection is declared and populated but its values are never read anywhere in the code, it can be considered unused. This often arises from\nincomplete refactoring, copy-pasting errors, or typos. Unused collections can lead to wasted memory and degraded application performance.\nAdditionally, their presence makes the code harder to read and understand.\nHow to fix it\nRemove unused collection.\nCode examples\nNoncompliant code example\n```java\nint getLength(String a, String b, String c) {\n  List<String> strings = new ArrayList<>();  // Noncompliant: List is declared and populated but never read.\n  strings.add(a);\n  strings.add(b);\n  strings.add(c);\n\n  return a.length() + b.length() + c.length();\n}\n```\nCompliant solution\n```java\nint getLength(String a, String b, String c) {\n  return a.length() + b.length() + c.length();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-4011": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of disallowed constructors\nDescription: Why is this an issue?\nThis rule allows banning usage of certain constructors.\nNoncompliant code example\nGiven parameters:\n1. className: java.util.Date\n2. argumentTypes: java.lang.String\n```java\nDate birthday;\nbirthday = new Date(\"Sat Sep 27 05:42:21 EDT 1986\");  // Noncompliant\nbirthday = new Date(528176541000L); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3985": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused \"private\" classes should be removed\nDescription: This rule raises an issue when a private nested class is never used.\nWhy is this an issue?\nprivate\nclasses that are never used are dead code: unnecessary, inoperative code that should be removed. Cleaning out dead code\ndecreases the size of the maintained codebase, making it easier to understand the program and preventing bugs from being introduced.\nCode examples\nNoncompliant code example\n```java\npublic class TopLevel\n{\n  private class Nested {...} // Noncompliant: Nested is never used\n}\n```\nCompliant solution\n```java\npublic class TopLevel\n{\n  void doSomething() {\n    Nested a = new Nested();\n    ...\n  }\n  private class Nested {...}\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3973": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A conditionally executed single line should be denoted by indentation\nDescription: Why is this an issue?\nWhen the line immediately after a conditional has neither curly braces nor indentation, the intent of the code is unclear and perhaps not what is\nexecuted. Additionally, such code is confusing to maintainers.\n```java\nif (condition)  // Noncompliant\ndoTheThing();\ndoTheOtherThing(); // Was the intent to call this function unconditionally?\n```\nIt becomes even more confusing and bug-prone if lines get commented out.\n```java\nif (condition)  // Noncompliant\n//  doTheThing();\ndoTheOtherThing(); // Was the intent to call this function conditionally?\n```\nIndentation alone or together with curly braces makes the intent clear.\n```java\nif (condition)\n  doTheThing();\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n\n// or\n\nif (condition) {\n  doTheThing();\n}\ndoTheOtherThing(); // Clear intent to call this function unconditionally\n```\nThis rule raises an issue if the line controlled by a conditional has the same indentation as the conditional and is not enclosed in curly\nbraces.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3972": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Conditionals should start on new lines\nDescription: Why is this an issue?\nPlacing an\nif\nstatement on the same line as the closing\n}\nfrom a preceding\nif\n,\nelse\n, or\nelse if\nblock can lead to confusion and potential errors. It may indicate a missing\nelse\nstatement or create ambiguity for\nmaintainers who might fail to understand that the two statements are unconnected.\nThe following code snippet is confusing:\n```java\nif (condition1) {\n  // ...\n} if (condition2) {  // Noncompliant\n  //...\n}\n```\nEither the two conditions are unrelated and they should be visually separated:\n```java\nif (condition1) {\n  // ...\n}\n\nif (condition2) {\n  //...\n}\n```\nOr they were supposed to be exclusive and you should use\nelse if\ninstead:\n```java\nif (condition1) {\n  // ...\n} else if (condition2) {\n  //...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3937": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Number patterns should be regular\nDescription: Why is this an issue?\nThe use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus\n1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error.\nThis rule raises an issue when underscores (\n_\n) are used to break a number into irregular subgroups.\nNoncompliant code example\n```java\nint thousand = 100_0;\nint tenThousand = 100_00;\nint million = 1_000_00_000;\n```\nCompliant solution\n```java\nint thousand = 1000;\nint tenThousand = 10_000;\nint tenThousandWithout = 10000;\nint duos = 1_00_00;\nint million = 100_000_000;\n```\nExceptions\nNo issue will be raised on binary numbers (starting with\n0b\nor\n0B\n). Binary number bits are often grouped corresponding to\ncertain meanings, resulting in irregular bit group sizes.\n```java\nint configValue1 = 0b00_000_10_1; // Compliant\nint configValue2 = 0B00_000_10_1; // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3878": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arrays should not be created for varargs parameters\nDescription: Why is this an issue?\nThere\u2019s no point in creating an array solely for the purpose of passing it as a varargs (\n...\n) argument; varargs\nis\nan array.\nSimply pass the elements directly. They will be consolidated into an array automatically. Incidentally passing an array where\nObject ...\nis expected makes the intent ambiguous: Is the array supposed to be one object or a collection of objects?\nNoncompliant code example\n```java\npublic void callTheThing() {\n  //...\n  doTheThing(new String[] { \"s1\", \"s2\"});  // Noncompliant: unnecessary\n  doTheThing(new String[12]);  // Compliant\n  doTheOtherThing(new String[8]);  // Noncompliant: ambiguous\n  // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n```\nCompliant solution\n```java\npublic void callTheThing() {\n  //...\n  doTheThing(\"s1\", \"s2\");\n  doTheThing(new String[12]);\n  doTheOtherThing((Object[]) new String[8]);\n   // ...\n}\n\npublic void doTheThing (String ... args) {\n  // ...\n}\n\npublic void doTheOtherThing(Object ... args) {\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3864": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Stream.peek\" should be used with caution\nDescription: Why is this an issue?\nAccording to its JavaDocs, the intermediate Stream operation\njava.util.Stream.peek()\n\u201cexists mainly to support debugging\u201d\npurposes.\nA key difference with other intermediate Stream operations is that the Stream implementation is free to skip calls to\npeek()\nfor\noptimization purpose. This can lead to\npeek()\nbeing unexpectedly called only for some or none of the elements in the Stream.\nAs a consequence, relying on\npeek()\nwithout careful consideration can lead to error-prone code.\nThis rule raises an issue for each use of peek() to be sure that it is challenged and validated by the team to be meant for production\ndebugging/logging purposes.\nNoncompliant code example\n```java\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -> e.length() > 3)\n         .peek(e -> System.out.println(\"Filtered value: \" + e)); // Noncompliant\n```\nCompliant solution\n```java\nStream.of(\"one\", \"two\", \"three\", \"four\")\n         .filter(e -> e.length() > 3)\n         .foreach(e -> System.out.println(\"Filtered value: \" + e));\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3824": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Map.get\" and value test should be replaced with single method call\nDescription: Why is this an issue?\nIt\u2019s a common pattern to test the result of a\njava.util.Map.get()\nagainst\nnull\nor calling\njava.util.Map.containsKey()\nbefore proceeding with adding or changing the value in the map. However the\njava.util.Map\nAPI\noffers a significantly better alternative in the form of the\ncomputeIfPresent()\nand\ncomputeIfAbsent()\nmethods. Using these\ninstead leads to cleaner and more readable code.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis not 8.\nNoncompliant code example\n```java\nV value = map.get(key);\nif (value == null) {  // Noncompliant\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nif (!map.containsKey(key)) {  // Noncompliant\n  value = V.createFor(key);\n  if (value != null) {\n    map.put(key, value);\n  }\n}\nreturn value;\n```\nCompliant solution\n```java\nreturn map.computeIfAbsent(key, k -> V.createFor(k));\n```\nExceptions\nThis rule will not raise an issue when trying to add\nnull\nto a map, because\ncomputeIfAbsent\nwill not add the entry if the\nvalue returned by the function is\nnull\n.\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3776": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Cognitive Complexity of methods should not be too high\nDescription: This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.\nWhy is this an issue?\nCognitive Complexity is a measure of how hard it is to understand the control flow of a unit of code. Code with high cognitive complexity is hard\nto read, understand, test, and modify.\nAs a rule of thumb, high cognitive complexity is a sign that the code should be refactored into smaller, easier-to-manage pieces.\nWhich syntax in code does impact cognitive complexity score?\nHere are the core concepts:\n1. Cognitive complexity is incremented each time the code breaks the normal linear reading flow.This concerns, for example,\n  loop structures, conditionals, catches, switches, jumps to labels, and conditions mixing multiple operators.\n2. Each nesting level increases complexity.During code reading, the deeper you go through nested layers, the harder it\n  becomes to keep the context in mind.\n3. Method calls are freeA well-picked method name is a summary of multiple lines of code. A reader can first explore a\n  high-level view of what the code is performing then go deeper and deeper by looking at called functions content.Note:This does not\n  apply to recursive calls, those will increment cognitive score.\nThe method of computation is fully detailed in the pdf linked in the resources.\nExceptions\nequals\nand\nhashCode\nmethods are ignored because they might be automatically generated and might end up being difficult to\nunderstand, especially in the presence of many fields.\nHow to fix it\nReducing cognitive complexity can be challenging.\nHere are a few suggestions:\n1. Extract complex conditions in a new function.Mixed operators in condition will increase complexity. Extracting the\n  condition in a new function with an appropriate name will reduce cognitive load.\n2. Break down large functions.Large functions can be hard to understand and maintain. If a function is doing too many\n  things, consider breaking it down into smaller, more manageable functions. Each function should have a single responsibility.\n3. Avoid deep nesting by returning early.To avoid the nesting of conditions, process exceptional cases first and return\n  early.\nCode examples\nExtraction of a complex condition in a new function.\nNoncompliant code example\nThe code is using a complex condition and has a cognitive cost of 3.\n```java\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (user.hasMembership()                            // +1 (if)\n    && user.ordersCount() > 10                        // +1 (more than one condition)\n    && user.isAccountActive()\n    && !user.hasDiscount()\n    || user.ordersCount() == 1) {                    // +1 (change of operator in condition)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n```\nCompliant solution\nEven if the cognitive complexity of the whole program did not change, it is easier for a reader to understand the code of the\ncalculateFinalPrice\nfunction, which now only has a cognitive cost of 1.\n```java\ndouble calculateFinalPrice(User user, Cart cart) {\n  double total = calculateTotal(cart);\n  if (isEligibleForDiscount(user)) {                  // +1 (if)\n    total = applyDiscount(user, total);\n  }\n  return total;\n}\n\nboolean isEligibleForDiscount(User user) {\n  return user.hasMembership()\n    && user.ordersCount() > 10                        // +1 (more than one condition)\n    && user.isAccountActive()\n    && !user.hasDiscount()\n    || user.ordersCount() == 1;                       // +1 (change of operator in condition)\n}\n```\nBreak down large functions.\nNoncompliant code example\nFor example, consider a function that calculates the total price of a shopping cart, including sales tax and shipping.\nNote:\nThe code\nis simplified here, to illustrate the purpose. Please imagine there is more happening in the\nfor\nloops.\n```java\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n\n  // calculateSalesTax\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n\n  //calculateShipping\n  total += 5 * cart.items().size();\n\n  return total;\n}\n```\nThis function could be refactored into smaller functions: The complexity is spread over multiple functions and the complex\ncalculateTotal\nhas now a complexity score of zero.\nCompliant solution\n```java\ndouble calculateTotal(Cart cart) {\n  double total = 0;\n  total = calculateSubtotal(cart, total);\n  total += calculateSalesTax(cart, total);\n  total += calculateShipping(cart, total);\n\n  return total;\n}\n\ndouble calculateShipping(Cart cart, double total) {\n  total += 5 * cart.items().size();\n  return total;\n}\n\ndouble calculateSalesTax(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += 0.2 * item.price;\n  }\n  return total;\n}\n\ndouble calculateSubtotal(Cart cart, double total) {\n  for (Item item : cart.items()) {       // +1 (for)\n    total += item.price;\n  }\n  return total;\n}\n```\nAvoid deep nesting by returning early.\nNoncompliant code example\nThe below code has a cognitive complexity of 6.\n```java\ndouble calculateDiscount(double price, User user) {\n  if (isEligibleForDiscount(user)) {      // +1 ( if )\n    if (user.hasMembership()) {           // +2 ( nested if )\n      return price * 0.9;\n    } else if (user.ordersCount() == 1) { // +1 ( else )\n      return price * 0.95;\n    } else {                              // +1 ( else )\n      return price;\n    }\n  } else {                                // +1 ( else )\n    return price;\n  }\n}\n```\nCompliant solution\nChecking for the edge case first flattens the\nif\nstatements and reduces the cognitive complexity to 3.\n```java\ndouble calculateDiscount(double price, User user) {\n  if (!isEligibleForDiscount(user)) {     // +1 ( if )\n    return price;\n  }\n  if (user.hasMembership()) {             // +1\n    return price * 0.9;\n  }\n  if (user.ordersCount() == 1) {          // +1 ( if )\n    return price * 0.95;\n  }\n  return price;\n}\n```\nPitfalls\nAs this code is complex, ensure that you have unit tests that cover the code before refactoring.\nDocumentation\n1. Sonar -Cognitive Complexity\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3751": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@RequestMapping\" methods should not be \"private\"\nDescription: Why is this an issue?\nA method with a\n@RequestMapping\nannotation part of a class annotated with\n@Controller\n(directly or indirectly through a\nmeta annotation -\n@RestController\nfrom Spring Boot is a good example) will be called to handle matching web requests. That will happen\neven if the method is\nprivate\n, because Spring invokes such methods via reflection, without checking visibility.\nSo marking a sensitive method\nprivate\nmay seem like a good way to control how such code is called. Unfortunately, not all Spring\nframeworks ignore visibility in this way. For instance, if you\u2019ve tried to control web access to your sensitive,\nprivate\n,\n@RequestMapping\nmethod by marking it\n@Secured\n\u2026\u200b it will still be called, whether or not the user is authorized to access\nit. That\u2019s because AOP proxies are not applied to private methods.\nIn addition to\n@RequestMapping\n, this rule also considers the annotations introduced in Spring Framework 4.3:\n@GetMapping\n,\n@PostMapping\n,\n@PutMapping\n,\n@DeleteMapping\n,\n@PatchMapping\n.\nNoncompliant code example\n```java\n@RequestMapping(\"/greet\", method = GET)\nprivate String greet(String greetee) {  // Noncompliant\n```\nCompliant solution\n```java\n@RequestMapping(\"/greet\", method = GET)\npublic String greet(String greetee) {\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3749": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Members of Spring components should be injected\nDescription: Why is this an issue?\nSpring\n@Component\n,\n@Controller\n,\n@RestController\n,\n@Service\n, and\n@Repository\nclasses\nare singletons by default, meaning only one instance of the class is ever instantiated in the application. Typically such a class might have a few\nstatic\nmembers, such as a logger, but all non-\nstatic\nmembers should be managed by Spring.\nThis rule raises an issue when a singleton\n@Component\n,\n@Controller\n,\n@RestController\n,\n@Service\n,\nor\n@Repository\n, not annotated with\n@ConfigurationProperties\n, has non-\nstatic\nmembers that are not annotated with\none of:\n1. org.springframework.beans.factory.annotation.Autowired\n2. org.springframework.beans.factory.annotation.Value\n3. javax.annotation.Inject\n4. javax.annotation.Resource\n5. javax.persistence.PersistenceContext\n6. jakarta.annotation.Resource\n7. jakarta.inject.Inject\n8. jakarta.persistence.PersistenceContext\nHow to fix it\nAdd one of these annotations to all non-\nstatic\nmembers:\n@Resource\n,\n@Inject\n,\n@Autowired\nor\n@Value\n.\nCode examples\nNoncompliant code example\n```java\n@Controller\npublic class HelloWorld {\n\n  private String name = null;\n\n  @RequestMapping(\"/greet\", method = GET)\n  public String greet(String greetee) {\n\n    if (greetee != null) {\n      this.name = greetee;\n    }\n\n    return \"Hello \" + this.name;  // if greetee is null, you see the previous user's data\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3740": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Raw types should not be used\nDescription: Generic types should not be used raw (without type arguments). To fix this issue, add the type parameters.\nWhy is this an issue?\nA generic type is a generic class or interface that is parameterized over types. For example,\njava.util.List\nhas one type parameter:\nthe type of its elements.\nUsing generic types raw (without binding arguments to the type parameters) prevents compile-time type checking for expressions that use these type\nparameters. Explicit type casts are necessary for them, which do perform a runtime type check that may fail with a\nClassCastException\n.\nWhat is the potential impact?\nThe compiler cannot assert that the program is inherently type safe. When a cast fails, a\nClassCastException\nis thrown during runtime\nand the program most likely crashes. Therefore, this issue might impact the availability and reliability of your application.\nExceptions\nThe rule does not raise an issue for the simple\ninstanceof\noperator, which checks against runtime types where type parameter\ninformation has been erased. Since it does not return a rawly typed instance but a boolean value, it does not prevent compile-time type checking.\nThis, however, is not the case for the\ncast\noperator as well as the extended\ninstanceof\noperator which are both not an\nexception from this rule. Since they operate on the erased runtime type as well, they must use wildcard type arguments when checked against a\nparameterized type (see the examples).\nHow to fix it\nFor any usage of parameterized types, bind the type parameters with type arguments. For example, when a function returns a list of strings, the\nreturn type is\nList<String>\n, where the type parameter\nE\nin interface\nList<E>\nis bound with the\nargument\nString\n.\nIf the concrete binding is unknown, you still should not use the type raw. Use a wildcard type argument instead, with optional lower or upper\nbound, such as in\nList<?>\nfor a list whose element type is unknown, or\nList<? extends Number>\nfor a list whose\nelement type is\nNumber\nor a subtype of it.\nCode examples\nNoncompliant code example\n```java\n// List is supposed to store integers only\nList integers = new ArrayList<>();\n\n// Yet, we can add strings, because we did not give\n// this information to the compiler\nintegers.add(\"Hello World!\");\n\n// Type is checked during runtime and will throw a ClassCastException\nInteger a = (Integer) integers.get(0);\n```\nCompliant solution\n```java\n// List is supposed to store integers, and we let the compiler know\nList<Integer> integers = new ArrayList<>();\n\n// Now we can add only integers.\n// Adding a string results in a compile time error.\nintegers.add(42);\n\n// No cast required anymore, and no possible ClassCastException\nInteger a = integers.get(0);\n```\nNoncompliant code example\n```java\nString getStringFromForcedList(Object object) {\n  // Cast expression and instanceof can check runtime type only.\n  // The solution is _not_ to skip the type argument in that case.\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n```\nCompliant solution\n```java\nString getStringFromForcedList(Object object) {\n  // The solution is to use a wildcard type argument in that case.\n  return object instanceof List<?> stringList ? (String) stringList.getFirst(): \"\";\n}\n```\nNoncompliant code example\n```java\nString getStringFromForcedList(Object object) {\n  return object instanceof List stringList ? (String) stringList.getFirst(): \"\";\n}\n\nString returnString() {\n  Object object = List.of(\"Hello\");\n  return getStringFromForcedList(object);\n}\n```\nCompliant solution\n```java\nObject getObjectFromForcedList(Object object) {\n  // You may also choose not to make assumptions about type arguments you cannot infer.\n  return object instanceof List<?> list ? list.getFirst(): \"\";\n}\n\nString returnString(Object object) {\n  // Instead, delegate the decision to use-site, which may have more information.\n  Object object = List.of(\"Hello\");\n  return (String) getObjectFromForcedList(object);\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3725": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Java 8's \"Files.exists\" should not be used\nDescription: Why is this an issue?\nThe\nFiles.exists\nmethod has noticeably poor performance in JDK 8, and can slow an application significantly when used to check files\nthat don\u2019t actually exist.\nThe same goes for\nFiles.notExists\n,\nFiles.isDirectory\nand\nFiles.isRegularFile\nfrom\njava.nio.file\npackage.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis not 8.\nNoncompliant code example\n```java\nPath myPath;\nif(java.nio.file.Files.exists(myPath)) {  // Noncompliant\n // do something\n}\n```\nCompliant solution\n```java\nPath myPath;\nif(myPath.toFile().exists())) {\n // do something\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3688": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of disallowed classes\nDescription: Why is this an issue?\nThis rule allows banning certain classes.\nNoncompliant code example\nGiven parameters:\n1. className:java.lang.String\n```java\nString name;  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3658": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unit tests should throw exceptions\nDescription: Why is this an issue?\nWhen the code under test in a unit test throws an exception, the test itself fails. Therefore, there is no need to surround the tested code with a\ntry\n-\ncatch\nstructure to detect failure. Instead, you can simply move the exception type to the method signature.\nThis rule raises an issue when there is a fail assertion inside a\ncatch\nblock.\nSupported frameworks:\n1. JUnit3\n2. JUnit4\n3. JUnit5\n4. Fest assert\n5. AssertJ\nNoncompliant code example\n```java\n@Test\npublic void testMethod() {\n  try {\n            // Some code\n  } catch (MyException e) {\n    Assert.fail(e.getMessage());  // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\n@Test\npublic void testMethod() throws MyException {\n    // Some code\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3631": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Arrays.stream\" should be used for primitive arrays\nDescription: Why is this an issue?\nFor arrays of objects,\nArrays.asList(T ... a).stream()\nand\nArrays.stream(array)\nare basically equivalent in terms of\nperformance. However, for arrays of primitives, using\nArrays.asList\nwill force the construction of a list of boxed types, and then use\nthat\nlist as a stream. On the other hand,\nArrays.stream\nuses the appropriate primitive stream type (\nIntStream\n,\nLongStream\n,\nDoubleStream\n) when applicable, with much better performance.\nNoncompliant code example\n```java\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nArrays.asList(1, 2, 3, 4).stream() // Noncompliant\n    .filter(...)\n    .forEach(...);\n```\nCompliant solution\n```java\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\").stream()\n    .filter(...)\n    .forEach(...);\n\nint[] intArray = new int[]{1, 2, 3, 4};\nArrays.stream(intArray)\n    .filter(...)\n    .forEach(...);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3626": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Jump statements should not be redundant\nDescription: Why is this an issue?\nJump statements such as\nreturn\nand\ncontinue\nlet you change the default flow of program execution, but jump statements\nthat direct the control flow to the original direction are just a waste of keystrokes.\nNoncompliant code example\n```java\npublic void foo() {\n  while (condition1) {\n    if (condition2) {\n      continue; // Noncompliant\n    } else {\n      doTheThing();\n    }\n  }\n  return; // Noncompliant; this is a void method\n}\n```\nCompliant solution\n```java\npublic void foo() {\n  while (condition1) {\n    if (!condition2) {\n      doTheThing();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3578": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test methods should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test method name does not match the provided\nregular expression.\nNoncompliant code example\nWith the default value:\n^test[A-Z][a-zA-Z0-9]*$\n```java\n@Test\npublic void foo() {  // Noncompliant\n  //...\n}\n```\nCompliant solution\n```java\n@Test\npublic void testFoo() {\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3577": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test classes should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently. This rule raises an issue when a test class name does not match the provided\nregular expression.\nNoncompliant code example\nWith the default value:\n^((Test|IT)[a-zA-Z0-9_]+|[A-Z][a-zA-Z0-9_]*(Test|Tests|TestCase|IT|ITCase))$\n```java\nclass Foo {  // Noncompliant\n  @Test\n  void check() {  }\n}\n\nclass Bar {  // Noncompliant\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n```\nCompliant solution\n```java\nclass FooTest {\n  @Test\n  void check() {  }\n}\n\nclass BarIT {\n  @Nested\n  class PositiveCase {\n    @Test\n    void check() {  }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3553": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Optional\" should not be used for parameters\nDescription: Why is this an issue?\nThe Java language authors have been quite frank that\nOptional\nwas intended for use only as a return type, as a way to convey that a\nmethod may or may not return a value.\nAnd for that, it\u2019s valuable but using\nOptional\non the input side increases the work you have to do in the method without really\nincreasing the value. With an\nOptional\nparameter, you go from having 2 possible inputs: null and not-null, to three: null,\nnon-null-without-value, and non-null-with-value. Add to that the fact that overloading has long been available to convey that some parameters are\noptional, and there\u2019s really no reason to have\nOptional\nparameters.\nThe rule also checks for Guava\u2019s\nOptional\n, as it was the inspiration for the JDK\nOptional\n. Although it is different in\nsome aspects (serialization, being recommended for use as collection elements), using it as a parameter type causes exactly the same problems as for\nJDK\nOptional\n.\nNoncompliant code example\n```java\npublic String sayHello(Optional<String> name) {  // Noncompliant\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n```\nCompliant solution\n```java\npublic String sayHello(String name) {\n  if (name == null) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n```\nExceptions\nNo issues will be raised if a method is overriding, as the developer has no control over the signature at this point.\n```java\n@Override\npublic String sayHello(Optional<String> name) {\n  if (name == null || !name.isPresent()) {\n    return \"Hello World\";\n  } else {\n    return \"Hello \" + name;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3516": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods returns should not be invariant\nDescription: Why is this an issue?\nWhen a method is designed to return an invariant value, it may be poor design, but it shouldn\u2019t adversely affect the outcome of your program.\nHowever, when it happens on all paths through the logic, it is surely a bug.\nThis rule raises an issue when a method contains several\nreturn\nstatements that all return the same value.\nNoncompliant code example\n```java\nint foo(int a) {\n  int b = 12;\n  if (a == 1) {\n    return b;\n  }\n  return b;  // Noncompliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3457": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Format strings should be used correctly\nDescription: Why is this an issue?\nA\nprintf-\n-style format string is a string that contains placeholders, usually represented by special characters such as \"%s\" or \"{}\",\ndepending on the technology in use. These placeholders are replaced by values when the string is printed or logged.\nBecause\nprintf\n-style format strings are interpreted at runtime, rather than validated by the compiler, they can contain errors that\nresult in the wrong strings being created.\nThis rule checks whether every format string specifier can be correctly matched with one of the additional arguments when calling the following\nmethods:\n1. java.lang.String#format\n2. java.util.Formatter#format\n3. java.io.PrintStream#format\n4. java.text.MessageFormat#format\n5. java.io.PrintWriter#format\n6. java.io.PrintStream#printf\n7. java.io.PrintWriter#printf\n8. java.lang.String#formatted(since Java 15)\n9. logging methods oforg.slf4j.Logger,java.util.logging.Logger,org.apache.logging.log4j.Logger.\nHow to fix it\nA\nprintf-\n-style format string is a string that contains placeholders, which are replaced by values when the string is printed or\nlogged. Mismatch in the format specifiers and the arguments provided can lead to incorrect strings being created.\nTo avoid issues, a developer should ensure that the provided arguments match format specifiers.\nNote that\nMessageFormat\nis used by most\nlogging mechanisms, for example\njava.util.logging.Logger\n, thus the\nsingle quote\nmust be escaped by a\ndouble single\nquote\n.\nCode examples\nNoncompliant code example\n```java\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2, 3); // Noncompliant - the third argument '3' is unused\n    String.format(\"First {0} and then {1}\", \"foo\", \"bar\");  //Noncompliant - it appears there is confusion with the use of \"java.text.MessageFormat\" - parameters \"foo\" and \"bar\" will be ignored here\n\n\n    slf4jLog.debug(\"The number: \", 1); // Noncompliant - String contains no format specifiers.\n\n    logger.log(level, \"Can't load library \\\"{0}\\\"!\", \"foo\"); // Noncompliant - the single quote ' must be escaped\n}\n```\nCompliant solution\n```java\nvoid logging(org.slf4j.Logger slf4jLog, java.util.logging.Logger logger) {\n    String.format(\"Too many arguments %d and %d\", 1, 2);\n    String.format(\"First %s and then %s\", \"foo\", \"bar\");\n\n    slf4jLog.debug(\"The number: {}\", 1);\n\n    logger.log(level, \"Can''t load library \\\"{0}\\\"!\", \"foo\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3437": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Value-based objects should not be serialized\nDescription: Why is this an issue?\nAccording to the documentation,\nA program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly\n  via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization\u2026\u200b\nFor example (credit to Brian Goetz), imagine Foo is a value-based class:\n```java\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = new Foo(0);\n```\nSerialization promises that on deserialization of arr, elements 0 and 1 will not be aliased. Similarly, in:\n```java\nFoo[] arr = new Foo[2];\narr[0] = new Foo(0);\narr[1] = arr[0];\n```\nSerialization promises that on deserialization of\narr\n, elements 0 and 1\nwill\nbe aliased.\nWhile these promises are coincidentally fulfilled in current implementations of Java, that is not guaranteed in the future, particularly when true\nvalue types are introduced in the language.\nThis rule raises an issue when a\nSerializable\nclass defines a non-transient, non-static field field whose type is a known serializable\nvalue-based class. Known serializable value-based classes are: all the classes in the\njava.time\npackage except\nClock\n; the\ndate classes for alternate calendars:\nHijrahDate\n,\nJapaneseDate\n,\nMinguoDate\n,\nThaiBuddhistDate\n.\nNoncompliant code example\n```java\nclass MyClass implements Serializable {\n  private HijrahDate date;  // Noncompliant; mark this transient\n  // ...\n}\n```\nCompliant solution\n```java\nclass MyClass implements Serializable {\n  private transient HijrahDate date;\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3416": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loggers should be named for their enclosing classes\nDescription: Why is this an issue?\nIt is convention to name each class\u2019s logger for the class itself. Doing so allows you to set up clear, communicative logger configuration. Naming\nloggers by some other convention confuses configuration, and using the same class name for multiple class loggers prevents the granular configuration\nof each class' logger. Some libraries, such as SLF4J warn about this, but not all do.\nThis rule raises an issue when a logger is not named for its enclosing class.\nNoncompliant code example\n```java\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(WrongClass.class);  // Noncompliant; multiple classes using same logger\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n  private final static Logger LOG = LoggerFactory.getLogger(MyClass.class);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3415": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Assertion arguments should be passed in the correct order\nDescription: Why is this an issue?\nThe standard assertions library methods such as\norg.junit.Assert.assertEquals\n, and\norg.junit.Assert.assertSame\nexpect the\nfirst argument to be the expected value and the second argument to be the actual value. For AssertJ instead, the argument of\norg.assertj.core.api.Assertions.assertThat\nis the actual value, and the subsequent calls contain the expected values.\nWhat is the potential impact?\nHaving the expected value and the actual value in the wrong order will not alter the outcome of tests, (succeed/fail when it should) but the error\nmessages will contain misleading information.\nThis rule raises an issue when the actual argument to an assertions library method is a hard-coded value and the expected argument is not.\nHow to fix it\nYou should provide the assertion methods with a hard-coded value as the expected value, while the actual value of the assertion should derive from\nthe portion of code that you want to test.\nSupported frameworks:\n1. JUnit4\n2. JUnit5\n3. AssertJ\nCode examples\nNoncompliant code example\n```java\norg.junit.Assert.assertEquals(runner.exitCode(), 0, \"Unexpected exit code\");  // Noncompliant; Yields error message like: Expected:<-1>. Actual:<0>.\norg.assertj.core.api.Assertions.assertThat(0).isEqualTo(runner.exitCode()); // Noncompliant\n```\nCompliant solution\n```java\norg.junit.Assert.assertEquals(0, runner.exitCode(), \"Unexpected exit code\");\norg.assertj.core.api.Assertions.assertThat(runner.exitCode()).isEqualTo(0);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3414": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tests should be kept in a dedicated source directory\nDescription: Why is this an issue?\nIt is a good practice to isolate test classes in a separate package so that what is shipped to production is neither polluted by nor bloated with\nthem. Further, including unit tests in code assemblies could affect build processes.\nThis rule raises an issue when test classes are found in projects containing non-test-related code.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3400": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not return constants\nDescription: Why is this an issue?\nThere\u2019s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a\nmethod call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.\nThis rule raises an issue if on methods that contain only one statement: the\nreturn\nof a constant value.\nNoncompliant code example\n```java\nint getBestNumber() {\n  return 12;  // Noncompliant\n}\n```\nCompliant solution\n```java\nstatic final int BEST_NUMBER = 12;\n```\nExceptions\nThe following types of method are ignored:\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3398": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"private\" methods called only by inner classes should be moved to those classes\nDescription: Why is this an issue?\nWhen a\nprivate\nmethod is only invoked by an inner class, there\u2019s no reason not to move it into that class. It will still have the same\naccess to the outer class' members, but the outer class will be clearer and less cluttered.\nNoncompliant code example\n```java\npublic class Outie {\n  private int i=0;\n\n  private void increment() {  // Noncompliant\n    i++;\n  }\n\n  public class Innie {\n    public void doTheThing() {\n      Outie.this.increment();\n    }\n  }\n}\n```\nCompliant solution\n```java\npublic class Outie {\n  private int i=0;\n\n  public class Innie {\n    public void doTheThing() {\n      increment();\n    }\n\n    private void increment() {\n      Outie.this.i++;\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3366": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"this\" should not be exposed from constructors\nDescription: Why is this an issue?\nIn single-threaded environments, the use of\nthis\nin constructors is normal, and expected. But in multi-threaded environments, it could\nexpose partially-constructed objects to other threads, and should be used with caution.\nThe classic example is a class with a\nstatic\nlist of its instances. If the constructor stores\nthis\nin the list, another\nthread could access the object before it\u2019s fully-formed. Even when the storage of\nthis\nis the last instruction in the constructor,\nthere\u2019s still a danger if the class is not\nfinal\n. In that case, the initialization of subclasses won\u2019t be complete before\nthis\nis exposed.\nThis rule raises an issue when\nthis\nis assigned to any globally-visible object in a constructor, and when it is passed to the method\nof another object in a constructor\nNoncompliant code example\n```java\npublic class Monument {\n\n  public static final List<Monument> ALL_MONUMENTS = new ArrayList()<>;\n  // ...\n\n  public Monument(String location, ...) {\n    ALL_MONUMENTS.add(this);  // Noncompliant; passed to a method of another object\n\n    this.location = location;\n    // ...\n  }\n}\n```\nExceptions\nThis rule ignores instances of assigning\nthis\ndirectly to a\nstatic\nfield of the same class because that case is covered\nby {rule:java:S3010} .\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3358": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Ternary operators should not be nested\nDescription: Why is this an issue?\nNested ternaries are hard to read and can make the order of operations complex to understand.\n```java\npublic String getReadableStatus(Job j) {\n  return j.isRunning() ? \"Running\" : j.hasErrors() ? \"Failed\" : \"Succeeded\";  // Noncompliant\n}\n```\nInstead, use another line to express the nested operation in a separate statement.\n```java\npublic String getReadableStatus(Job j) {\n  if (j.isRunning()) {\n    return \"Running\";\n  }\n  return j.hasErrors() ? \"Failed\" : \"Succeeded\";\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3305": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Factory method injection should be used in \"@Configuration\" classes\nDescription: Why is this an issue?\nWhen\n@Autowired\nis used, dependencies need to be resolved when the class is instantiated, which may cause early initialization of\nbeans or lead the context to look in places it shouldn\u2019t to find the bean. To avoid this tricky issue and optimize the way the context loads,\ndependencies should be requested as late as possible. That means using parameter injection instead of field injection for dependencies that are only\nused in a single\n@Bean\nmethod.\nNoncompliant code example\n```java\n@Configuration\npublic class \u200bFooConfiguration {\n\n  @Autowired private \u200bDataSource dataSource\u200b\u037e  // Noncompliant\n\n  @Bean\n  public \u200bMyService myService() {\n    return new \u200bMyService(this\u200b.dataSource\u200b)\u037e\n  }\n}\n```\nCompliant solution\n```java\n@Configuration\npublic class \u200bFooConfiguration {\n\n @Bean\n  public \u200bMyService myService(DataSource dataSource) {\n    return new \u200bMyService(dataSource)\u037e\n  }\n}\n```\nExceptions\nFields used in methods that are called directly by other methods in the application (as opposed to being invoked automatically by the Spring\nframework) are ignored by this rule so that direct callers don\u2019t have to provide the dependencies themselves.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3254": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Default annotation parameter values should not be passed as arguments\nDescription: Why is this an issue?\nSpecifying the default value for an annotation parameter is redundant. Such values should be omitted in the interests of readability.\nNoncompliant code example\n```java\n@MyAnnotation(arg = \"def\")  // Noncompliant\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n```\nCompliant solution\n```java\n@MyAnnotation\npublic class MyClass {\n  // ...\n}\npublic @interface MyAnnotation {\n  String arg() default \"def\";\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3252": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"static\" base class members should not be accessed via derived types\nDescription: Why is this an issue?\nIn object-oriented programming, inappropriately accessing static members of a base class via derived types is considered a code smell.\nStatic members are associated with the class itself, not with any specific instance of the class or its children classes. Accessing through the\nwrong type suggests a misunderstanding of the ownership and role of this member. This can make the maintenance of the code more complicated.\nTherefore, the access should be done directly through the base class to maintain clarity and avoid potential misunderstandings.\nNoncompliant code example\n```java\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Child.counter++;  // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\nclass Parent {\n  public static int counter;\n}\n\nclass Child extends Parent {\n  public Child() {\n    Parent.counter++;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3242": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Method parameters should be declared with base types\nDescription: Why is this an issue?\nFor maximum reusability, methods should accept parameters with as little specialization as possible. So unless specific features from a child class\nare required by a method, a type higher up the class hierarchy should be used instead.\nNoncompliant code example\n```java\npublic void printSize(ArrayList<Object> list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(List<Object> list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n```\nCompliant solution\n```java\npublic void printSize(Collection<?> list) {  // Collection can be used instead\n    System.out.println(list.size());\n}\n\npublic static void loop(Iterable<?> list) { // java.lang.Iterable can be used instead\n   for (Object o : list) {\n     o.toString();\n  }\n}\n```\nExceptions\nParameters in non-public methods are not checked, because such methods are not intended to be generally reusable.\njava.lang.String\nparameters are excluded, because String is immutable and can not be always substituted for more generic type. Parameters used in any other context\nthan method invocation or enhanced for loop are also excluded.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3066": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"enum\" fields should not be publicly mutable\nDescription: Why is this an issue?\nenum\ns are generally thought of as constant, but an\nenum\nwith a\npublic\nfield or\npublic\nsetter is\nnon-constant. Ideally fields in an\nenum\nare\nprivate\nand set in the constructor, but if that\u2019s not possible, their visibility\nshould be reduced as much as possible.\nNoncompliant code example\n```java\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  public int countryCount;  // Noncompliant\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n\n  public void setLandMass(int landMass) {  // Noncompliant\n    this.landMass = landMass;\n  }\n```\nCompliant solution\n```java\npublic enum Continent {\n\n  NORTH_AMERICA (23, 24709000),\n  // ...\n  EUROPE (50, 39310000);\n\n  private int countryCount;\n  private int landMass;\n\n  Continent(int countryCount, int landMass) {\n    // ...\n  }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3063": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"StringBuilder\" data should be used\nDescription: Why is this an issue?\nStringBuffer\nand\nStringBuilder\ninstances that are\nappend\ned but never\ntoString\ned needlessly\nclutter the code, and worse are a drag on performance. Either they should be removed, or the missing\ntoString\ncall added.\nNoncompliant code example\n```java\npublic void doSomething(List<String> strings) {\n\n  StringBuilder sb = new StringBuilder();  // Noncompliant\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic void doSomething(List<String> strings) {\n\n  for (String str : strings) {\n    // ...\n  }\n}\n```\nor\n```java\npublic void doSomething(List<String> strings) {\n\n  StringBuilder sb = new StringBuilder();\n  sb.append(\"Got: \");\n  for (String str : strings) {\n    sb.append(str).append(\", \");\n    // ...\n  }\n\n  LOGGER.info(sb.toString);\n}\n```\nExceptions\nThis rule ignores\nStringBuffer\ns and\nStringBuilder\ns that are passed as method arguments on the grounds that they are\nlikely\ntoString\ned there.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3052": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Fields should not be initialized to default values\nDescription: Why is this an issue?\nThe compiler automatically initializes class fields to their default values before setting them with any initialization values, so there is no need\nto explicitly set a field to its default value. Further, under the logic that cleaner code is better code, it\u2019s considered poor style to do so.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  int count = 0;  // Noncompliant\n  // ...\n\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  int count;\n  // ...\n\n}\n```\nExceptions\nfinal\nfields are ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3047": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Multiple loops over the same set should be combined\nDescription: Why is this an issue?\nWhen a method loops multiple over the same set of data, whether it\u2019s a list or a set of numbers, it is highly likely that the method could be made\nmore efficient by combining the loops into a single set of iterations.\nNoncompliant code example\n```java\npublic void doSomethingToAList(List<String> strings) {\n  for (String str : strings) {\n    doStep1(str);\n  }\n  for (String str : strings) {  // Noncompliant\n    doStep2(str);\n  }\n}\n```\nCompliant solution\n```java\npublic void doSomethingToAList(List<String> strings) {\n  for (String str : strings) {\n    doStep1(str);\n    doStep2(str);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3042": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"writeObject\" should not be the only \"synchronized\" code in a class\nDescription: Why is this an issue?\nSynchronization is a mechanism used when multithreading in Java to ensure that only one thread executes a given block of code at a time. This is\ndone to avoid bugs that can occur when multiple threads share a given state and try to manipulate simultaneously.\nObject serialization is not thread-safe by default. In a multithreaded environment, one option is to mark\nwriteObject\nwith\nsynchronized\nto improve thread safety. It is highly suspicious, however, if\nwriteObject\nis the only\nsynchronized\nmethod in a class. It may indicate that serialization is not required, as multithreading is not used. Alternatively, it\ncould also suggest that other methods in the same class have been forgotten to be made thread-safe.\nHow to fix it\nConsider whether this class is used in a multithreaded context. If it is, ask yourself whether other methods in this class should also be marked as\nsynchronized\n. Otherwise, remove the\nsynchronized\nmodifier from this method.\nCode examples\nNoncompliant code example\n```java\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private synchronized void writeObject(ObjectOutputStream stream) throws IOException { // Noncompliant, \"writeObject\" is the only synchronized method in this class\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic class RubberBall implements Serializable {\n\n  private Color color;\n  private int diameter;\n\n  public RubberBall(Color color, int diameter) {\n    // ...\n  }\n\n  public void bounce(float angle, float velocity) {\n    // ...\n  }\n\n  private void writeObject(ObjectOutputStream stream) throws IOException { // Compliant, no methods in this class are synchronized\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3038": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract methods should not be redundant\nDescription: Why is this an issue?\nThere\u2019s no point in redundantly defining an\nabstract\nmethod with the same signature as a method in an\ninterface\nthat the\nclass\nimplements\n. Any concrete child classes will have to implement the method either way.\nNoncompliant code example\n```java\npublic interface Reportable {\n  String getReport();\n}\n\npublic abstract class AbstractRuleReport implements Reportable{\n  public abstract String getReport();  // Noncompliant\n\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3033": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \".isEmpty\" should be used to test for the emptiness of StringBuffers/Builders\nDescription: Why is this an issue?\nIt is inefficient to build a\nString\nfrom a\nStringBuilder\nor\nStringBuffer\njust to check if it\u2019s empty.\nInstead, directly use the\n.isEmpty\nmethod.\nNoncompliant code example\n```java\nStringBuilder sb = new StringBuilder();\n// ...\nif (\"\".equals(sb.toString()) { // Noncompliant\n  // ...\n}\nif (sb.toString().isEmpty()) { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\nStringBuilder sb = new StringBuilder();\n// ...\nif (sb.isEmpty()) {\n  // ...\n}\nif (sb.isEmpty()) {\n  // ...\n}\n```\nBenchmarks\nMethod\nstringBuilderSize\nRuntime\nAverage time\nError margin\nisEmpty\n10\nTemurin 21\n6.57 ns/op\n\u00b10.38 ns/op\nisEmpty\n100\nTemurin 21\n6.68 ns/op\n\u00b10.10 ns/op\nisEmpty\n1000\nTemurin 21\n6.80 ns/op\n\u00b10.12 ns/op\nlength\n10\nTemurin 21\n6.83 ns/op\n\u00b10.12 ns/op\nlength\n100\nTemurin 21\n6.66 ns/op\n\u00b10.11 ns/op\nlength\n1000\nTemurin 21\n6.67 ns/op\n\u00b10.07 ns/op\ntoStringEquals\n10\nTemurin 21\n13.92 ns/op\n\u00b10.18 ns/op\ntoStringEquals\n100\nTemurin 21\n59.09 ns/op\n\u00b10.53 ns/op\ntoStringEquals\n1000\nTemurin 21\n465.79 ns/op\n\u00b15.86 ns/op\ntoStringIsEmpty\n10\nTemurin 21\n13.83 ns/op\n\u00b10.23 ns/op\ntoStringIsEmpty\n100\nTemurin 21\n60.06 ns/op\n\u00b13.42 ns/op\ntoStringIsEmpty\n1000\nTemurin 21\n484.58 ns/op\n\u00b14.24 ns/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@Param({\"10\", \"100\", \"1000\"})\nint stringBuilderSize;\n\n\nprivate StringBuilder sb;\n\n@Setup(Level.Iteration)\npublic void setup() {\n  sb = new StringBuilder();\n  IntStream.range(0, stringBuilderSize).forEach(i -> sb.append(\"word\"));\n}\n\n@Benchmark\npublic StringBuilder toStringEquals() {\n  if (\"\".equals((sb.toString()))) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder toStringIsEmpty() {\n  if (sb.toString().isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder length() {\n  if (sb.length() == 0) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n\n@Benchmark\npublic StringBuilder isEmpty() {\n  if (sb.isEmpty()) {\n    return sb;\n  }\n  return new StringBuilder();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3030": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not have too many \"static\" imports\nDescription: Why is this an issue?\nImporting a class statically allows you to use its\npublic static\nmembers without qualifying them with the class name. That can be\nhandy, but if you import too many classes statically, your code can become confusing and difficult to maintain.\nNoncompliant code example\nWith the default threshold value: 4\n```java\nimport static java.lang.Math.*;\nimport static java.util.Collections.*;\nimport static com.myco.corporate.Constants.*;\nimport static com.myco.division.Constants.*;\nimport static com.myco.department.Constants.*;  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3024": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arguments to \"append\" should not be concatenated\nDescription: Why is this an issue?\nThe use of a\nStringBuilder\nor\nStringBuffer\nmakes\nString\nassembly more efficient than plain concatenation\nwhen you perform a large number of appends. Using\nString\nconcatenation within\nStringBuilder.append\ndefeats the purpose of\nthe\nStringBuilder\n. If you concatenate only a few strings, use direct\nString\nconcatenation. Otherwise, replace\nString\nconcatenation with calls to\nappend\n.\nThis rule applies to String concatenations performed repeatedly, inside loops. In such scenarios, the performance penalty associated with\ninefficient StringBuilder.append usage can multiply significantly.\nNoncompliant code example\n```java\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \" + name); // Noncompliant\n}\n```\nCompliant solution\n```java\nStringBuilder sb = new StringBuilder();\nfor (String name : names) {\n  sb.append(\"Hello : \").append(name);\n}\n```\nBenchmarks\nMethod\nRuntime\nAverage time\nError margin\nappend\nTemurin 21\n14.26 ns/op\n\u00b10.50 ns/op\nconcat\nTemurin 21\n17.77 ns/op\n\u00b10.66 ns/op\nconcatWithinBuilder\nTemurin 21\n31.42 ns/op\n\u00b11.80 ns/op\nThe results were generated by running the following snippet with\njmh\n:\n```java\nprivate String name1 = \"John\";\nprivate String name2 = \"Jane\";\n\n@Benchmark\npublic String concat() {\n  return name1 + \", \" + name2;\n}\n\n@Benchmark\npublic String concatWithinBuilder() {\n  return new StringBuilder()\n    .append(name1 + \", \" + name2)\n    .toString();\n}\n\n@Benchmark\npublic String append() {\n  return new StringBuilder()\n    .append(name1)\n    .append(\", \")\n    .append(name2)\n    .toString();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3014": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ThreadGroup\" should not be used\nDescription: Why is this an issue?\nThe\nThreadGroup\nclass contains many deprecated methods like\nallowThreadSuspension\n,\nresume\n,\nstop\n, and\nsuspend\n. Also, some of the non-deprecated methods are obsolete or not thread-safe, and still others are insecure\n(\nactiveCount\n,\nenumerate\n). For these reasons, any use of\nThreadGroup\nis suspicious and should be avoided.\nHow to fix it\nInstead, use implementations of\njava.util.concurrent.ExecutorService\nto safely manage groups of threads.\nCode examples\nNoncompliant code example\n```java\nclass NetworkHandler {\n\n  void startThreadInGroup(ThreadGroup tg) { // Noncompliant, use an ExecutorService instead, which is more secure\n    Thread thread = new Thread(tg, \"controller\");\n    thread.start();\n  }\n\n}\n```\nCompliant solution\n```java\nclass NetworkHandler {\n\n  void handleThreadsProperly() {\n    ThreadFactory threadFactory = Executors.defaultThreadFactory();\n    ThreadPoolExecutor executorPool = new ThreadPoolExecutor(3, 10, 5, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(2), threadFactory);\n    for (int i = 0; i < 10; i++) {\n      executorPool.execute(new Thread(\"Job: \" + i));\n    }\n    executorPool.shutdown();\n  }\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3012": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Arrays and lists should not be copied using loops\nDescription: Why is this an issue?\nThe JDK provides a set of built-in methods to copy the contents of an array into another array. Using a loop to perform the same operation is less\nclear, more verbose and should be avoided.\nExceptions\nThe rule detects only the most idiomatic patterns, it will not consider loops with non-trivial control flow. For example, loops that copy array\nelements conditionally are ignored.\nHow to fix it\nYou can use:\n1. Arrays.copyOfto copy an entire array into another array\n2. System.arraycopyto copy only a subset of an array into another array\n3. Arrays.asListto create a new list with the contents of the array\n4. Collections.addAllto add the elements of a collection into another collection\nNote that\nArrays.asList\nreturns a fixed-size\nList\n, so further steps are required if a non-fixed-size\nList\nis\nneeded.\nCode examples\nNoncompliant code example\n```java\npublic void copyArray(String[] source){\n  String[] array = new String[source.length];\n  for (int i = 0; i < source.length; i++) {\n    array[i] = source[i]; // Noncompliant\n  }\n}\n\npublic void copyList(List<String> source) {\n  List<String> list = new ArrayList<>();\n  for (String s : source) {\n    list.add(s); // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic void copyArray(String[] source){\n  String[] array = Arrays.copyOf(source, source.length);\n}\n\npublic void copyList(List<String> source) {\n  List<String> list = new ArrayList<>();\n  Collections.addAll(list, source);\n}\n```\n```java\npublic void makeCopiesConditional(int[] source) {\n  int[] dest = new int[source.length];\n  for (int i = 0; i < source.length; i++) {\n    if (source[i] > 10) {\n      dest[i] = source[i];  // Compliant, since the array elements are conditionally copied to the dest array\n    }\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3011": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Reflection should not be used to increase accessibility of classes, methods, or fields\nDescription: Why is this an issue?\nAltering or bypassing the accessibility of classes, methods, or fields through reflection violates the encapsulation principle. This can break the\ninternal contracts of the accessed target and lead to maintainability issues and runtime errors.\nThis rule raises an issue when reflection is used to change the visibility of a class, method or field, and when it is used to directly update a\nfield value.\n```java\npublic void makeItPublic(String methodName) throws NoSuchMethodException {\n\n  this.getClass().getMethod(methodName).setAccessible(true); // Noncompliant\n}\n\npublic void setItAnyway(String fieldName, int value) {\n  this.getClass().getDeclaredField(fieldName).setInt(this, value); // Noncompliant; bypasses controls in setter\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3010": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Static fields should not be updated in constructors\nDescription: Why is this an issue?\nAssigning a value to a\nstatic\nfield in a constructor could cause unreliable behavior at runtime since it will change the value for all\ninstances of the class.\nInstead remove the field\u2019s\nstatic\nmodifier, or initialize it statically.\nNoncompliant code example\n```java\npublic class Person {\n  static Date dateOfBirth;\n  static int expectedFingers;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;  // Noncompliant; now everyone has this birthday\n    expectedFingers = 10;  // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic class Person {\n  Date dateOfBirth;\n  static int expectedFingers = 10;\n\n  public Person(date birthday) {\n    dateOfBirth = birthday;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-3008": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Static non-final field names should comply with a naming convention\nDescription: Why is this an issue?\nThe Java Language Specification defines a set of rules called naming conventions that apply to Java programs. These conventions provide\nrecommendations for naming packages, classes, methods, and variables.\nBy following shared naming conventions, teams can collaborate more efficiently.\nThis rule checks that static non-final field names match a provided regular expression.\nNoncompliant code example\nThe default regular expression applied by the rule is\n^[a-z][a-zA-Z0-9]*$\n:\n```java\npublic class MyClass {\n   private static String foo_bar; // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n   private static String fooBar;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2975": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"clone\" should not be overridden\nDescription: This rule raises an issue when a class overrides the\nObject.clone\nmethod instead of resorting to a copy constructor or other copy\nmechanisms.\nWhy is this an issue?\nThe\nObject.clone\n/\njava.lang.Cloneable\nmechanism in Java should be considered broken for the following reasons and\nshould, consequently, not be used:\n1. Cloneableis amarker interfacewithout API but with a contract about class behavior that the compiler cannot enforce.\n  This is a bad practice.\n2. Classes are instantiated without calling their constructor, so possible preconditions cannot be enforced.\n3. There are implementation flaws by design when overridingObject.clone, like type casts or the handling ofCloneNotSupportedExceptionexceptions.\nHow to fix it\nA copy constructor, copy factory or a custom copy function are suitable alternatives to the\nObject.clone\n/\njava.lang.Cloneable\nmechanism.\nConsider the following example:\n```java\nclass Entity implements Cloneable { // Noncompliant, using `Cloneable`\n\n  public int value;\n  public List<Entity> children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone(); // invariant not enforced, because no constructor is caled\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) { // this will not happen due to behavioral contract\n      throw new AssertionError();\n    }\n  }\n}\n```\nThe\nCloneable\n/\nObject.clone\nmechanism could easily be replaced by copy constructor:\n```java\nclass Entity { // Compliant\n\n  public int value;\n  public List<Entity> children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  Entity(Entity template) {\n    value = template.value;\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n```\nOr by a factory method:\n```java\nclass Entity { // Compliant\n\n  public int value;\n  public List<Entity> children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  public static Entity create(Entity template) {\n    Entity entity = new Entity();\n    entity.value = template.value;\n    entity.children = template.children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n```\nOr by a custom\ncopy\nfunction:\n```java\nclass Entity { // Compliant\n\n  public int value;\n  public List<Entity> children; // deep copy wanted\n\n  Entity() {\n    EntityManager.register(this); // invariant\n  }\n\n  public Entity copy() {\n    Entity entity = new Entity();\n    entity.value = value;\n    entity.children = children.stream().map(Entity::new).toList();\n    return Entity;\n  }\n}\n```\nDocumentation\n1. Joshua Bloch - Copy Constructor versus Cloning\n2. Interface Cloneable - Java\u2122 Platform, Standard Edition 8 API\n  Specification\n3. Object.clone - Java\u2122 Platform, Standard Edition 8 API\n  Specification\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2974": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes without \"public\" constructors should be \"final\"\nDescription: Why is this an issue?\nClasses with only\nprivate\nconstructors should be marked\nfinal\nto prevent any mistaken extension attempts.\nNoncompliant code example\n```java\npublic class PrivateConstructorClass {  // Noncompliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n```\nCompliant solution\n```java\npublic final class PrivateConstructorClass {  // Compliant\n  private PrivateConstructorClass() {\n    // ...\n  }\n\n  public static int magic(){\n    return 42;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2973": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Escaped Unicode characters should not be used\nDescription: Why is this an issue?\nThe use of Unicode escape sequences should be reserved for characters that would otherwise be ambiguous, such as unprintable characters.\nThis rule ignores sequences composed entirely of Unicode characters, but otherwise raises an issue for each Unicode character that represents a\nprintable character.\nNoncompliant code example\n```java\nString prefix = \"n\\u00E9e\"; // Noncompliant\n```\nCompliant solution\n```java\nString prefix = \"n\u00e9e\";\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2972": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Inner classes should not have too many lines of code\nDescription: Why is this an issue?\nInner classes should be short and sweet, to manage complexity in the overall file. An inner class that has grown longer than a certain threshold\nshould probably be externalized to its own file.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2970": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Assertions should be complete\nDescription: Why is this an issue?\nIt is very easy to write incomplete assertions when using some test frameworks. This rule enforces complete assertions in the following cases:\n1. Fest:assertThatis not followed by an assertion invocation\n2. AssertJ:assertThatis not followed by an assertion invocation\n3. Mockito:verifyis not followed by a method invocation\n4. Truth:assertXXXis not followed by an assertion invocation\nIn such cases, what is intended to be a test doesn\u2019t actually verify anything\nNoncompliant code example\n```java\n// Fest\nboolean result = performAction();\n// let's now check that result value is true\nassertThat(result); // Noncompliant; nothing is actually checked, the test passes whether \"result\" is true or false\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// let's check that \"add\" and \"clear\" methods are actually called\nMockito.verify(mockedList); // Noncompliant; nothing is checked here, oups no call is chained to verify()\n```\nCompliant solution\n```java\n// Fest\nboolean result = performAction();\n// let's now check that result value is true\nassertThat(result).isTrue();\n\n// Mockito\nList mockedList = Mockito.mock(List.class);\nmockedList.add(\"one\");\nmockedList.clear();\n// let's check that \"add\" and \"clear\" methods are actually called\nMockito.verify(mockedList).add(\"one\");\nMockito.verify(mockedList).clear();\n```\nExceptions\nVariable assignments and return statements are skipped to allow helper methods.\n```java\nprivate BooleanAssert check(String filename, String key) {\n  String fileContent = readFileContent(filename);\n  performReplacements(fileContent);\n  return assertThat(fileContent.contains(key)); // No issue is raised here\n}\n\n@Test\npublic void test() {\n  check(\"foo.txt\", \"key1\").isTrue();\n  check(\"bar.txt\", \"key2\").isTrue();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2959": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnecessary semicolons should be omitted\nDescription: Why is this an issue?\nUnder the reasoning that cleaner code is better code, the semicolon at the end of a try-with-resources construct should be omitted because it can\nbe omitted.\nNoncompliant code example\n```java\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);  // ignored; this one's required\n      Reader r = new InputStreamReader(b);)   // Noncompliant\n{\n   //do stuff\n}\n```\nCompliant solution\n```java\ntry (ByteArrayInputStream b = new ByteArrayInputStream(new byte[10]);\n      Reader r = new InputStreamReader(b))\n{\n   //do stuff\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2925": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Thread.sleep\" should not be used in tests\nDescription: Why is this an issue?\nIn asynchronous testing, the test code is written in a way that allows it to wait for the asynchronous operation to complete before continuing with\nthe test.\nUsing\nThread.sleep\nin this case can cause flaky tests, slow test execution, and inaccurate test results. It creates brittle tests that\ncan fail unpredictably depending on the environment or load.\nUse mocks or libraries such as\nAwaitility\ninstead. These tools provide features such as timeouts, assertions, and error handling to\nmake it easier to write and manage asynchronous tests.\nNoncompliant code example\n```java\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  Thread.sleep(500);  // Noncompliant\n  // assertions...\n}\n```\nCompliant solution\n```java\n@Test\npublic void testDoTheThing(){\n\n  MyClass myClass = new MyClass();\n  myClass.doTheThing();\n\n  await().atMost(2, Duration.SECONDS).until(didTheThing());  // Compliant\n  // assertions...\n}\n\nprivate Callable<Boolean> didTheThing() {\n  return new Callable<Boolean>() {\n    public Boolean call() throws Exception {\n      // check the condition that must be fulfilled...\n    }\n  };\n}\n```\nDocumentation\n1. Oracle SE 20 - Thread\n2. Awaitility\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2924": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit rules should be used\nDescription: Why is this an issue?\nJUnit rules are predefined classes that extend the behavior of JUnit tests, allowing to add new functionalities, such as managing resources,\nmodifying test behavior, and handling exceptions.\nUnused JUnit rules can lead to confusion when reading the test code, making tests harder to understand and maintain. Having unused rules can also\nslow down the test suite, as JUnit has to process the rules even though they are not being used. Some\nTestRule\nclasses have the desired\neffect without being directly referenced by a test, while others do not. There\u2019s no reason to leave them cluttering the file if they\u2019re not in\nuse.\nThe rule raises an issue when in a\nTest\nclass, there is no method referencing a declared\nTestRule\nof the following\ntypes:\n1. TemporaryFolderandTestNamein JUnit\n2. TempDirandTestInfoin JUnit 5\nHow to fix it\nRemove the unused\nTestRule\nfield that is expected to be referenced inside a test method.\nCode examples\nNoncompliant code example\n```java\npublic class ProjectDefinitionTest {\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();  // Noncompliant\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n```\nCompliant solution\n```java\npublic class ProjectDefinitionTest {\n\n  @Test\n  public void shouldSetKey() {\n    ProjectDefinition def = ProjectDefinition.create();\n    def.setKey(\"mykey\");\n    assertThat(def.getKey(), is(\"mykey\"));\n  }\n}\n```\nDocumentation\n1. Junit API - Rule\n2. Junit - Rules\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2864": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"entrySet()\" should be iterated when both the key and value are needed\nDescription: Why is this an issue?\nMap\nis an object that maps keys to values. A map cannot contain duplicate keys, which means each key can map to at most one value.\nWhen both the key and the value are needed, it is more efficient to iterate the\nentrySet()\n, which will give access to both instead of\niterating over the\nkeySet()\nand then getting the value.\nIf the\nentrySet()\nmethod is not iterated when both the key and value are needed, it can lead to unnecessary lookups. This is because\neach lookup requires two operations: one to retrieve the key and another to retrieve the value. By iterating the\nentrySet()\nmethod, the\nkey-value pair can be retrieved in a single operation, which can improve performance.\nNoncompliant code example\n```java\npublic void doSomethingWithMap(Map<String,Object> map) {\n  for (String key : map.keySet()) {  // Noncompliant; for each key the value is retrieved\n    Object value = map.get(key);\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic void doSomethingWithMap(Map<String,Object> map) {\n  for (Map.Entry<String,Object> entry : map.entrySet()) {\n    String key = entry.getKey();\n    Object value = entry.getValue();\n    // ...\n  }\n}\n```\nDocumentation\n1. Oracle SE 20 - Map\nArticles & blog posts\n1. Baeldung - Java Map methods\nBenchmarks\nMethod\nsize\nRuntime\nAverage time\nError margin\nusingEntrySet\n10\nTemurin 21\n27.48 ns/op\n\u00b16.22 ns/op\nusingEntrySet\n1000\nTemurin 21\n2480.26 ns/op\n\u00b1899.05 ns/op\nusingEntrySet\n10000\nTemurin 21\n22745.78 ns/op\n\u00b110505.46 ns/op\nusingKeySet\n10\nTemurin 21\n49.70 ns/op\n\u00b13.78 ns/op\nusingKeySet\n1000\nTemurin 21\n5061.54 ns/op\n\u00b12056.60 ns/op\nusingKeySet\n10000\nTemurin 21\n46689.04 ns/op\n\u00b114509.97 ns/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@BenchmarkMode({Mode.AverageTime})\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@State(Scope.Benchmark)\npublic class S2864 {\n  @Param({\"10\", \"1000\", \"10000\"})\n  int size;\n\n  Map<Integer,Integer> map;\n\n  @Setup(Level.Trial)\n  public void setup() {\n    Random random = new Random();\n    map = new HashMap<>();\n    for (int i = 0; i < size; i++) {\n      map.put(i, random.nextInt());\n    }\n  }\n\n  @Benchmark\n  public int usingKeySet() {\n    int sumKeysValues = 0;\n    for (Integer key : map.keySet()) {\n      sumKeysValues += key + map.get(key);\n    }\n    return sumKeysValues;\n  }\n\n  @Benchmark\n  public int usingEntrySet() {\n    int sumKeysValues = 0;\n    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n      sumKeysValues += entry.getKey() + entry.getValue();\n    }\n    return sumKeysValues;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2786": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nested \"enum\"s should not be declared static\nDescription: Why is this an issue?\nIn Java, an enum is a special data type that allows you to define a set of constants. Nested enum types, also known as inner enum types, are enum\ntypes that are defined within another class or interface.\nNested enum types are implicitly static, so there is no need to declare them\nstatic\nexplicitly.\nNoncompliant code example\n```java\npublic class Flower {\n  static enum Color { // Noncompliant; static is redundant here\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n```\nCompliant solution\n```java\npublic class Flower {\n  enum Color { // Compliant\n    RED, YELLOW, BLUE, ORANGE\n  }\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2737": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"catch\" clauses should do more than rethrow\nDescription: Why is this an issue?\nA\ncatch\nclause that only rethrows the caught exception has the same effect as omitting the\ncatch\naltogether and letting\nit bubble up automatically.\n```java\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    throw e;\n  }\n  return content;\n}\n```\nSuch clauses should either be removed or populated with the appropriate logic.\n```java\npublic String readFile(File f) throws IOException {\n  return readFromDisk(f);\n}\n```\nor\n```java\npublic String readFile(File f) throws IOException {\n  String content;\n  try {\n    content = readFromDisk(f);\n  } catch (IOException e) {\n    logger.LogError(e);\n    throw e;\n  }\n  return content;\n}\n```\nIn the case of try-with-resources, the try should remain even without a catch clause, to keep the resource management\n```java\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  } catch (IOException e) { // Noncompliant\n  throw e;\n}\n```\nbecomes\n```java\nString readFirstLine(FileReader fileReader) throws IOException {\n  try (BufferedReader br = new BufferedReader(fileReader)) {\n     return br.readLine();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2718": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"DateUtils.truncate\" from Apache Commons Lang library should not be used\nDescription: Why is this an issue?\nThe\nZonedDateTime\nis an immutable representation of a date-time with a time-zone, introduced in Java 8. This class stores all date and\ntime fields, to a precision of nanoseconds, and a time zone, with a zone offset used to handle ambiguous local date times.\nDate truncation to a specific time unit means setting the values up to the specific time unit to zero while keeping the values of the larger time\nunits unchanged.\nThe\nZonedDateTime\nclass provides a\ntruncatedTo\nmethod that allows truncating the date in a significantly faster way than\nthe\nDateUtils\nclass from Commons Lang.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n.\nNoncompliant code example\n```java\npublic Date trunc(Date date) {\n  return DateUtils.truncate(date, Calendar.SECOND);  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic Date trunc(Date date) {\n  Instant instant = date.toInstant();\n  ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());\n  ZonedDateTime truncatedZonedDateTime = zonedDateTime.truncatedTo(ChronoUnit.SECONDS);\n  Instant truncatedInstant = truncatedZonedDateTime.toInstant();\n  return Date.from(truncatedInstant);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2701": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Literal boolean values and nulls should not be used in assertions\nDescription: Why is this an issue?\nThere\u2019s no reason to use literal boolean values or nulls in assertions. Instead of using them with\nassertEquals\n,\nassertNotEquals\nand similar methods, you should be using\nassertTrue\n,\nassertFalse\n,\nassertNull\nor\nassertNotNull\ninstead (or\nisNull\netc. when using Fest). Using them with assertions unrelated to equality (such as\nassertNull\n) is most likely a bug.\nSupported frameworks:\n1. JUnit3\n2. JUnit4\n3. JUnit5\n4. Fest assert\nNoncompliant code example\n```java\nAssert.assertTrue(true);  // Noncompliant\nassertThat(null).isNull(); // Noncompliant\n\nassertEquals(true, something()); // Noncompliant\nassertNotEquals(null, something()); // Noncompliant\n```\nCompliant solution\n```java\nassertTrue(something());\nassertNotNull(something());\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2699": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tests should include assertions\nDescription: Why is this an issue?\nA test case without assertions ensures only that no exceptions are thrown. Beyond basic runnability, it ensures nothing about the behavior of the\ncode under test.\nThis rule raises an exception when no assertions from any of the following known frameworks are found in a test:\n1. AssertJ\n2. Awaitility\n3. EasyMock\n4. Eclipse Vert.x\n5. Fest 1.x and 2.x\n6. Hamcrest\n7. JMock\n8. JMockit\n9. JUnit\n10. Mockito\n11. Rest-assured 2.x, 3.x and 4.x\n12. RxJava 1.x and 2.x\n13. Selenide\n14. Spring\u2019sorg.springframework.test.web.servlet.ResultActions.andExpect()andorg.springframework.test.web.servlet.ResultActions.andExpectAll()\n15. Truth Framework\n16. WireMock\nFurthermore, as new or custom assertion frameworks may be used, the rule can be parametrized to define specific methods that will also be\nconsidered as assertions. No issue will be raised when such methods are found in test cases. The parameter value should have the following format\n<FullyQualifiedClassName>#<MethodName>\n, where\nMethodName\ncan end with the wildcard character. For constructors,\nthe pattern should be\n<FullyQualifiedClassName>#<init>\n.\nExample:\ncom.company.CompareToTester#compare*,com.company.CustomAssert#customAssertMethod,com.company.CheckVerifier#<init>\n.\nNoncompliant code example\n```java\n@Test\npublic void testDoSomething() {  // Noncompliant\n  MyClass myClass = new MyClass();\n  myClass.doSomething();\n}\n```\nCompliant solution\nExample when\ncom.company.CompareToTester#compare*\nis used as parameter to the rule.\n```java\nimport com.company.CompareToTester;\n\n@Test\npublic void testDoSomething() {\n  MyClass myClass = new MyClass();\n  assertNull(myClass.doSomething());  // JUnit assertion\n  assertThat(myClass.doSomething()).isNull();  // Fest assertion\n}\n\n@Test\npublic void testDoSomethingElse() {\n  MyClass myClass = new MyClass();\n  new CompareToTester().compareWith(myClass);  // Compliant - custom assertion method defined as rule parameter\n  CompareToTester.compareStatic(myClass);  // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2698": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Test assertions should include messages\nDescription: Why is this an issue?\nAdding messages to JUnit, FEST and AssertJ assertions is an investment in your future productivity. Spend a few seconds writing them now, and\nyou\u2019ll save a lot of time on the other end when either the tests fail and you need to quickly diagnose the problem, or when you need to maintain the\ntests and the assertion messages work as a sort of documentation.\nNoncompliant code example\n```java\nassertEquals(4, list.size());  // Noncompliant\n\ntry {\n  fail();  // Noncompliant\n} catch (Exception e) {\n  assertThat(list.get(0)).isEqualTo(\"pear\");  // Noncompliant\n}\n```\nCompliant solution\n```java\nassertEquals(\"There should have been 4 Fruits in the list\", 4, list.size());\n\ntry {\n  fail(\"And exception is expected here\");\n} catch (Exception e) {\n  assertThat(list.get(0)).as(\"check first element\").overridingErrorMessage(\"The first element should be a pear, not a %s\", list.get(0)).isEqualTo(\"pear\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2696": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Instance methods should not write to \"static\" fields\nDescription: Why is this an issue?\nCorrectly updating a\nstatic\nfield from a non-static method is tricky to get right and could easily lead to bugs if there are multiple\nclass instances and/or multiple threads in play. Ideally,\nstatic\nfields are only updated from\nsynchronized static\nmethods.\nThis rule raises an issue each time a\nstatic\nfield is updated from a non-static method.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  private static int count = 0;\n\n  public void doSomething() {\n    //...\n    count++;  // Noncompliant\n  }\n}\n```\nStandards\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2694": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Inner classes which do not reference their owning classes should be \"static\"\nDescription: Why is this an issue?\nA non-static inner class has a reference to its outer class, and access to the outer class' fields and methods. That class reference makes the\ninner class larger and could cause the outer class instance to live in memory longer than necessary.\nIf the reference to the outer class isn\u2019t used, it is more efficient to make the inner class\nstatic\n(also called nested). If the\nreference is used only in the class constructor, then explicitly pass a class reference to the constructor. If the inner class is anonymous, it will\nalso be necessary to name it.\nHowever, while a nested/\nstatic\nclass would be more efficient, it\u2019s worth noting that there are semantic differences between an inner\nclass and a nested one:\n1. an inner class can only be instantiated within the context of an instance of the outer class.\n2. a nested (static) class can be instantiated independently of the outer class.\nHow to fix it\nThere are two scenarios in which this rule will raise an issue:\nOn an\ninner class\n: make it\nstatic\n.\nOn a\nlocal class\n: extract it as a\nstatic\ninner class\n.\nCode examples\nNoncompliant code example\nInner classes that don\u2019t use the outer class reference should be static.\n```java\npublic class Fruit {\n  // ...\n\n  public class Seed {  // Noncompliant; there's no use of the outer class reference so make it static\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n```\nCompliant solution\n```java\npublic class Fruit {\n  // ...\n\n  public static class Seed {\n    int germinationDays = 0;\n    public Seed(int germinationDays) {\n      this.germinationDays = germinationDays;\n    }\n    public int getGerminationDays() {\n      return germinationDays;\n    }\n  }\n}\n```\nLocal classes that don\u2019t use the outer class reference should be extracted as a static inner classes.\nNoncompliant code example\n```java\npublic class Foo {\n  public Foo() {\n    class Bar { // Noncompliant\n      void doSomething() {\n        // ...\n      }\n    }\n    new Bar().doSomething();\n  }\n\n  public void method() {\n    class Baz { // Noncompliant\n      void doSomething() {\n        // ...\n      }\n    }\n    new Baz().doSomething();\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo {\n  public Foo() {\n    new Bar().doSomething();\n  }\n\n  public void method()  {\n    new Baz().doSomething();\n  }\n\n  private static class Bar { // Compliant\n    void doSomething() {\n      // ...\n    }\n  }\n\n  private static class Baz { // Compliant\n    void doSomething() {\n      // ...\n    }\n  }\n}\n```\nDocumentation\n1. Oracle Java SE - Nested Classes\n2. Oracle Java SE - Local Classes\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2693": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Threads should not be started in constructors\nDescription: Why is this an issue?\nThe problem with invoking\nThread.start()\nin a constructor is that you\u2019ll have a confusing mess on your hands if the class is ever\nextended because the superclass' constructor will start the thread before the child class has truly been initialized.\nThis rule raises an issue any time\nstart\nis invoked in the constructor of a non-\nfinal\nclass.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  Thread thread = null;\n\n  public MyClass(Runnable runnable) {\n    thread = new Thread(runnable);\n    thread.start(); // Noncompliant\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2692": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"indexOf\" checks should not be for positive numbers\nDescription: Why is this an issue?\nMost checks against an\nindexOf\nvalue compare it with -1 because 0 is a valid index. Checking against\n> 0\nignores the\nfirst element, which is likely a bug.\n```java\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") > 0) { // Noncompliant\n  // ...\n}\n```\nMoreover, if the intent is merely to check the inclusion of a value in a\nString\nor a\nList\n, consider using the\ncontains\nmethod instead.\n```java\nString name = \"ishmael\";\n\nif (name.contains(\"ish\") {\n  // ...\n}\n```\nIf the intent is really to skip the first element, comparing it with\n>=1\nwill make it more straightforward.\n```java\nString name = \"ishmael\";\n\nif (name.indexOf(\"ish\") >= 1) {\n  // ...\n}\n```\nThis rule raises an issue when an\nindexOf\nvalue retrieved from a\nString\nor a\nList\nis tested against\n> 0\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2681": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Multiline blocks should be enclosed in curly braces\nDescription: Why is this an issue?\nHaving inconsistent indentation and omitting curly braces from a control structure, such as an\nif\nstatement or\nfor\nloop,\nis misleading and can induce bugs.\nThis rule raises an issue when the indentation of the lines after a control structure indicates an intent to include those lines in the block, but\nthe omission of curly braces means the lines will be unconditionally executed once.\nThe following patterns are recognized:\n```java\nif (condition)\n  firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\nthirdAction();\n```\n```java\nif (condition) firstActionInBlock(); secondAction();  // Noncompliant: secondAction is executed unconditionally\n```\n```java\nif (condition) firstActionInBlock();\n  secondAction();  // Noncompliant: secondAction is executed unconditionally\n```\n```java\nif (condition); secondAction();  // Noncompliant: secondAction is executed unconditionally\n```\n```java\nfor (int i = 0; i < array.length; i++)\n  str = array[i];\n  doTheThing(str);  // Noncompliant: executed only on the last element\n```\nNote that this rule considers tab characters to be equivalent to 1 space. When mixing spaces and tabs, a code may look fine in one editor but be\nconfusing in another configured differently.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2675": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"readObject\" should not be \"synchronized\"\nDescription: Why is this an issue?\nThe\nreadObject\nmethod is implemented when a\nSerializable\nobject requires special handling to be reconstructed from a\nfile. The object created by\nreadObject\nis accessed only by the thread that called the method, thus using the\nsynchronized\nkeyword in this context is unnecessary and causes confusion.\nNoncompliant code example\n```java\nprivate synchronized void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // Noncompliant\n  //...\n}\n```\nCompliant solution\n```java\nprivate void readObject(java.io.ObjectInputStream in)\n     throws IOException, ClassNotFoundException { // Compliant\n  //...\n}\n```\nDocumentation\n1. Oracle SDK 20 - Serializable\n2. Oracle SDK 20 - ObjectInputStream\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2638": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Method overrides should not change contracts\nDescription: This rule raises an issue when an overriding method changes a contract defined in a superclass.\nWhy is this an issue?\nBecause a subclass instance may be cast to and treated as an instance of the superclass, overriding methods should uphold the aspects of the\nsuperclass contract that relate to the Liskov Substitution Principle. Specifically, if the parameters or return type of the superclass method are\nmarked with any of the following:\n@Nullable\n,\n@CheckForNull\n,\n@NotNull\n,\n@NonNull\n, and\n@Nonnull\n, then subclass parameters are not allowed to tighten the contract, and return values are not allowed to loosen it.\nCode examples\nNoncompliant code example\n```java\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@NotNull Season ripe) {  // Noncompliant: the ripe argument annotated as @Nullable in parent class\n    this.ripe = ripe;\n  }\n\n  public @Nullable Integer getProtein() {  // Noncompliant: the return type annotated as @NotNull in parent class\n    return null;\n  }\n}\n```\nCompliant solution\n```java\npublic class Fruit {\n\n  private Season ripe;\n  private String color;\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n\npublic class Raspberry extends Fruit {\n\n  public void setRipe(@Nullable Season ripe) {\n    this.ripe = ripe;\n  }\n\n  public @NotNull Integer getProtein() {\n    return 12;\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2629": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Preconditions\" and logging arguments should not require evaluation\nDescription: Why is this an issue?\nSome method calls can effectively be \"no-ops\", meaning that the invoked method does nothing, based on the application\u2019s configuration (eg: debug\nlogs in production). However, even if the method effectively does nothing, its arguments may still need to evaluated before the method is called.\nPassing message arguments that require further evaluation into a Guava\ncom.google.common.base.Preconditions\ncheck can result in a\nperformance penalty. That is because whether or not they\u2019re needed, each argument must be resolved before the method is actually called.\nSimilarly, passing concatenated strings into a logging method can also incur a needless performance hit because the concatenation will be performed\nevery time the method is called, whether or not the log level is low enough to show the message.\nInstead, you should structure your code to pass static or pre-computed values into\nPreconditions\nconditions check and logging\ncalls.\nSpecifically, the built-in string formatting should be used instead of string concatenation, and if the message is the result of a method call,\nthen\nPreconditions\nshould be skipped altogether, and the relevant exception should be conditionally thrown instead.\nNoncompliant code example\n```java\nlogger.log(Level.DEBUG, \"Something went wrong: \" + message);  // Noncompliant; string concatenation performed even when log level too high to show DEBUG messages\n\nlogger.fine(\"An exception occurred with message: \" + message); // Noncompliant\n\nLOG.error(\"Unable to open file \" + csvPath, e);  // Noncompliant\n\nPreconditions.checkState(a > 0, \"Arg must be positive, but got \" + a);  // Noncompliant. String concatenation performed even when a > 0\n\nPreconditions.checkState(condition, formatMessage());  // Noncompliant. formatMessage() invoked regardless of condition\n\nPreconditions.checkState(condition, \"message: %s\", formatMessage());  // Noncompliant\n```\nCompliant solution\n```java\nlogger.log(Level.DEBUG, \"Something went wrong: {0} \", message);  // String formatting only applied if needed\nlogger.log(Level.SEVERE, () -> \"Something went wrong: \" + message); // since Java 8, we can use Supplier , which will be evaluated lazily\n\nlogger.fine(\"An exception occurred with message: {}\", message);  // SLF4J, Log4j\n\nLOG.error(\"Unable to open file {0}\", csvPath, e);\n\nif (LOG.isDebugEnabled()) {\n  LOG.debug(\"Unable to open file \" + csvPath, e);  // this is compliant, because it will not evaluate if log level is above debug.\n}\n\nPreconditions.checkState(arg > 0, \"Arg must be positive, but got %d\", a);  // String formatting only applied if needed\n\nif (!condition) {\n  throw new IllegalStateException(formatMessage());  // formatMessage() only invoked conditionally\n}\n\nif (!condition) {\n  throw new IllegalStateException(\"message: \" + formatMessage());\n}\n```\nExceptions\ncatch\nblocks are ignored, because the performance penalty is unimportant on exceptional paths (catch block should not be a part of\nstandard program flow). Getters are ignored as well as methods called on annotations which can be considered as getters. This rule accounts for\nexplicit test-level testing with SLF4J methods\nisXXXEnabled\nand ignores the bodies of such\nif\nstatements.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2589": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Boolean expressions should not be gratuitous\nDescription: Gratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the\ncorrectness of an application, as well as its maintainability.\nWhy is this an issue?\nControl flow constructs like\nif\n-statements allow the programmer to direct the flow of a program depending on a boolean expression.\nHowever, if the condition is always true or always false, only one of the branches will ever be executed. In that case, the control flow construct and\nthe condition no longer serve a purpose; they become\ngratuitous\n.\nWhat is the potential impact?\nThe presence of gratuitous conditions can indicate a logical error. For example, the programmer\nintended\nto have the program branch into\ndifferent paths but made a mistake when formulating the branching condition. In this case, this issue might result in a bug and thus affect the\nreliability of the application. For instance, it might lead to the computation of incorrect results.\nAdditionally, gratuitous conditions and control flow constructs introduce unnecessary complexity. The source code becomes harder to understand, and\nthus, the application becomes more difficult to maintain.\nHow to fix it\nGratuitous boolean expressions are suspicious and should be carefully removed from the code.\nFirst, the boolean expression in question should be closely inspected for logical errors. If a mistake was made, it can be corrected so the\ncondition is no longer gratuitous.\nIf it becomes apparent that the condition is actually unnecessary, it can be removed. The associated control flow construct (e.g., the\nif\n-statement containing the condition) will be adapted or even removed, leaving only the necessary branches.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (a) {                // Noncompliant\n          doSomething();\n        }\n\n        if (b && a) {           // Noncompliant; \"a\" is always \"true\"\n          doSomething();\n        }\n\n        if (c || !a) {          // Noncompliant; \"!a\" is always \"false\"\n          doSomething();\n        }\n\n        if (c || (!c && b)) {   // Noncompliant; c || (!c && b) is equal to c || b\n          doSomething();\n        }\n    }\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n    public void doThings(boolean b, boolean c) {\n        a = true;\n        if (foo(a)) {\n          doSomething();\n        }\n\n        if (b) {\n          doSomething();\n        }\n\n        if (c) {\n          doSomething();\n        }\n\n        if (c || b) {\n          doSomething();\n        }\n    }\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2479": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Whitespace and control characters in literals should be explicit\nDescription: Why is this an issue?\nNon-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either\ninvisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control\ncharacter use their encoded version (ex: ASCII\n\\n,\\t,\n\u2026\u200b or Unicode\nU+000D, U+0009,\n\u2026\u200b).\nThis rule raises an issue when the following characters are seen in a literal string:\n1. ASCII control character. (character index < 32 or = 127)\n2. Unicodewhitespace characters.\n3. UnicodeC0 control characters\n4. Unicode charactersU+200B, U+200C, U+200D, U+2060, U+FEFF, U+2028, U+2029\nNo issue will be raised on the simple space character. Unicode\nU+0020\n, ASCII 32.\nNoncompliant code example\n```java\nString tabInside = \"A\tB\";  // Noncompliant, contains a tabulation\nString zeroWidthSpaceInside = \"foo\u200bbar\"; // Noncompliant, it contains a U+200B character inside\nchar tab = '\t';\n```\nCompliant solution\n```java\nString tabInside = \"A\\tB\";  // Compliant, uses escaped value\nString zeroWidthSpaceInside = \"foo\\u200Bbar\";  // Compliant, uses escaped value\nchar tab = '\\t';\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2447": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"null\" should not be returned from a \"Boolean\" method\nDescription: Why is this an issue?\nCallers of a\nBoolean\nmethod may be expecting to receive\ntrue\nor\nfalse\nin response. But\nBoolean\nobjects can take\nnull\nas a possible value.\nBoolean\nmethods should not return\nnull\nunless the code is annotated\nappropriately. With the proper annotation, the caller is aware that the returned value could be null.\nNoncompliant code example\n```java\npublic Boolean isUsable() {\n  // ...\n  return null;  // Noncompliant\n}\n\npublic void caller() {\n  if (isUsable()) { // A NullPointerException might occur here\n    // ...\n  }\n}\n```\nCompliant solution\n```java\n@javax.annotation.Nullable\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\n@javax.annotation.CheckForNull\npublic Boolean isUsable() {\n  // ...\n  return null;\n}\n\npublic void caller() {\n  if (Boolean.True.equals(isUsable())) { // This caller knows to check and avoid ambiguity\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2444": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lazy initialization of \"static\" fields should be \"synchronized\"\nDescription: Why is this an issue?\nIn a multi-threaded situation, un-\nsynchronized\nlazy initialization of static fields could mean that a second thread has access to a\nhalf-initialized object while the first thread is still creating it. Allowing such access could cause serious bugs. Instead. the initialization block\nshould be\nsynchronized\n.\nSimilarly, updates of such fields should also be\nsynchronized\n.\nThis rule raises an issue whenever a lazy static initialization is done on a class with at least one\nsynchronized\nmethod, indicating\nintended usage in multi-threaded applications.\nNoncompliant code example\n```java\nprivate static Properties fPreferences = null;\n\nprivate static Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties(); // Noncompliant\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n```\nCompliant solution\n```java\nprivate static Properties fPreferences = null;\n\nprivate static synchronized Properties getPreferences() {\n        if (fPreferences == null) {\n            fPreferences = new Properties();\n            fPreferences.put(\"loading\", \"true\");\n            fPreferences.put(\"filterstack\", \"true\");\n            readPreferences();\n        }\n        return fPreferences;\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2442": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Synchronizing on a \"Lock\" object should be avoided\nDescription: Why is this an issue?\njava.util.concurrent.locks.Lock\noffers far more powerful and flexible locking operations than are available with\nsynchronized\nblocks. So synchronizing on a\nLock\ninstance throws away the power of the object, as it overrides its better\nlocking mechanisms. Instead, such objects should be locked and unlocked using one of their\nlock\nand\nunlock\nmethod\nvariants.\nNoncompliant code example\n```java\nLock lock = new MyLockImpl();\nsynchronized(lock) {  // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\nLock lock = new MyLockImpl();\nif (lock.tryLock()) {\n  try {\n    // ...\n  } finally {\n    lock.unlock();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2440": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes with only \"static\" methods should not be instantiated\nDescription: Why is this an issue?\nstatic\nmethods can be accessed without an instance of the enclosing class, so there\u2019s no reason to instantiate a class that has only\nstatic\nmethods.\nNoncompliant code example\n```java\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"<[^>]+>\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    TextUtils textUtils = new TextUtils(); // Noncompliant\n\n    String stripped = textUtils.stripHtml(source);\n\n    //...\n  }\n}\n```\nCompliant solution\n```java\npublic class TextUtils {\n  public static String stripHtml(String source) {\n    return source.replaceAll(\"<[^>]+>\", \"\");\n  }\n}\n\npublic class TextManipulator {\n\n  // ...\n\n  public void cleanText(String source) {\n    String stripped = TextUtils.stripHtml(source);\n\n    //...\n  }\n}\n```\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2438": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Thread\" should not be used where a \"Runnable\" argument is expected\nDescription: Why is this an issue?\nThe semantics of\nThread\nand\nRunnable\nare different, and while it is technically correct to use\nThread\nwhere\na\nRunnable\nis expected, it is a bad practice to do so.\nThe crux of the issue is that\nThread\nis a larger concept than\nRunnable\n. A\nRunnable\nrepresents a task. A\nThread\nrepresents a task and its execution management (ie: how it should behave when started, stopped, resumed, \u2026\u200b). It is both a task\nand a lifecycle management.\nNoncompliant code example\n```java\npublic static void main(String[] args) {\n\tThread runnable = new Thread() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic static void main(String[] args) {\n\tRunnable runnable = new Runnable() {\n\t\t@Override\n\t\tpublic void run() { /* ... */ }\n\t};\n\tnew Thread(runnable).start();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2437": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnecessary bit operations should not be performed\nDescription: Why is this an issue?\nCertain bit operations are just silly and should not be performed because their results are predictable.\nSpecifically, using\n& -1\nwith any value will always result in the original value, as will\nanyValue ^ 0\nand\nanyValue | 0\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2388": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Inner class calls to super class methods should be unambiguous\nDescription: Why is this an issue?\nAn inner class that extends another type can call methods from both the outer class and parent type directly, without prepending\nsuper.\nor\nOuter.this.\n.\nWhen both the outer and parent classes contain a method with the same name, the compiler will resolve an unqualified call to the parent type\u2019s\nimplementation. The maintainer or a future reader may confuse the method call as calling the outer class\u2019s implementation, even though it really calls\nthe super type\u2019s.\nTo make matters worse, the maintainer sees the outer class\u2019s implementation in the same file as the call in the inner class, while the parent type\nis often declared in another file. The maintainer may not even be aware of the ambiguity present, as they do not see the parent\u2019s implementation.\nHow to fix it\nExplicitly call the super type\u2019s method by prepending\nsuper.\nto the method call. If the intention was to call the outer class\u2019s\nimplementation, prepend\nOuter.this.\ninstead.\nCode examples\nNoncompliant code example\n```java\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      foo();  // Noncompliant, it is not explicit if Outer#foo or Parent#foo is the intended implementation to be called.\n      // ...\n    }\n  }\n}\n```\nCompliant solution\n```java\npublic class Parent {\n  public void foo() { ... }\n}\n\npublic class Outer {\n  public void foo() { ... }\n\n  public class Inner extends Parent {\n    public void doSomething() {\n      super.foo(); // Compliant, it is explicit that Parent#foo is the desired implementation to be called.\n      // ...\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2387": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Child class fields should not shadow parent class fields\nDescription: Why is this an issue?\nHaving a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy and you\u2019ll get confusion at\nbest, chaos at worst.\nNoncompliant code example\n```java\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripe;  // Noncompliant\n  private static Color FLESH; // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class Fruit {\n  protected Season ripe;\n  protected Color flesh;\n\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private boolean ripened;\n  private static Color FLESH_COLOR;\n\n}\n```\nExceptions\nThis rule ignores same-name fields that are\nstatic\nin both the parent and child classes. This rule ignores\nprivate\nparent\nclass fields, but in all other such cases, the child class field should be renamed.\n```java\npublic class Fruit {\n  private Season ripe;\n  // ...\n}\n\npublic class Raspberry extends Fruit {\n  private Season ripe;  // Compliant as parent field 'ripe' is anyway not visible from Raspberry\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2386": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Mutable fields should not be \"public static\"\nDescription: Why is this an issue?\nThere is no good reason to have a mutable object as the\npublic\n(by default),\nstatic\nmember of an\ninterface\n.\nSuch variables should be moved into classes and their visibility lowered.\nSimilarly, mutable\nstatic\nmembers of classes and enumerations which are accessed directly, rather than through getters and setters,\nshould be protected to the degree possible. That can be done by reducing visibility or making the field\nfinal\nif appropriate.\nNote that making a mutable field, such as an array,\nfinal\nwill keep the variable from being reassigned, but doing so has no effect on\nthe mutability of the internal state of the array (i.e. it doesn\u2019t accomplish the goal).\nThis rule raises issues for\npublic static\narray,\nCollection\n,\nDate\n, and\nawt.Point\nmembers.\nNoncompliant code example\n```java\npublic interface MyInterface {\n  public static String [] strings; // Noncompliant\n}\n\npublic class A {\n  public static String [] strings1 = {\"first\",\"second\"};  // Noncompliant\n  public static String [] strings2 = {\"first\",\"second\"};  // Noncompliant\n  public static List<String> strings3 = new ArrayList<>();  // Noncompliant\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2384": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Private mutable members should not be stored or returned directly\nDescription: Why is this an issue?\nMutable objects are those whose state can be changed. For instance, an array is mutable, but a String is not. Private mutable class members should\nnever be returned to a caller or accepted and stored directly. Doing so leaves you vulnerable to unexpected changes in your class state.\nInstead use an unmodifiable\nCollection\n(via\nCollections.unmodifiableCollection\n,\nCollections.unmodifiableList\n, \u2026\u200b) or make a copy of the mutable object, and store or return the copy instead.\nThis rule checks that private arrays, collections and Dates are not stored or returned directly.\nExceptions\nThe rule violation is not reported for mutable values stored in private methods if no non-private methods directly passes a mutable parameter to\nthem.\nSimilarly, rule violations are not reported for mutable values returned by a private getter if that getter\u2019s value is not directly exposed by a\nnon-private method.\nNoncompliant code example\n```java\nclass A {\n  private String[] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return strings; // Noncompliant\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings;  // Noncompliant\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"yellow\", \"second\"};\n  }\n}\n```\nCompliant solution\n```java\nclass A {\n  private String [] strings;\n\n  public A () {\n    strings = new String[]{\"first\", \"second\"};\n  }\n\n  public String[] getStrings() {\n    return getStringsInternal().clone();\n  }\n\n  private String[] getStringsInternal() {\n    return strings;\n  }\n\n  private void setStringsInternal(String[] strings) {\n    this.strings = strings;\n  }\n\n  public void setStrings(String[] strings) {\n    this.strings = strings.clone();\n  }\n}\n\npublic class B {\n\n  private A a = new A();  // At this point a.strings = {\"first\", \"second\"};\n\n  public void wreakHavoc() {\n    a.getStrings()[0] = \"yellow\";  // a.strings = {\"first\", \"second\"};\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2333": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant modifiers should not be used\nDescription: Why is this an issue?\nThe methods declared in an\ninterface\nare\npublic\nand\nabstract\nby default. Any variables are automatically\npublic static final\n. Finally,\nclass\nand\ninterface\nare automatically\npublic static\n. There is no\nneed to explicitly declare them so.\nSince annotations are implicitly interfaces, the same holds true for them as well.\nSimilarly, the\nfinal\nmodifier is redundant on any method of a\nfinal\nclass,\nprivate\nis redundant on the\nconstructor of an\nEnum\n, and\nstatic\nis redundant for\ninterface\nnested into a\nclass\nor\nenum\n.\nNoncompliant code example\n```java\npublic interface Vehicle {\n\n  public void go(int speed, Direction direction);  // Noncompliant\n```\nCompliant solution\n```java\npublic interface Vehicle {\n\n  void go(int speed, Direction direction);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2326": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused type parameters should be removed\nDescription: Why is this an issue?\nType parameters that aren\u2019t used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type\nparameters should be removed.\nNoncompliant code example\n```java\nint <T> Add(int a, int b) // Noncompliant; <T> is ignored\n{\n  return a + b;\n}\n```\nCompliant solution\n```java\nint Add(int a, int b)\n{\n  return a + b;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2325": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"private\" and \"final\" methods that don't access instance data should be \"static\"\nDescription: Why is this an issue?\nNon-overridable methods (\nprivate\nor\nfinal\n) that don\u2019t access instance data can be\nstatic\nto prevent any\nmisunderstanding about the contract of the method.\nNoncompliant code example\n```java\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private String getMagicWord() { // Noncompliant\n    return magicWord;\n  }\n\n  private void setMagicWord(String value) { // Noncompliant\n    magicWord = value;\n  }\n\n}\n```\nCompliant solution\n```java\nclass Utilities {\n  private static String magicWord = \"magic\";\n\n  private static String getMagicWord() {\n    return magicWord;\n  }\n\n  private static void setMagicWord(String value) {\n    magicWord = value;\n  }\n\n}\n```\nExceptions\nWhen\njava.io.Serializable\nis implemented the following three methods are excluded by the rule:\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2309": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should not be empty\nDescription: Why is this an issue?\nFiles with no lines of code clutter a project and should be removed.\nNoncompliant code example\n```java\n//package org.foo;\n//\n//public class Bar {}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2308": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"deleteOnExit\" should not be used\nDescription: Why is this an issue?\nUse of\nFile.deleteOnExit()\nis not recommended for the following reasons:\n1. The deletion occurs only in the case of a normal JVM shutdown but not when the JVM crashes or is killed.\n2. For each file handler, the memory associated with the handler is released only at the end of the process.\nNoncompliant code example\n```java\nFile file = new File(\"file.txt\");\nfile.deleteOnExit();  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2301": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Public methods should not contain selector arguments\nDescription: Why is this an issue?\nA selector argument is a\nboolean\nargument that\u2019s used to determine which of two paths to take through a method. Specifying such a\nparameter may seem innocuous, particularly if it\u2019s well named.\nUnfortunately, the maintainers of the code calling the method won\u2019t see the parameter name, only its value. They\u2019ll be forced either to guess at\nthe meaning or to take extra time to look the method up.\nInstead, separate methods should be written.\nThis rule finds methods with a\nboolean\nthat\u2019s used to determine which path to take through the method.\nNoncompliant code example\n```java\npublic String tempt(String name, boolean ofAge) {\n  if (ofAge) {\n    offerLiquor(name);\n  } else {\n    offerCandy(name);\n  }\n}\n\n// ...\npublic void corrupt() {\n  tempt(\"Joe\", false); // does this mean not to temp Joe?\n}\n```\nCompliant solution\n```java\npublic void temptAdult(String name) {\n  offerLiquor(name);\n}\n\npublic void temptChild(String name) {\n    offerCandy(name);\n}\n\n// ...\npublic void corrupt() {\n  age < legalAge ? temptChild(\"Joe\") : temptAdult(\"Joe\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2293": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The diamond operator (\"<>\") should be used\nDescription: Why is this an issue?\nJava uses angular brackets (\n<\nand\n>\n) to provide a specific type (the \"type argument\") to a generic type. For\ninstance,\nList\nis a generic type, so a list containing strings can be declared with\nList<String>\n.\nPrior to Java 7, the type argument had to be provided explicitly for every occurrence where generics were used. This often caused redundancy, as\nthe type argument would have to be provided both when a field is declared and initialized.\nJava 7 introduced the diamond operator (\n<>\n) to reduce the code\u2019s verbosity in some situations. The type argument between the\nangular brackets should be omitted if the compiler can infer it.\nSince the diamond operator was only introduced in Java 7, this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis\nlower than\n7\n.\nHow to fix it\nThe type argument should be omitted in the initialization if it is already present in the declaration of a field or variable.\nFor instance, a field with type\nList<String>\ncan be initialized with\nArrayList<>()\n, as the compiler will\ninfer that\nArrayList<String>()\nis the actually desired call.\nCode examples\nNoncompliant code example\n```java\nList<String> strings = new ArrayList<String>();                       // Noncompliant, the compiler can infer the type argument of the constructor invocation\nMap<String,List<Integer>> map = new HashMap<String,List<Integer>>();  // Noncompliant, the compiler can also infer complex type arguments\n```\nCompliant solution\n```java\nList<String> strings = new ArrayList<>();        // Compliant, the compiler will infer the type argument\nMap<String,List<Integer>> map = new HashMap<>(); // Compliant, the compiler will infer the type argument\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2274": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Object.wait(...)\" and \"Condition.await(...)\" should be called inside a \"while\" loop\nDescription: Why is this an issue?\nIn a multithreaded environment, the\nObject.wait(\u2026\u200b)\n, as well as\nCondition.await(\u2026\u200b)\nand similar methods are used to pause\nthe execution of a thread until the thread is awakened. A thread is typically awakened when it is notified, signaled, or interrupted, usually because\nof an event in another thread requiring some subsequent action by the waiting thread.\nHowever, a thread may be awakened despite the desired condition not being met or the desired event not having happened. This is referred to as\n\"spurious wakeups\" and may be caused by underlying platform semantics. In other words, a thread may be awakened due to reasons that have nothing to do\nwith the business logic. Hence, the assumption that the desired condition is met or the desired event occurred after a thread is awakened does not\nalways hold.\nAccording to the documentation of the Java\nCondition\ninterface [1]:\nWhen waiting upon a\nCondition\n, a \"spurious wakeup\" is permitted to occur, in general, as a concession to the underlying platform\n  semantics. This has little practical impact on most application programs as a Condition should always be waited upon in a loop, testing the state\n  predicate that is being waited for. An implementation is free to remove the possibility of spurious wakeups but it is recommended that applications\n  programmers always assume that they can occur and so always wait in a loop.\nThe same advice is also found for the\nObject.wait(\u2026\u200b)\nmethod [2]:\n[\u2026\u200b] waits should always occur in loops, like this one:\n```java\nsynchronized (obj) {\n  while (<condition does not hold>){\n    obj.wait(timeout);\n  }\n   ... // Perform action appropriate to condition\n}\n```\nHow to fix it\nMake sure that the desired condition is actually true after being awakened. This can be accomplished by calling the\nwait\nor\nawait\nmethods inside a loop that checks said condition.\nCode examples\nNoncompliant code example\n```java\nsynchronized (obj) {\n  if (!suitableCondition()){\n    obj.wait(timeout); // Noncompliant, the thread can be awakened even though the condition is still false\n  }\n   ... // Perform some logic that is appropriate for when the condition is true\n}\n```\nCompliant solution\n```java\nsynchronized (obj) {\n  while (!suitableCondition()){\n    obj.wait(timeout); // Compliant, the condition is checked in a loop, so the action below will only occur if the condition is true\n  }\n   ... // Perform some logic that is appropriate for when the condition is true\n}\n```\nJava SE 17 & JDK 17\n-\n  Condition\nJava Platform SE 8\n- Object#wait\nCERT THI03-J.\n- Always invoke wait() and await() methods inside a loop\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2260": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Java parser failure\nDescription: Why is this an issue?\nWhen the Java parser fails, it is possible to record the failure as a violation on the file. This way, not only it is possible to track the number\nof files that do not parse but also to easily find out why they do not parse.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2253": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of disallowed methods\nDescription: Why is this an issue?\nThis rule allows banning certain methods.\nNoncompliant code example\nGiven parameters:\n1. className:java.lang.String\n2. methodName: replace\n3. argumentTypes: java.lang.CharSequence, java.lang.CharSequence\n```java\nString name;\nname.replace(\"A\",\"a\");  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2250": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Collection methods with O(n) performance should be used carefully\nDescription: Why is this an issue?\nThe time complexity of method calls on collections is not always obvious. For instance, for most collections the\nsize()\nmethod takes\nconstant time, but the time required to execute\nConcurrentLinkedQueue.size()\nis O(n), i.e. directly proportional to the number of\nelements in the collection. When the collection is large, this could therefore be an expensive operation.\nThis rule raises an issue when the following O(n) methods are called outside of constructors on class fields:\n1. ArrayListcontainsremove\n2. contains\n3. remove\n4. LinkedListgetcontains\n5. get\n6. contains\n7. ConcurrentLinkedQueuesizecontains\n8. size\n9. contains\n10. ConcurrentLinkedDequesizecontains\n11. size\n12. contains\n13. CopyOnWriteArrayListaddcontainsremove\n14. add\n15. contains\n16. remove\n17. CopyOnWriteArraySetaddcontainsremove\n18. add\n19. contains\n20. remove\nNoncompliant code example\n```java\nConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();\n//...\nlog.info(\"Queue contains \" + queue.size() + \" elements\");  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2235": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"IllegalMonitorStateException\" should not be caught\nDescription: Why is this an issue?\nThe\nIllegalMonitorStateException\nis an exception that occurs when a thread tries to perform an operation on an object\u2019s monitor that\nit does not own. This exception is typically thrown when a method like\nwait()\n,\nnotify()\n, or\nnotifyAll()\nis\ncalled outside a synchronized block or method.\nIllegalMonitorStateException\nis specifically designed to be an unchecked exception to point out a programming mistake. This exception\nserves as a reminder for developers to rectify their code by correctly acquiring and releasing locks using synchronized blocks or methods. It also\nemphasizes the importance of calling monitor-related methods on the appropriate objects to ensure proper synchronization.\nCatching and handling this exception can mask underlying synchronization issues and lead to unpredictable behavior.\nNoncompliant code example\n```java\npublic void doSomething() {\n  try {\n    anObject.notify();\n  } catch(IllegalMonitorStateException e) { // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  synchronized(anObject) {\n    anObject.notify();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2234": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Parameters should be passed in the correct order\nDescription: Why is this an issue?\nWhen the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when\nthe names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead\nto unexpected results.\nNoncompliant code example\n```java\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\n  //...\n}\n```\nCompliant solution\n```java\npublic double divide(int divisor, int dividend) {\n  return divisor/dividend;\n}\n\npublic void doTheThing() {\n  int divisor = 15;\n  int dividend = 5;\n\n  double result = divide(divisor, dividend);\n  //...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2232": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"ResultSet.isLast()\" should not be used\nDescription: Why is this an issue?\nThere are several reasons to avoid using this method:\nIt is optionally available only for result sets of type\nResultSet.TYPE_FORWARD_ONLY\n. Database drivers will throw an exception if\n  not supported.\nThe method can be expensive to execute as the database driver may need to fetch ahead one row to determine whether the current row is the last\n  in the result set. The documentation of the method explicitly mentions this fact.\nWhat \"the cursor is on the last row\" means for an empty\nResultSet\nis unclear. Database drivers may return\ntrue\nor\nfalse\nin this case .\nResultSet.next()\nis a good alternative to\nResultSet.isLast()\nas it does not have the mentioned issues. It is always\nsupported and, as per specification, returns\nfalse\nfor empty result sets.\nHow to fix it\nRefactor your code to use\nResultSet.next()\ninstead of\nResultSet.isLast()\n. Be cautious of its different semantics and side\neffects on cursor positioning in the result set. Verify that your program logic is still valid under these side effects and otherwise adjust it.\nCode examples\nNoncompliant code example\n```java\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nStringBuilder sb = new StringBuilder();\nwhile (results.next() && !results.isLast()) { // Noncompliant\n  sb.append(results.getString(\"name\") + \", \");\n}\nsb.append(results.getString(\"name\"));\nString formattedNames = sb.toString();\n```\nCompliant solution\n```java\nResultSet results = stmt.executeQuery(\"SELECT name, address FROM PERSON\");\nList<String> names = new ArrayList<>();\nwhile (results.next()) { // Compliant, and program logic refactored\n  names.add(results.getString(\"name\"));\n}\nString formattedNames =  names.stream().collect(Collectors.joining(\", \"));\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2221": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Exception\" should not be caught when not required by called methods\nDescription: Why is this an issue?\nCatching\nException\nseems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types,\nboth checked and runtime exceptions, thereby casting too broad a net. Indeed, was it really the intention of developers to also catch runtime\nexceptions? To prevent any misunderstanding, if both checked and runtime exceptions are really expected to be caught, they should be explicitly listed\nin the\ncatch\nclause.\nThis rule raises an issue if\nException\nis caught when it is not explicitly thrown by a method in the\ntry\nblock.\nNoncompliant code example\n```java\ntry {\n  // do something that might throw an UnsupportedDataTypeException or UnsupportedEncodingException\n} catch (Exception e) { // Noncompliant\n  // log exception ...\n}\n```\nCompliant solution\n```java\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException|RuntimeException e) {\n  // log exception ...\n}\n```\nor if runtime exceptions should not be caught:\n```java\ntry {\n  // do something\n} catch (UnsupportedEncodingException|UnsupportedDataTypeException e) {\n  // log exception ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2211": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Types should be used in lambdas\nDescription: Why is this an issue?\nShared coding conventions allow teams to collaborate effectively. While types for lambda arguments are optional, specifying them anyway makes the\ncode clearer and easier to read.\nNoncompliant code example\n```java\nArrays.sort(rosterAsArray,\n    (a, b) -> {  // Noncompliant\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n```\nCompliant solution\n```java\nArrays.sort(rosterAsArray,\n    (Person a, Person b) -> {\n        return a.getBirthday().compareTo(b.getBirthday());\n    }\n);\n```\nExceptions\nWhen the lambda has one or two parameters and does not have a block this rule will not fire up an issue as things are considered more readable in\nthose cases.\n```java\nstream.map((a, b) -> a.length); // compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2209": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"static\" members should be accessed statically\nDescription: Why is this an issue?\nWhile it is\npossible\nto access\nstatic\nmembers from a class instance, it\u2019s bad form, and considered by most to be misleading\nbecause it implies to the readers of your code that there\u2019s an instance of the member per class instance.\nNoncompliant code example\n```java\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    first.counter ++;  // Noncompliant\n    second.counter ++;  // Noncompliant. A.counter is now 2, which is perhaps contrary to expectations\n  }\n}\n```\nCompliant solution\n```java\npublic class A {\n  public static int counter = 0;\n}\n\npublic class B {\n  private A first = new A();\n  private A second = new A();\n\n  public void runUpTheCount() {\n    A.counter ++;  // Compliant\n    A.counter ++;  // Compliant\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2208": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Wildcard imports should not be used\nDescription: Why is this an issue?\nUsing wildcards in imports may look cleaner as it reduces the number of lines in the import section and simplifies the code.\nOn the other hand,\nit makes the code harder to maintain:\n1. It reduces code readability as developers will have a hard time knowing where names come from.\n2. It could lead to conflicts between names defined locally and the ones imported.\n3. It could later raise conflicts on dependency upgrade or Java version migration, as a wildcard import that works today might be broken tomorrow.\nThat is why it is better to import only the specific classes or modules you need.\nExceptions\nStatic imports are ignored by this rule. For example:\n```java\nimport static java.lang.Math.*;\n```\nwill not raise an issue;\nHow to fix it\nDepending on your IDE you can solve this issue almost\nautomatically\n:\nLook for\nOrganize/Optimize imports\nactions. These actions can also often be applied automatically on save.\nNote:\nTo make this work properly, you must adjust IDE settings to\nuse a very high\nallowed class count usage\nbefore using wildcards.\nResolving this issue\nmanually\nwill require a step-by-step approach:\nRemove one wildcard import and note down compilation failures.\nFor each missing class, import it back with the package prefix.\nWhen the code compiles again, proceed with the next wildcard import.\nCode examples\nNoncompliant code example\n```java\nimport java.sql.*; // Noncompliant\nimport java.util.*; // Noncompliant\n\nprivate Date date; // Date class exists in java.sql and java.util. Which one is this?\n```\nCompliant solution\n```java\nimport java.sql.Date;\nimport java.util.List;\nimport java.util.ArrayList;\n\nprivate Date date;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2203": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"collect\" should be used with \"Streams\" instead of \"list::add\"\nDescription: Why is this an issue?\nWhile you can use either\nforEach(list::add)\nor\ncollect\nwith a\nStream\n,\ncollect\nis by far the\nbetter choice because it\u2019s automatically thread-safe and parallellizable.\nNoncompliant code example\n```java\nList<String> bookNames = new ArrayList<>();\nbooks.stream().filter(book -> book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .forEach(bookNames::add);  // Noncompliant\n```\nCompliant solution\n```java\nList<String> bookNames = books.stream().filter(book -> book.getIsbn().startsWith(\"0\"))\n                .map(Book::getTitle)\n                .collect(Collectors.toList());\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2197": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Modulus results should not be checked for direct equality\nDescription: Why is this an issue?\nWhen the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for\nequality with a positive number (or a negative one) could result in unexpected results.\nNoncompliant code example\n```java\npublic boolean isOdd(int x) {\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\n}\n```\nCompliant solution\n```java\npublic boolean isOdd(int x) {\n  return x % 2 != 0;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2196": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Switches should be used for sequences of simple \"String\" tests\nDescription: Why is this an issue?\nSince Java 7,\nString\ns can be used as\nswitch\narguments. So when a single\nString\nis tested against three or\nmore values in an\nif\n/\nelse if\nstructure, it should be converted to a switch instead for greater readability.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\nif (\"red\".equals(choice)) {  // Noncompliant\n  dispenseRed();\n} else if (\"blue\".equals(choice)) {\n  dispenseBlue();\n} else if (\"yellow\".equals(choice)) {\n  dispenseYellow();\n} else {\n  promptUser();\n}\n```\nCompliant solution\n```java\nswitch(choice) {\n  case \"Red\":\n    dispenseRed();\n    break;\n  case \"Blue\":\n    dispenseBlue():\n    break;\n  case \"Yellow\":\n    dispenseYellow();\n    break;\n  default:\n    promptUser();\n    break;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2188": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit test cases should call super methods\nDescription: Why is this an issue?\nOverriding a parent class method prevents that method from being called unless an explicit\nsuper\ncall is made in the overriding\nmethod. In some cases, not calling the parent method is fine. However,\nsetUp\nand\ntearDown\nprovide some shared logic that is\ncalled before all test cases. This logic may change over the lifetime of your codebase. To make sure that your test cases are set up and cleaned up\nconsistently, your overriding implementations of\nsetUp\nand\ntearDown\nshould call the parent implementations explicitly.\nHow to fix it\nAdd an explicit call to\nsuper.setUp()\nand\nsuper.tearDown()\nin the overriding methods.\nCode examples\nNoncompliant code example\n```java\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {  // Noncompliant\n    myClass = new MyClass();\n  }\n}\n```\nCompliant solution\n```java\npublic class MyClassTest extends MyAbstractTestCase {\n\n  private MyClass myClass;\n\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myClass = new MyClass();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2187": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: TestCases should contain tests\nDescription: Why is this an issue?\nThere\u2019s no point in having a JUnit\nTestCase\nwithout any test methods. Similarly, you shouldn\u2019t have a file in the tests directory\nnamed\n*Test\n,\n*Tests\n, or\n*TestCase\n, but no tests in the file. Doing either of these things may lead someone to\nthink that uncovered classes have been tested.\nThis rule raises an issue when files in the test directory are named\n*Test\n,\n*Tests\n, or\n*TestCase\nor\nimplement\nTestCase\nbut don\u2019t contain any tests.\nSupported frameworks:\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2186": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit assertions should not be used in \"run\" methods\nDescription: Why is this an issue?\nJUnit assertions should not be made from the\nrun\nmethod of a\nRunnable\n, because their failure may not be detected in the\ntest that initiated them. Failed assertions throw assertion errors. However, if the error is thrown from another thread than the one that initiated\nthe test, the thread will exit but the test will not fail.\nHow to fix it\nAssertions in\nRunnable\ntasks should be extracted or executed by the main thread to make the whole test fail.\nCode examples\nNoncompliant code example\n```java\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // Noncompliant\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.start(); // The assertion in the run method above will be executed by other thread than the current one\n    // ...\n    // Perform some actions that do not make the test fail\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n```\nCompliant solution\n```java\nclass RunnableWithAnAssertion extends Thread {\n  @Override\n  public void run() {\n    Assert.assertEquals(expected, actual);  // Noncompliant\n  }\n\n  @Test\n  void test() {\n    RunnableWithAnAssertion otherThread = new RunnableWithAnAssertion();\n    otherThread.run();\n    // ...\n    // The failed assertions in the run method will prevent us from reaching the assertion below\n    // ...\n    Assert.assertTrue(true);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2185": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Do not perform unnecessary mathematical operations\nDescription: Why is this an issue?\nSome mathematical operations are unnecessary and should not be performed because their results are predictable.\nFor instance,\nanyValue % 1\nwill always return 0, as any integer value can be divided by 1 without remainder.\nSimilarly, casting a non-floating-point to a floating-point value and then passing it to\nMath.round\n,\nMath.ceil\n, or\nMath.floor\nis also unnecessary, as the result will always be the original value.\nThe following operations are unnecessary when given any constant value:\nMath.abs\n,\nMath.ceil\n,\nMath.floor\n,\nMath.rint\n,\nMath.round\n. Instead, use the result of the operation directly.\nThe following operations are unnecessary with certain constants and can be replaced by the result of the operation directly:\nOperation\nValue\nacos\n0.0 or 1.0\nasin\n0.0 or 1.0\natan\n0.0 or 1.0\natan2\n0.0\ncbrt\n0.0 or 1.0\ncos\n0.0\ncosh\n0.0\nexp\n0.0 or 1.0\nexpm1\n0.0\nlog\n0.0 or 1.0\nlog10\n0.0 or 1.0\nsin\n0.0\nsinh\n0.0\nsqrt\n0.0 or 1.0\ntan\n0.0\ntanh\n0.0\ntoDegrees\n0.0 or 1.0\ntoRadians\n0.0\nHow to fix it\nAsk yourself if the questionable operation represents the desired calculation or if a value used is erroneous. If the calculation is correct,\nreplace it with the result to avoid having to perform the unnecessary operation at runtime.\nCode examples\nNoncompliant code example\n```java\npublic void doMath(int a) {\n  double res1 = Math.floor((double)a); // Noncompliant, the result will always be equal to '(double) a'\n  double res2 = Math.ceil(4.2);        // Noncompliant, the result will always be 5.0\n  double res3 = Math.atan(0.0);        // Noncompliant, the result will always be 0.0\n}\n```\nCompliant solution\n```java\npublic void doMath(int a) {\n  double res1 = a;    // Compliant\n  double res2 = 5.0;  // Compliant\n  double res3 = 0.0;  // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2178": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Short-circuit logic should be used in boolean contexts\nDescription: Why is this an issue?\nThe use of non-short-circuit logic in a boolean context is likely a mistake - one that could cause serious program errors as conditions are\nevaluated under the wrong circumstances.\nNoncompliant code example\n```java\nif(getTrue() | getFalse()) { ... } // Noncompliant; both sides evaluated\n```\nCompliant solution\n```java\nif(getTrue() || getFalse()) { ... } // true short-circuit logic\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2176": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class names should not shadow interfaces or superclasses\nDescription: Why is this an issue?\nTwo classes can have the same simple name if they are in two different packages.\n```java\npackage org.foo.domain;\n\npublic class User {\n  // ..\n}\n```\n```java\npackage org.foo.presentation;\n\npublic class User {\n  // ..\n}\n```\nHowever, this becomes an issue when a class has the same name as the superclass it extends or the interfaces it implements, also known as class\nname shadowing. It is problematic because it can be unclear which class is being referred to in the code, leading to ambiguity and potential bugs.\nTherefore, it is recommended to use unique and descriptive class names that do not conflict with the names of the superclass or interfaces.\nThis rule raises an issue when a class name shadows its superclass or interface names.\nHow to fix it\nRename the class using a more descriptive name.\nCode examples\nNoncompliant code example\n```java\npackage org.foo.presentation;\n\npublic class User implements org.foo.domain.User { // Noncompliant\n  // ...\n}\n```\nCompliant solution\n```java\npackage org.foo.presentation;\n\nimport org.foo.domain.User;\n\npublic class UserView implements User { // Compliant\n  // ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2166": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes named like \"Exception\" should extend \"Exception\" or a subclass\nDescription: Why is this an issue?\nClear, communicative naming is important in code. It helps maintainers and API users understand the intentions for and uses of a unit of code.\nUsing \"exception\" in the name of a class that does not extend\nException\nor one of its subclasses is a clear violation of the expectation\nthat a class' name will indicate what it is and/or does.\nNoncompliant code example\n```java\npublic class FruitException {  // Noncompliant; this has nothing to do with Exception\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException {  // Noncompliant; the extends clause was forgotten?\n  public CarException(String message, Throwable cause) {\n  // ...\n```\nCompliant solution\n```java\npublic class FruitSport {\n  private Fruit expected;\n  private String unusualCharacteristics;\n  private boolean appropriateForCommercialExploitation;\n  // ...\n}\n\npublic class CarException extends Exception {\n  public CarException(String message, Throwable cause) {\n  // ...\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2165": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"finalize\" should not set fields to \"null\"\nDescription: This rule raises an issue when a finalizer assign\nnull\nto fields of the instance it is called on.\nWhy is this an issue?\nIn the Java object lifecycle, the\nfinalize\nmethod for an instance is called after the garbage collector has determined that the\ninstance can be removed from the object heap. Therefore, it is unnecessary to implement a finalizer to set instance fields explicitly to\nnull\nto tell the garbage collector that the instance no longer needs them.\nIn the worst case, implementing\nfinalize\nis even counterproductive because it might accidentally create new references from other\n(living) objects on the heap to the collectible instance, thus, reviving it.\nImportant note about finalizers:\nThere are no guarantees when the Java Runtime will call the\nfinalize\nmethod or whether it will be called at all.\nUsing finalizers is, therefore, a bad practice. They should never be used to free resources, such as closing streams, freeing locks, or freeing\nnative system resources. Consider other freeing mechanisms instead, such as an explicit\nclose\n,\nunlock\n, or\nfree\nmethod in your class.\nHow to fix it\nRemove assignments from your finalizer that assign\nnull\nto fields of the instance the finalizer is called on. When this leaves you\nwith an empty finalizer body, remove the finalizer.\nCode examples\nNoncompliant code example\n```java\npublic class Foo {\n  private String name;\n\n  @Override\n  void finalize() {\n    name = null;  // Noncompliant, instance will be removed anyway\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo { // Compliant\n  private String name;\n}\n```\nDocumentation\n1. Java SE 8 API Specification - Object.finalize\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2160": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Subclasses that add fields to classes that override \"equals\" should also override \"equals\"\nDescription: This rule raises an issue when a subclass of a class that overrides\nObject.equals\nintroduces new fields but does not also override the\nObject.equals\nmethod.\nWhy is this an issue?\nWhen a class overrides\nObject.equals\n, this indicates that the class not just considers object identity as equal (the default\nimplementation of\nObject.equals\n) but implements another logic for what is considered equal in the context of this class. Usually (but not\nnecessarily), the semantics of\nequals\nin this case is that two objects are equal when their state is equal field by field.\nBecause of this, adding new fields to a subclass of a class that overrides\nObject.equals\nbut not updating the implementation of\nequals\nin the subclass is most likely an error.\nHow to fix it\nConsider the following example:\n```java\nclass Foo {\n\n  final int a;\n\n  @Override\n  public boolean equals(Object other) {\n    if (other == null) return false;\n    if (getClass() != other.getClass()) return false;\n    return a == ((Foo) other).a;\n  }\n}\n```\n```java\nclass Bar extends Foo { // Noncompliant, `equals` ignores the value of `b`\n  final int b;\n}\n```\nOverride the\nequals\nmethod in the subclass to incorporate the new fields into the comparison:\n```java\nclass Bar extends Foo { // Compliant, `equals` now also considers `b`\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    if (!super.equals(other)) return false;\n    return b == ((Bar) other).b;\n  }\n}\n```\nIn case the new fields should not be part of the comparison because they are, for example, auxiliary variables not contributing to the object value\n(), still override the method to make the point clear that this was not just forgotten:\n```java\nclass Bar extends Foo { // Compliant, we do explicitly not want to take `b` into account\n\n  final int b;\n\n  @Override\n  public boolean equals(Object other) {\n    return super.equals(other);\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2157": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Cloneables\" should implement \"clone\"\nDescription: This rule raises an issue when a class implements the interface\njava.lang.Cloneable\n, but does not override the\nObject.clone()\nmethod.\nWhy is this an issue?\nCloneable\nis a\nmarker interface\nthat defines the contract of the\nObject.clone\nmethod, which is to create a\nconsistent copy of the instance. The\nclone\nmethod is not defined by the interface though, but by class\nObjects\n.\nThe general problem with marker interfaces is that their definitions cannot be enforced by the compiler because they have no own API. When a class\nimplements\nCloneable\nbut does not override\nObject.clone\n, it is highly likely that it violates the contract for\nCloneable\n.\nHow to fix it\nConsider the following example:\n```java\nclass Foo implements Cloneable { // Noncompliant, override `clone` method\n  public int value;\n}\n```\nOverride the\nclone\nmethod in class\nFoo\n. By convention, it must call\nsuper.clone()\n. At this point, we know\nthat:\n1. By behavioral contract,Object.clonewill not throw aCloneNotSupportedException, becauseFooimplementsCloneable.\n2. The returned object is an instance of classFoo\nWe can narrow down the return type of\nclone\nto\nFoo\nand handle the\nCloneNotSupportedException\ninside the\nfunction instead of throwing it:\n```java\nclass Foo implements Cloneable { // Compliant\n\n  public int value;\n\n  @Override\n  public Foo clone() {\n    try {\n      return (Foo) super.clone();\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n```\nBe aware that\nsuper.clone()\nreturns a one-by-one copy of the fields of the original instance. This means that in our example, the\nFoo.value\nfield is not required to be explicitly copied in the overridden function.\nIf you require another copy behavior for some or all of the fields, for example, deep copy or certain invariants that need to be true for a field,\nthese fields must be patched after\nsuper.clone()\n:\n```java\nclass Entity implements Cloneable {\n\n  public int id; // unique per instance\n  public List<Entity> children; // deep copy wanted\n\n  @Override\n  public Entity clone() {\n    try {\n      Entity copy = (Entity) super.clone();\n      copy.id = System.identityHashCode(this);\n      copy.children = children.stream().map(Entity::clone).toList();\n      return copy;\n    } catch (CloneNotSupportedException e) {\n      throw new AssertionError();\n    }\n  }\n}\n```\nBe aware that the\nCloneable\n/\nObject.clone\napproach has several drawbacks. You might, therefore, also consider resorting\nto other solutions, such as a custom\ncopy\nmethod or a copy constructor:\n```java\nclass Entity implements Cloneable {\n\n  public int id; // unique per instance\n  public List<Entity> children; // deep copy wanted\n\n  Entity(Entity template) {\n    id = System.identityHashCode(this);\n    children = template.children.stream().map(Entity::new).toList();\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2156": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"final\" classes should not have \"protected\" members\nDescription: Why is this an issue?\nThe difference between\nprivate\nand\nprotected\nvisibility is that child classes can see and use\nprotected\nmembers, but they cannot see\nprivate\nones. Since a\nfinal\nclass will have no children, marking the members of a\nfinal\nclass\nprotected\nis confusingly pointless.\nNote that the\nprotected\nmembers of a class can also be seen and used by other classes that are placed within the same package, this\ncould lead to accidental, unintended access to otherwise private members.\nNoncompliant code example\n```java\npublic final class MyFinalClass {\n\n  protected String name = \"Fred\";  // Noncompliant\n  protected void setName(String name) {  // Noncompliant\n    // ...\n  }\n```\nCompliant solution\n```java\npublic final class MyFinalClass {\n\n  private String name = \"Fred\";\n  public void setName(String name) {\n    // ...\n  }\n```\nExceptions\nMembers annotated with\n@VisibleForTesting\nannotation are ignored, as it indicates that visibility has been purposely relaxed to\nmake the code testable.\n```java\npublic final class MyFinalClass {\n  @VisibleForTesting\n  protected Logger logger; // Compliant\n\n  @VisibleForTesting\n  protected int calculateSomethingComplex(String input) { // Compliant\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2148": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Underscores should be used to make large numbers readable\nDescription: Why is this an issue?\nBeginning with Java 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this\nmanner has no semantic meaning, but makes it easier for maintainers to understand the code.\nThe number of digits to the left of a decimal point needed to trigger this rule varies by base.\nBase\nMinimum digits\nbinary\n9\noctal\n9\ndecimal\n6\nhexadecimal\n9\nIt is only the presence of underscores, not their spacing that is scrutinized by this rule.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\nint i = 10000000;  // Noncompliant; is this 10 million or 100 million?\nint  j = 0b01101001010011011110010101011110;  // Noncompliant\nlong l = 0x7fffffffffffffffL;  // Noncompliant\n```\nCompliant solution\n```java\nint i = 10_000_000;\nint  j = 0b01101001_01001101_11100101_01011110;\nlong l = 0x7fff_ffff_ffff_ffffL;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2147": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Catches should be combined\nDescription: Why is this an issue?\nSince Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiple\ncatch\nblocks have the same code, they\nshould be combined for better readability.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\n.\nNoncompliant code example\n```java\ncatch (IOException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (SQLException e) {  // Noncompliant\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {  // Compliant; block contents are different\n  doCleanup();\n  throw e;\n}\n```\nCompliant solution\n```java\ncatch (IOException|SQLException e) {\n  doCleanup();\n  logger.log(e);\n}\ncatch (TimeoutException e) {\n  doCleanup();\n  throw e;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2143": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"java.time\" classes should be used for dates and times\nDescription: Why is this an issue?\nThe old, much-derided\nDate\nand\nCalendar\nclasses have always been confusing and difficult to use properly, particularly in\na multi-threaded context.\nJodaTime\nhas long been a popular alternative, but now an even better option is built-in. Java 8\u2019s JSR 310\nimplementation offers specific classes for:\nClass\nUse for\nLocalDate\na date, without time of day, offset, or zone\nLocalTime\nthe time of day, without date, offset, or zone\nLocalDateTime\nthe date and time, without offset, or zone\nOffsetDate\na date with an offset such as +02:00, without time of day, or zone\nOffsetTime\nthe time of day with an offset such as +02:00, without date, or zone\nOffsetDateTime\nthe date and time with an offset such as +02:00, without a zone\nZonedDateTime\nthe date and time with a time zone and offset\nYearMonth\na year and month\nMonthDay\nmonth and day\nYear/MonthOfDay/DayOfWeek/\u2026\u200b\nclasses for the important fields\nDateTimeFields\nstores a map of field-value pairs which may be invalid\nCalendrical\naccess to the low-level API\nPeriod\na descriptive amount of time, such as \"2 months and 3 days\"\nNoncompliant code example\n```java\nDate now = new Date();  // Noncompliant\nDateFormat df = new SimpleDateFormat(\"dd.MM.yyyy\");\nCalendar christmas  = Calendar.getInstance();  // Noncompliant\nchristmas.setTime(df.parse(\"25.12.2020\"));\n```\nCompliant solution\n```java\nLocalDate now = LocalDate.now();  // gets calendar date. no time component\nLocalTime now2 = LocalTime.now(); // gets current time. no date component\nLocalDate christmas = LocalDate.of(2020,12,25);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2140": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods of \"Random\" that return floating point values should not be used in random integer generation\nDescription: Why is this an issue?\nGenerating random floating point values to cast them into integers is inefficient. A random bounded integer value can be generated with a single\nproper method call. Use\nnextInt\nto make the code more efficient and the intent clearer.\nNoncompliant code example\n```java\nRandom r = new Random();\nint rand = (int) (r.nextDouble() * 50);  // Noncompliant way to get a pseudo-random value between 0 and 50\nint rand2 = (int) r.nextFloat(); // Noncompliant; will always be 0;\n```\nCompliant solution\n```java\nRandom r = new Random();\nint rand = r.nextInt(50);  // returns pseudo-random value between 0 and 50\nint rand2 = 0;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2139": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exceptions should be either logged or rethrown but not both\nDescription: Why is this an issue?\nIn applications where the accepted practice is to log an\nException\nand then rethrow it, you end up with miles-long logs that contain\nmultiple instances of the same exception. In multi-threaded applications debugging this type of log can be particularly hellish because messages from\nother threads will be interwoven with the repetitions of the logged-and-thrown\nException\n. Instead, exceptions should be either logged or\nrethrown, not both.\nNoncompliant code example\n```java\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  throw new MySQLException(contextInfo, e);\n}\n```\nCompliant solution\n```java\ncatch (SQLException e) {\n  ...\n  throw new MySQLException(contextInfo, e);\n}\n```\nor\n```java\ncatch (SQLException e) {\n  ...\n  LOGGER.log(Level.ERROR,  contextInfo, e);\n  // handle exception...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2133": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Objects should not be created only to invoke \"getClass\"\nDescription: Why is this an issue?\nCreating an object for the sole purpose of calling\ngetClass\non it is a waste of memory and cycles. Instead, simply use the class\u2019s\n.class\nproperty.\nNoncompliant code example\n```java\nMyObject myOb = new MyObject();  // Noncompliant\nClass c = myOb.getClass();\n```\nCompliant solution\n```java\nClass c = MyObject.class;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2131": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Primitives should not be boxed just for \"String\" conversion\nDescription: This rule is deprecated; use {rule:java:S1158} instead.\nWhy is this an issue?\n\"Boxing\" is the process of putting a primitive value into a primitive-wrapper object. When that\u2019s done purely to use the wrapper class'\ntoString\nmethod, it\u2019s a waste of memory and cycles because those methods are\nstatic\n, and can therefore be used without a\nclass instance. Similarly, using the\nstatic\nmethod\nvalueOf\nin the primitive-wrapper classes with a non-\nString\nargument should be avoided.\nNoncompliant code example\n```java\nint myInt = 4;\nString myIntString = (new Integer(myInt)).toString(); // Noncompliant; creates & discards an Integer object\nmyIntString = Integer.valueOf(myInt).toString(); // Noncompliant\n```\nCompliant solution\n```java\nint myInt = 4;\nString myIntString = Integer.toString(myInt);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2130": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Parsing should be used to convert \"Strings\" to primitives\nDescription: Why is this an issue?\nRather than creating a boxed primitive from a\nString\nto extract the primitive value, use the relevant\nparse\nmethod\ninstead. Using\nparse\nmakes the code more efficient and the intent of the developer clearer.\nNoncompliant code example\n```java\nString myNum = \"42.0\";\nfloat myFloat = new Float(myNum);  // Noncompliant\nfloat myFloatValue = (new Float(myNum)).floatValue();  // Noncompliant\nint myInteger = Integer.valueOf(myNum); // Noncompliant\nint myIntegerValue = Integer.valueOf(myNum).intValue(); // Noncompliant\n```\nCompliant solution\n```java\nString myNum = \"42.0\";\nfloat f = Float.parseFloat(myNum);\nint myInteger = Integer.parseInt(myNum);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2129": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Constructors should not be used to instantiate \"String\", \"BigInteger\", \"BigDecimal\" and primitive-wrapper classes\nDescription: Why is this an issue?\nCalling constructors for\nString\n,\nBigInteger\n,\nBigDecimal\nand the objects used to wrap primitives is less\nefficient and less clear than relying on autoboxing or\nvalueOf\n.\nConsider simplifying when possible for more efficient and cleaner code.\nNoncompliant code example\n```java\nString empty = new String(); // Noncompliant; yields essentially \"\", so just use that.\nString nonempty = new String(\"Hello world\"); // Noncompliant\nDouble myDouble = new Double(1.1); // Noncompliant; use valueOf\nInteger integer = new Integer(1); // Noncompliant\nBoolean bool = new Boolean(true); // Noncompliant\nBigInteger bigInteger1 = new BigInteger(\"3\"); // Noncompliant\nBigInteger bigInteger2 = new BigInteger(\"9223372036854775807\"); // Noncompliant\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\"); // Compliant, greater than Long.MAX_VALUE\nBigDecimal bigDecimal = new BigDecimal(\"42.0\"); // Compliant (see Exceptions section)\n```\nCompliant solution\n```java\nString empty = \"\";\nString nonempty = \"Hello world\";\nDouble myDouble = 1.1;\nInteger integer = 1;\nBoolean bool = true;\nBigInteger bigInteger1 = BigInteger.valueOf(3);\nBigInteger bigInteger2 = BigInteger.valueOf(9223372036854775807L);\nBigInteger bigInteger3 = new BigInteger(\"111222333444555666777888999\");\nBigDecimal bigDecimal = new BigDecimal(\"42.0\");\n```\nExceptions\nBigDecimal\nconstructor with a\ndouble\nargument is ignored as using\nvalueOf\ninstead might change the resulting\nvalue. See {rule:java:S2111}.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2112": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"URL.hashCode\" and \"URL.equals\" should be avoided\nDescription: Why is this an issue?\nThe\nequals\nand\nhashCode\nmethods of\njava.net.URL\nmay trigger a name service lookup (typically DNS) to resolve\nthe hostname or IP address. Depending on the configuration, and network status, this lookup can be time-consuming.\nOn the other hand, the\nURI\nclass does not perform such lookups and is a better choice unless you specifically require the\nfunctionality provided by\nURL\n.\nIn general, it is better to use the\nURI\nclass until access to the resource is actually needed, at which point you can convert the\nURI\nto a\nURL\nusing\nURI.toURL()\n.\nThis rule checks for uses of\nURL\n's in\nMap\nand\nSet\n, and for explicit calls to the\nequals\nand\nhashCode\nmethods. It suggests reconsidering the use of\nURL\nin such scenarios to avoid potential performance issues related\nto name service lookups.\nHow to fix it\nUse the\nURI\nclass until access to the resource is actually needed.\nCode examples\nNoncompliant code example\n```java\npublic void checkUrl(URL url) {\n  Set<URL> sites = new HashSet<URL>();               // Noncompliant\n\n  URL homepage = new URL(\"http://sonarsource.com\");  // Compliant\n  if (homepage.equals(url)) {                        // Noncompliant\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic void checkUrl(URL url) {\n  Set<URI> sites = new HashSet<URI>();               // Compliant\n\n  URI homepage = new URI(\"http://sonarsource.com\");  // Compliant\n  URI uri = url.toURI();\n  if (homepage.equals(uri)) {                        // Compliant\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2096": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"main\" should not \"throw\" anything\nDescription: Why is this an issue?\nThere\u2019s no reason for a\nmain\nmethod to\nthrow\nanything. After all, what\u2019s going to catch it?\nInstead, the method should itself gracefully handle any exceptions that may bubble up to it, attach as much contextual information as possible, and\nperform whatever logging or user communication is necessary, and\nexit\nwith a non-zero (i.e. non-success) exit code if necessary.\nNoncompliant code example\n```java\npublic static void main(String args[]) throws Exception { // Noncompliant\n  doSomething();\n}\n```\nCompliant solution\n```java\npublic static void main(String args[]) {\n try {\n    doSomething();\n  } catch (Throwable t) {\n    log.error(t);\n    System.exit(1);  // Default exit code, 0, indicates success. Non-zero value means failure.\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2094": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not be empty\nDescription: Why is this an issue?\nThere is no good excuse for an empty class. If it\u2019s being used simply as a common extension point, it should be replaced with an\ninterface\n. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be\neliminated.\nNoncompliant code example\n```java\npublic class Nothing {  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic interface Nothing {\n}\n```\nExceptions\nEmpty classes can be used as marker types (for Spring for instance), therefore empty classes that are annotated will be ignored.\n```java\n@Configuration\n@EnableWebMvc\npublic final class ApplicationConfiguration {\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2093": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Try-with-resources should be used\nDescription: Why is this an issue?\nMany resources in Java need be closed after they have been used. If they are not, the garbage collector cannot reclaim the resources' memory, and\nthey are still considered to be in use by the operating system. Such resources are considered to be leaked, which can lead to performance issues.\nJava 7 introduced the try-with-resources statement, which guarantees that the resource in question will be closed.\n```java\ntry (InputStream input = Files.newInputStream(path)) {\n  // \"input\" will be closed after the execution of this block\n}\n```\nThis syntax is safer than the traditional method using\ntry\n,\ncatch\n, and\nfinally\nand hence should be\npreferred.\nThis rule raises an issue if a closeable resources is not opened using a try-with-resources statement.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n7\nas the close-with-resources\nstatement was unavailable prior to Java 7.\nHow to fix it\nUse the try-with-resources syntax by moving the\nClosable\nvariable declarations after the\ntry\nkeyword surrounded by\nparentheses and separated by\n;\n:\n```java\ntry (/* resources declarations */) {\n  // resources usage ...\n}\n```\nCode examples\nNoncompliant code example\n```java\nFileReader fr = null;\nBufferedReader br = null;\n\ntry { // Noncompliant, the FileReader and BufferedReader are instantiated without try-with-resources\n  fr = new FileReader(fileName);\n  br = new BufferedReader(fr);\n  return br.readLine();\n} catch (...) {\n  ...\n} finally {\n\n  if (br != null) { // br has to be closed manually\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n  if (fr != null ) { // fr has to be closed manually\n    try {\n      br.close();\n    } catch(IOException e){...}\n  }\n\n}\n```\nCompliant solution\n```java\ntry ( // Compliant, all resources are instantiated within a try-with-resources statement and hence automatically closed after use\n    FileReader fr = new FileReader(fileName);\n    BufferedReader br = new BufferedReader(fr)\n  ) {\n  return br.readLine();\n}\ncatch (...) {}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2065": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Fields in non-serializable classes should not be \"transient\"\nDescription: Why is this an issue?\nFields marked as\ntransient\nin a\nSerializable\nclass will be ignored during serialization and consequently not written out\nto a file (or stream).\nThis can be useful in situations such as where the content of a field can be recomputed from other fields. To reduce the output size, this field\ncan be marked as\ntransient\nand recomputed when a given object is deserialized.\nSince\ntransient\nis very specific to classes that implement\nSerializable\n, it is superfluous in classes that do not.\nThis rule raises an issue when a field is marked as\ntransient\n, even though the containing class does not implement\nSerializable\n.\nHow to fix it\nAsk yourself whether this class should be serializable. If yes, ensure it implements\nSerializable\nand provides any additional logic\nrequired to serialize and deserialize an instance of this type. Otherwise, remove the\ntransient\nmodifier from this field.\nCode examples\nNoncompliant code example\n```java\nclass Vegetable {\n  private transient Season ripe; // Noncompliant, the \"Vegetable\" class does not implement \"Serializable\" but the field is marked as \"transient\"\n  // ...\n}\n```\nCompliant solution\n```java\nclass Vegetable {\n  private Season ripe; // Compliant, the field is not marked as \"transient\"\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2063": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comparators should be \"Serializable\"\nDescription: Why is this an issue?\nA non-serializable\nComparator\ncan prevent an otherwise-\nSerializable\nordered collection from being serializable. Since the\noverhead to make a\nComparator\nserializable is usually low, doing so can be considered good defensive programming.\nNoncompliant code example\n```java\npublic class FruitComparator implements Comparator<Fruit> {  // Noncompliant\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n```\nCompliant solution\n```java\npublic class FruitComparator implements Comparator<Fruit>, Serializable {\n  private static final long serialVersionUID = 1;\n\n  int compare(Fruit f1, Fruit f2) {...}\n  boolean equals(Object obj) {...}\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2062": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"readResolve\" methods should be inheritable\nDescription: Why is this an issue?\nDevelopers may want to add some logic to handle deserialized objects before they are returned to the caller. This can be achieved by implementing\nthe\nreadResolve\nmethod.\nNon-final classes implementing\nreadResolve\nshould not set its visibility to\nprivate\nas this would make it unavailable to\nchild classes. Instead, mark\nreadResolve\nas\nprotected\n, allowing it to be inherited.\nCode examples\nNoncompliant code example\n```java\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  private Object readResolve() throws ObjectStreamException // Noncompliant, `readResolve` should not be private\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // This class has no access to the parent's \"readResolve\" method\n  //...\n}\n```\nCompliant solution\n```java\npublic class Fruit implements Serializable {\n  private static final long serialVersionUID = 1;\n\n  protected Object readResolve() throws ObjectStreamException // Compliant, `readResolve` is protected\n  {...}\n\n  //...\n}\n\npublic class Raspberry extends Fruit implements Serializable { // This class has access to the parent's \"readResolve\"\n  //...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2059": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Serializable\" inner classes of \"Serializable\" classes should be static\nDescription: Why is this an issue?\nSerializing a non-\nstatic\ninner class will result in an attempt at serializing the outer class as well. If the outer class is actually\nserializable, then the serialization will succeed but possibly write out far more data than was intended.\nMaking the inner class\nstatic\n(i.e. \"nested\") avoids this problem, therefore inner classes should be\nstatic\nif possible.\nHowever, you should be aware that there are semantic differences between an inner class and a nested one:\n1. an inner class can only be instantiated within the context of an instance of the outer class.\n2. a nested (static) class can be instantiated independently of the outer class.\nNoncompliant code example\n```java\npublic class Raspberry implements Serializable {\n  // ...\n\n  public class Drupelet implements Serializable {  // Noncompliant; output may be too large\n    // ...\n  }\n}\n```\nCompliant solution\n```java\npublic class Raspberry implements Serializable {\n  // ...\n\n  public static class Drupelet implements Serializable {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2057": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Serializable\" classes should have a \"serialVersionUID\"\nDescription: Why is this an issue?\nA\nserialVersionUID\nfield is strongly recommended in all\nSerializable\nclasses. If you do not provide one, one will be\ncalculated for you by the compiler. The danger in not explicitly choosing the value is that when the class changes, the compiler will generate an\nentirely new id, and you will be suddenly unable to deserialize (read from file) objects that were serialized with the previous version of the\nclass.\nserialVersionUID\n's should be declared with all of these modifiers:\nstatic final long\n.\nNoncompliant code example\n```java\npublic class Raspberry extends Fruit  // Noncompliant; no serialVersionUID.\n        implements Serializable {\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private final int serialVersionUID = 1; // Noncompliant; not static & int rather than long\n```\nCompliant solution\n```java\npublic class Raspberry extends Fruit\n        implements Serializable {\n  private static final long serialVersionUID = 1;\n  private String variety;\n\n  public Raspberry(Season ripe, String variety) { ...}\n  public void setVariety(String variety) {...}\n  public String getVarity() {...}\n}\n```\nExceptions\nRecords, Swing and AWT classes,\nabstract\nclasses,\nThrowable\nand its subclasses (\nException\ns and\nError\ns), and classes marked with\n@SuppressWarnings(\"serial\")\nare ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2047": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The names of methods with boolean return values should start with \"is\" or \"has\"\nDescription: Why is this an issue?\nWell-named functions can allow the users of your code to understand at a glance what to expect from the function - even before reading the\ndocumentation. Toward that end, methods returning a boolean should have names that start with \"is\" or \"has\" rather than with \"get\".\nNoncompliant code example\n```java\npublic boolean getFoo() { // Noncompliant\n  // ...\n}\n\npublic boolean getBar(Bar c) { // Noncompliant\n  // ...\n}\n\npublic boolean testForBar(Bar c) { // Compliant - The method does not start by 'get'.\n  // ...\n}\n```\nCompliant solution\n```java\npublic boolean isFoo() {\n  // ...\n}\n\npublic boolean hasBar(Bar c) {\n  // ...\n}\n\npublic boolean testForBar(Bar c) {\n  // ...\n}\n```\nExceptions\nOverriding methods are excluded.\n```java\n@Override\npublic boolean getFoo(){\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-2039": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Member variable visibility should be specified\nDescription: Why is this an issue?\nFailing to explicitly declare the visibility of a member variable could result it in having a visibility you don\u2019t expect, and potentially leave it\nopen to unexpected modification by other classes.\nThe default access level modifier may be intentional; in that case, this rule can report false positives.\nNoncompliant code example\n```java\nclass Ball {\n  String color = \"red\";  // Noncompliant\n}\nenum A {\n  B;\n  int a;  // Noncompliant\n}\n```\nCompliant solution\n```java\nclass Ball {\n  private String color = \"red\";  // Compliant\n}\nenum A {\n  B;\n  private int a;  // Compliant\n}\n```\nExceptions\n1. Members with comments containing the wordmodifierare ignored, as it indicates the modifier is intentionally omitted.\n2. Members annotated with the@VisibleForTestingannotation are ignored, as it indicates that visibility has been purposely relaxed\n  to make the code testable.\n```java\nclass Cone {\n  @VisibleForTesting\n  Logger logger; // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1996": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should contain only one top-level class or interface each\nDescription: Why is this an issue?\nA file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain. This\nis doubly true for a file with multiple top-level classes and interfaces. It is strongly advised to divide the file into one top-level class or\ninterface per file.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1994": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"for\" loop increment clauses should modify the loops' counters\nDescription: Why is this an issue?\nThe counter of a\nfor\nloop should be updated in the loop\u2019s increment clause. The purpose of a\nfor\nloop is to iterate over\na range using a counter variable. It should not be used for other purposes, and alternative loops should be used in those cases.\nIf the counter is not updated, the loop will be infinite with a constant counter variable. If this is intentional, use a\nwhile\nor\ndo\nwhile\nloop instead of a\nfor\nloop.\nIf the counter variable is updated within the loop\u2019s body, try to move it to the increment clause. If this is impossible due to certain conditions,\nreplace the\nfor\nloop with a\nwhile\nor\ndo\nwhile\nloop.\nHow to fix it\nCode examples\nNoncompliant code example\nMove the counter variable update to the loop\u2019s increment clause.\n```java\nfor (int i = 0; i < 10; ) { // Noncompliant, i not updated in increment clause\n  // ...\n  i++;\n}\n```\n```java\nint sum = 0\nfor (int i = 0; i < 10; sum++) { // Noncompliant, i not updated in increment clause\n  // ...\n  i++;\n}\n```\nCompliant solution\n```java\nfor (i = 0; i < 10; i++) { // Compliant\n  // ...\n}\n```\n```java\nint sum = 0\nfor (int i = 0; i < 10; i++) { // Compliant\n  // ...\n  sum++;\n}\n```\nNoncompliant code example\nIf this is impossible and the counter variable must be updated in the loop\u2019s body, use a\nwhile\nor\ndo\nwhile\nloop instead.\n```java\nfor (int sum = 0; sum < 10) { // Noncompliant, sum not updated in increment clause\n  // ...\n  if (condition) sum++;\n  // ...\n}\n```\nCompliant solution\n```java\nint sum = 0;\nwhile (sum < 10) { // Compliant\n  // ...\n  if (condition) sum++;\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1948": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Fields in a \"Serializable\" class should either be transient or serializable\nDescription: This rule raises an issue on a non-transient and non-serializable field within a serializable class, if said class does not have\nwriteObject\nand\nreadObject\nmethods defined.\nWhy is this an issue?\nBy contract, non-static fields in a\nSerializable\nclass must themselves be either\nSerializable\nor\ntransient\n.\nEven if the class is never explicitly serialized or deserialized, it is not safe to assume that this cannot happen. For instance, under load, most\nJ2EE application frameworks flush objects to disk.\nAn object that implements\nSerializable\nbut contains non-transient, non-serializable data members (and thus violates the contract)\ncould cause application crashes and open the door to attackers. In general, a\nSerializable\nclass is expected to fulfil its contract and\nnot exhibit unexpected behaviour when an instance is serialized.\nThis rule raises an issue on:\n1. Non-Serializablefields.\n2. When a field is assigned a non-Serializabletype within the class.\n3. Collection fields when they are notprivate. Values that are not serializable could be added to these collections externally. Due\n  to type erasure, it cannot be guaranteed that the collection will only contain serializable objects at runtime despite being declared as a\n  collection of serializable types.\nHow to fix it\nConsider the following scenario.\n```java\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address;  // Noncompliant, Address is not serializable\n}\n```\nHow to fix this issue depends on the application\u2019s needs. If the field\u2019s value should be preserved during serialization and deserialization, you\nmay want to make the field\u2019s value serializable.\n```java\npublic class Address implements Serializable {\n  private static final long serialVersionUID = 2405172041950251807L;\n\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // Compliant, Address is serializable\n}\n```\nIf the field\u2019s value does not need to be preserved during serialization and deserialization, mark it as\ntransient\n. The field will be\nignored when the object is serialized. After deserialization, the field will be set to the default value corresponding to its type (e.g.,\nnull\nfor object references).\n```java\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private transient Address address; // Compliant, the field is transient\n}\n```\nThe alternative to making all members serializable or\ntransient\nis to implement special methods which take on the responsibility of\nproperly serializing and de-serializing the object\nwriteObject\nand\nreadObject\n. These methods can be used to properly\n(de-)serialize an object, even though it contains fields that are not transient or serializable. Hence, this rule does not raise issues on fields of\nclasses which implement these methods.\n```java\npublic class Address {\n    ...\n}\n\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n  private Address address; // Compliant, writeObject and readObject handle this field\n\n  private void writeObject(java.io.ObjectOutputStream out) throws IOException {\n    // Appropriate serialization logic here\n  }\n\n  private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException {\n    // Appropriate deserialization logic here\n  }\n}\n```\nFinally, static fields are out of scope for serialization, so making a field static prevents issues from being raised.\n```java\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n\n  private String name;\n\n  private static Logger log = getLogger(); // Compliant, static fields are not serialized\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1943": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes and methods that rely on the default system encoding should not be used\nDescription: Why is this an issue?\nUsing classes and methods that rely on the default system encoding can result in code that works fine in its \"home\" environment. But that code may\nbreak for customers who use different encodings in ways that are extremely difficult to diagnose and nearly, if not completely, impossible to\nreproduce when it\u2019s time to fix them.\nThis rule detects uses of the following classes and methods:\n1. FileReader\n2. FileWriter\n3. String constructors with abyte[]argument but noCharsetargumentString(byte[] bytes)String(byte[] bytes, int offset, int length)\n4. String(byte[] bytes)\n5. String(byte[] bytes, int offset, int length)\n6. String.getBytes()\n7. String.getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)\n8. InputStreamReader(InputStream in)\n9. OutputStreamWriter(OutputStream out)\n10. ByteArrayOutputStream.toString()\n11. SomeFormatterconstructorsFormatter(String fileName)Formatter(File file)Formatter(OutputStream os)\n12. Formatter(String fileName)\n13. Formatter(File file)\n14. Formatter(OutputStream os)\n15. SomeScannerconstructorsScanner(File source)Scanner(Path source)Scanner(InputStream source)\n16. Scanner(File source)\n17. Scanner(Path source)\n18. Scanner(InputStream source)\n19. SomePrintStreamconstructorsPrintStream(File file)PrintStream(OutputStream out)PrintStream(OutputStream out, boolean autoFlush)PrintStream(String fileName)\n20. PrintStream(File file)\n21. PrintStream(OutputStream out)\n22. PrintStream(OutputStream out, boolean autoFlush)\n23. PrintStream(String fileName)\n24. SomePrintWriterconstructorsPrintWriter(File file)PrintWriter(OutputStream out)PrintWriter(OutputStream out, boolean autoFlush)PrintWriter(String fileName)\n25. PrintWriter(File file)\n26. PrintWriter(OutputStream out)\n27. PrintWriter(OutputStream out, boolean autoFlush)\n28. PrintWriter(String fileName)\n29. methods from Apache commons-io library which accept an encoding argument when that argument is null, and overloads of those methods that omit\n  the encoding argumentIOUtils.copy(InputStream, Writer)IOUtils.copy(Reader, OutputStream)IOUtils.readLines(InputStream)IOUtils.toByteArray(Reader)IOUtils.toByteArray(String)IOUtils.toCharArray(InputStream)IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))IOUtils.toString(byte[])IOUtils.toString(URI)IOUtils.toString(URL)IOUtils.write(char[], OutputStream)IOUtils.write(CharSequence, OutputStream)IOUtils.writeLines(Collection, String, OutputStream)FileUtils.readFileToString(File)FileUtils.readLines(File)FileUtils.write(File, CharSequence)FileUtils.write(File, CharSequence, boolean)FileUtils.writeStringToFile(File, String)\n30. IOUtils.copy(InputStream, Writer)\n31. IOUtils.copy(Reader, OutputStream)\n32. IOUtils.readLines(InputStream)\n33. IOUtils.toByteArray(Reader)\n34. IOUtils.toByteArray(String)\n35. IOUtils.toCharArray(InputStream)\n36. IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))\n37. IOUtils.toString(byte[])\n38. IOUtils.toString(URI)\n39. IOUtils.toString(URL)\n40. IOUtils.write(char[], OutputStream)\n41. IOUtils.write(CharSequence, OutputStream)\n42. IOUtils.writeLines(Collection, String, OutputStream)\n43. FileUtils.readFileToString(File)\n44. FileUtils.readLines(File)\n45. FileUtils.write(File, CharSequence)\n46. FileUtils.write(File, CharSequence, boolean)\n47. FileUtils.writeStringToFile(File, String)\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1942": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Simple class names should be used\nDescription: Why is this an issue?\nJava\u2019s\nimport\nmechanism allows the use of simple class names. Therefore, using a class' fully qualified name in a file that\nimport\ns the class is redundant and confusing.\nNoncompliant code example\n```java\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\njava.util.List<String> myList;  // Noncompliant\njava.sql.Timestamp tStamp; // Noncompliant\n```\nCompliant solution\n```java\nimport java.util.List;\nimport java.sql.Timestamp;\n\n//...\n\nList<String> myList;\nTimestamp tStamp;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1941": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Variables should not be declared before they are relevant\nDescription: Why is this an issue?\nFor the sake of clarity, variables should be declared as close to where they\u2019re used as possible. This is particularly true when considering\nmethods that contain early returns and the potential to throw exceptions. In these cases, it is not only pointless, but also confusing to declare a\nvariable that may never be used because conditions for an early return are met first.\nNoncompliant code example\n```java\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n  MyClass foo = new MyClass(a);  // Noncompliant; not used before early return\n\n  if (difference < 0) {\n    return false;\n  }\n\n  // ...\n\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n```\nCompliant solution\n```java\npublic boolean isConditionMet(int a, int b) {\n  int difference = a - b;\n\n  if (difference < 0) {\n    return false;\n  }\n\n  // ...\n\n  MyClass foo = new MyClass(a);\n  if (foo.doTheThing()) {\n    return true;\n  }\n  return false;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1940": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Boolean checks should not be inverted\nDescription: Why is this an issue?\nIt is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.\nNoncompliant code example\n```java\nif ( !(a == 2)) { ...}  // Noncompliant\nboolean b = !(i < 10);  // Noncompliant\n```\nCompliant solution\n```java\nif (a != 2) { ...}\nboolean b = (i >= 10);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1939": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Extensions and implementations should not be redundant\nDescription: Why is this an issue?\nAll classes extend\nObject\nimplicitly. Doing so explicitly is redundant.\nFurther, declaring the implementation of an interface\nand\none if its parents is also redundant. If you implement the interface, you also\nimplicitly implement its parents and there\u2019s no need to do so explicitly.\nNoncompliant code example\n```java\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo\n    extends Object // Noncompliant\n    implements MyFace, MyOtherFace {  // Noncompliant\n  //...\n}\n```\nCompliant solution\n```java\npublic interface MyFace {\n  // ...\n}\n\npublic interface MyOtherFace extends MyFace {\n  // ...\n}\n\npublic class Foo implements MyOtherFace {\n  //...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1905": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant casts should not be used\nDescription: Why is this an issue?\nCasting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in\nstrongly typed languages like C, C++, C#, Java, Python, and others.\nHowever, there are instances where casting expressions are not needed. These include situations like:\n1. casting a variable to its own type\n2. casting a subclass to a parent class (in the case of polymorphism)\n3. the programming language is capable of automatically converting the given type to another\nThese scenarios are considered unnecessary casting expressions. They can complicate the code and make it more difficult to understand, without\noffering any advantages.\nAs a result, it\u2019s generally advised to avoid unnecessary casting expressions. Instead, rely on the language\u2019s type system to ensure type safety and\ncode clarity.\nExceptions\nCasting may be required to distinguish the method to call in the case of overloading:\n```java\nclass A {}\nclass B extends A{}\nclass C {\n  void fun(A a){}\n  void fun(B b){}\n\n  void foo() {\n    B b = new B();\n    fun(b);\n    fun((A) b); // Compliant, required to call the first method so cast is not redundant.\n  }\n}\n```\nHow to fix it\nTo fix your code remove the unnecessary casting expression.\nCode examples\nNoncompliant code example\n```java\nclass Example {\n    public void example(List<String> list) {\n        for (String item: (List<String>) list) {  // Noncompliant, Remove this unnecessary cast to \"List\".\n          //...\n        }\n    }\n}\n```\nCompliant solution\n```java\nclass Example {\n    public void example() {\n        for (String foo : getFoos()) {\n          //...\n        }\n    }\n\n    public List<String> getFoos() {\n        return List.of(\"foo1\", \"foo2\");\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1874": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Deprecated\" code should not be used\nDescription: Why is this an issue?\nCode is sometimes annotated as deprecated by developers maintaining libraries or APIs to indicate that the method, class, or other programming\nelement is no longer recommended for use. This is typically due to the introduction of a newer or more effective alternative. For example, when a\nbetter solution has been identified, or when the existing code presents potential errors or security risks.\nDeprecation is a good practice because it helps to phase out obsolete code in a controlled manner, without breaking existing software that may\nstill depend on it. It is a way to warn other developers not to use the deprecated element in new code, and to replace it in existing code when\npossible.\nDeprecated classes, interfaces, and their members should not be used, inherited or extended because they will eventually be removed. The\ndeprecation period allows you to make a smooth transition away from the aging, soon-to-be-retired technology.\nCheck the documentation or the deprecation message to understand why the code was deprecated and what the recommended alternative is.\n```java\n/**\n * @deprecated  As of release 1.3, replaced by {@link #Foo}\n */\n@Deprecated\npublic class Fum { ... }\n\npublic class Foo {\n  /**\n   * @deprecated  As of release 1.7, replaced by {@link #newMethod()}\n   */\n  @Deprecated\n  public void oldMethod() { ... }\n\n  public void newMethod() { ... }\n}\n\npublic class Bar extends Foo {\n  public void oldMethod() { ... } // Noncompliant; don't override a deprecated method\n}\n\npublic class Baz extends Fum {  // Noncompliant; Fum is deprecated\n  public void myMethod() {\n    Foo foo = new Foo();\n    foo.oldMethod();  // Noncompliant; oldMethod method is deprecated\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1871": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Two branches in a conditional structure should not have exactly the same implementation\nDescription: Why is this an issue?\nWhen the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can\npotentially introduce bugs if one instance of the code is changed but others are not.\nHaving two\ncases\nin a\nswitch\nstatement or two branches in an\nif\nchain with the same implementation is at\nbest duplicate code, and at worst a coding error.\n```java\nif (a >= 0 && a < 10) {\n  doFirstThing();\n  doTheThing();\n}\nelse if (a >= 10 && a < 20) {\n  doTheOtherThing();\n}\nelse if (a >= 20 && a < 50) {\n  doFirstThing();\n  doTheThing();  // Noncompliant; duplicates first condition\n}\nelse {\n  doTheRest();\n}\n```\n```java\nswitch (i) {\n  case 1:\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  case 3:  // Noncompliant; duplicates case 1's implementation\n    doFirstThing();\n    doSomething();\n    break;\n  default:\n    doTheRest();\n}\n```\nIf the same logic is truly needed for both instances, then:\n1. in anifchain they should be combined\n```java\nif ((a >= 0 && a < 10) || (a >= 20 && a < 50)) { // Compliant\n  doFirstThing();\n  doTheThing();\n}\nelse if (a >= 10 && a < 20) {\n  doTheOtherThing();\n}\nelse {\n  doTheRest();\n}\n```\n1. for aswitch, one should fall through to the other\n```java\nswitch (i) {\n  case 1:\n  case 3: // Compliant\n    doFirstThing();\n    doSomething();\n    break;\n  case 2:\n    doSomethingDifferent();\n    break;\n  default:\n    doTheRest();\n}\n```\nWhen all blocks are identical, either this rule will trigger if there is no default clause or rule {rule:java:S3923} will raise if there is a\ndefault clause.\nExceptions\nUnless all blocks are identical, blocks in an\nif\nchain that contain a single line of code are ignored. The same applies to blocks in a\nswitch\nstatement that contains a single line of code with or without a following\nbreak\n.\n```java\nif (a == 1) {\n  doSomething();  // Compliant, usually this is done on purpose to increase the readability\n} else if (a == 2) {\n  doSomethingElse();\n} else {\n  doSomething();\n}\n```\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1858": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"toString()\" should never be called on a String object\nDescription: Why is this an issue?\nInvoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. This redundant\nconstruction may be optimized by the compiler, but will be confusing in the meantime.\nNoncompliant code example\n```java\nString message = \"hello world\";\nSystem.out.println(message.toString()); // Noncompliant;\n```\nCompliant solution\n```java\nString message = \"hello world\";\nSystem.out.println(message);\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1854": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused assignments should be removed\nDescription: Why is this an issue?\nDead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are\nunnecessary and don\u2019t contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code\ncleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program\u2019s correctness, they are - at best - a waste\nof computing resources.\nExceptions\nThis rule ignores initializations to\n-1\n,\n0\n,\n1\n,\nnull\n,\ntrue\n,\nfalse\nand\n\"\"\n.\nHow to fix it\nRemove the unnecessary assignment, then test the code to make sure that the right-hand side of a given assignment had no side effects (e.g. a\nmethod that writes certain data to a file and returns the number of written bytes).\nCode examples\nNoncompliant code example\n```java\nint foo(int y) {\n  int x = 100; // Noncompliant: dead store\n  x = 150;     // Noncompliant: dead store\n  x = 200;\n  return x + y;\n}\n```\nCompliant solution\n```java\nint foo(int y) {\n  int x = 200; // Compliant: no unnecessary assignment\n  return x + y;\n}\n```\nStandards\n1. CWE -CWE-563 - Assignment to Variable without Use ('Unused Variable')\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1845": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods and field names should not be the same or differ only by capitalization\nDescription: This rule raises an issue when there is a method and a field in a class with names that differ only by capitalization.\nWhy is this an issue?\nLooking at the set of methods in a class, including superclass methods, and finding two methods or fields that differ only by capitalization is\nconfusing to users of the class. It is similarly confusing to have a method and a field which differ only in capitalization or a method and a field\nwith exactly the same name and visibility.\nIn the case of methods, it may have been a mistake on the part of the original developer, who intended to override a superclass method, but instead\nadded a new method with nearly the same name.\nOtherwise, this situation simply indicates poor naming. Method names should be action-oriented, and thus contain a verb, which is unlikely in the\ncase where both a method and a member have the same name (with or without capitalization differences). However, renaming a public method could be\ndisruptive to callers. Therefore renaming the member is the recommended action.\nCode examples\nNoncompliant code example\n```java\npublic class Car{\n\n  public DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // Noncompliant; duplicates field name\n}\n\npublic class MyCar extends Car{\n  public void teardown(){...}  // Noncompliant; not an override. It it really what's intended?\n\n  public void drivefast(){...}\n\n  public void driveFast(){...} //Huh?\n}\n```\nCompliant solution\n```java\npublic class Car{\n\n  private DriveTrain drive;\n\n  public void tearDown(){...}\n\n  public void drive() {...}  // field visibility reduced\n}\n\npublic class MyCar extends Car{\n  @Override\n  public void tearDown(){...}\n\n  public void drivefast(){...}\n\n  public void driveReallyFast(){...}\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1844": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Object.wait\" should not be called on objects that implement \"java.util.concurrent.locks.Condition\"\nDescription: Why is this an issue?\nThe\njava.util.concurrent.locks.Condition\ninterface provides an alternative to the\nObject\nmonitor methods\n(\nwait\n,\nnotify\nand\nnotifyAll\n). Hence, the purpose of implementing said interface is to gain access to its more\nnuanced\nawait\nmethods.\nConsequently, calling the method\nObject.wait\non a class implementing the\nCondition\ninterface is contradictory and should\nbe avoided. Use\nCondition.await\ninstead.\nCode examples\nNoncompliant code example\n```java\nvoid doSomething(Condition condition) {\n    condition.wait(); // Noncompliant, Object.wait is called\n\n        ...\n}\n```\nCompliant solution\n```java\nvoid doSomething(Condition condition) {\n    condition.await(); // Compliant, Condition.await is called\n\n        ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1821": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements and expressions should not be nested\nDescription: Why is this an issue?\nNested\nswitch\nstructures are difficult to understand because you can easily confuse the cases of an inner\nswitch\nas\nbelonging to an outer statement or expression. Therefore nested\nswitch\nstatements and expressions should be avoided.\nSpecifically, you should structure your code to avoid the need for nested\nswitch\nstatements or expressions, but if you cannot, then\nconsider moving the inner\nswitch\nto another method.\nNoncompliant code example\n```java\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      switch (m) {  // Noncompliant; nested switch\n        // ...\n      }\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n```\nCompliant solution\n```java\nvoid foo(int n, int m) {\n  switch (n) {\n    case 0:\n      bar(m);\n    case 1:\n      // ...\n    default:\n      // ...\n  }\n}\n\nvoid bar(int m){\n  switch(m) {\n    // ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1820": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not have too many fields\nDescription: Why is this an issue?\nA class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain, and\nhaving a lot of fields is an indication that a class has grown too large.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1774": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The ternary operator should not be used\nDescription: Why is this an issue?\nTernary expressions, while concise, can often lead to code that is difficult to read and understand, especially when they are nested or complex.\nPrioritizing readability fosters maintainability and reduces the likelihood of bugs. Therefore, they should be removed in favor of more explicit\ncontrol structures, such as\nif\n/\nelse\nstatements, to improve the clarity and readability of the code.\nCode examples\nNoncompliant code example\n```java\nSystem.out.println(i>10?\"yes\":\"no\");  // Noncompliant\n```\nCompliant solution\n```java\nif (i > 10) {\n  System.out.println(\"yes\");\n} else {\n  System.out.println(\"no\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1711": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Standard functional interfaces should not be redefined\nDescription: Why is this an issue?\nJust as there is little justification for writing your own String class, there is no good reason to re-define one of the existing, standard\nfunctional interfaces.\nDoing so may seem tempting, since it would allow you to specify a little extra context with the name. But in the long run, it will be a source of\nconfusion, because maintenance programmers will wonder what is different between the custom functional interface and the standard one.\nNoncompliant code example\n```java\n@FunctionalInterface\npublic interface MyInterface { // Noncompliant\n\tdouble toDouble(int a);\n}\n\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier { // Noncompliant\n  boolean get();\n  default boolean isFalse() {\n    return !get();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(MyInterface instance){\n\treturn instance.toDouble(a);\n    }\n}\n```\nCompliant solution\n```java\n@FunctionalInterface\npublic interface ExtendedBooleanSupplier extends BooleanSupplier { // Compliant, extends java.util.function.BooleanSupplier\n  default boolean isFalse() {\n    return !getAsBoolean();\n  }\n}\n\npublic class MyClass {\n    private int a;\n    public double myMethod(IntToDoubleFunction instance){\n\treturn instance.applyAsDouble(a);\n    }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1710": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Annotation repetitions should not be wrapped\nDescription: Why is this an issue?\nBefore Java 8, a container annotation was required as wrapper to use multiple instances of the same annotation. As of Java 8, this is no longer\nnecessary. Instead, these annotations should be used directly without a wrapper, resulting in cleaner and more readable code.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\nas repeating annotations were\nintroduced in Java 8.\nCode examples\nNoncompliant code example\n```java\n@SomeAnnotations({  // Noncompliant, wrapper annotations are not necessary in Java 8+\n  @SomeAnnotation(..a..),\n  @SomeAnnotation(..b..),\n  @SomeAnnotation(..c..),\n})\npublic class SomeClass {\n  ...\n}\n```\nCompliant solution\n```java\n@SomeAnnotation(..a..)\n@SomeAnnotation(..b..)\n@SomeAnnotation(..c..)\npublic class SomeClass {\n  ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1700": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A field should not duplicate the name of its containing class\nDescription: Why is this an issue?\nIt\u2019s confusing to have a class member with the same name (case differences aside) as its enclosing class. This is particularly so when you consider\nthe common practice of naming a class instance for the class itself.\nBest practice dictates that any field or member with the same name as the enclosing class be renamed to be more descriptive of the particular\naspect of the class it represents or holds.\nNoncompliant code example\n```java\npublic class Foo {\n  private String foo;\n\n  public String getFoo() { }\n}\n\nFoo foo = new Foo();\nfoo.getFoo() // what does this return?\n```\nCompliant solution\n```java\npublic class Foo {\n  private String name;\n\n  public String getName() { }\n}\n\n//...\n\nFoo foo = new Foo();\nfoo.getName()\n```\nExceptions\nWhen the type of the field is the containing class and that field is static, no issue is raised to allow singletons named like the type.\n```java\npublic class Foo {\n  ...\n  private static Foo foo;\n  public Foo getInstance() {\n    if(foo==null) {\n      foo = new Foo();\n    }\n    return foo;\n  }\n  ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1699": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Constructors should only call non-overridable methods\nDescription: Why is this an issue?\nCalling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the\nmethod.\nFor example:\n1. The subclass class constructor starts by contract by calling the parent class constructor.\n2. The parent class constructor calls the method, which has been overridden in the child class.\n3. If the behavior of the child class method depends on fields that are initialized in the child class constructor, unexpected behavior (like aNullPointerException) can result, because the fields aren\u2019t initialized yet.\nNoncompliant code example\n```java\npublic class Parent {\n\n  public Parent () {\n    doSomething();  // Noncompliant\n  }\n\n  public void doSomething () {  // not final; can be overridden\n    ...\n  }\n}\n\npublic class Child extends Parent {\n\n  private String foo;\n\n  public Child(String foo) {\n    super(); // leads to call doSomething() in Parent constructor which triggers a NullPointerException as foo has not yet been initialized\n    this.foo = foo;\n  }\n\n  public void doSomething () {\n    System.out.println(this.foo.length());\n  }\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1698": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"==\" and \"!=\" should not be used when \"equals\" is overridden\nDescription: Why is this an issue?\nIt is equivalent to use the equality\n==\noperator and the\nequals\nmethod to compare two objects if the\nequals\nmethod inherited from\nObject\nhas not been overridden. In this case both checks compare the object references.\nBut as soon as\nequals\nis overridden, two objects not having the same reference but having the same value can be equal. This rule spots\nsuspicious uses of\n==\nand\n!=\noperators on objects whose\nequals\nmethods are overridden.\nNoncompliant code example\n```java\nString firstName = getFirstName(); // String overrides equals\nString lastName = getLastName();\n\nif (firstName == lastName) { ... }; // Non-compliant; false even if the strings have the same value\n```\nCompliant solution\n```java\nString firstName = getFirstName();\nString lastName = getLastName();\n\nif (firstName != null && firstName.equals(lastName)) { ... };\n```\nExceptions\nComparing two instances of the\nClass\nobject will not raise an issue:\n```java\nClass c;\nif(c == Integer.class) { // No issue raised\n}\n```\nComparing\nEnum\nwill not raise an issue:\n```java\npublic enum Fruit {\n   APPLE, BANANA, GRAPE\n}\npublic boolean isFruitGrape(Fruit candidateFruit) {\n  return candidateFruit == Fruit.GRAPE; // it's recommended to activate S4551 to enforce comparison of Enums using ==\n}\n```\nComparing with\nfinal\nreference will not raise an issue:\n```java\nprivate static final Type DEFAULT = new Type();\n\nvoid foo(Type other) {\n  if (other == DEFAULT) { // Compliant\n  //...\n  }\n}\n```\nComparing with\nthis\nwill not raise an issue:\n```java\npublic boolean equals(Object other) {\n    if (this == other) {  // Compliant\n      return false;\n    }\n }\n```\nComparing with\njava.lang.String\nand boxed types\njava.lang.Integer\n, \u2026\u200b will not raise an issue.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1696": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"NullPointerException\" should not be caught\nDescription: Why is this an issue?\nNullPointerException\nshould be avoided, not caught. Any situation in which\nNullPointerException\nis explicitly caught can\neasily be converted to a\nnull\ntest, and any behavior being carried out in the catch block can easily be moved to the \"is null\" branch of\nthe conditional.\nNoncompliant code example\n```java\npublic int lengthPlus(String str) {\n  int len = 2;\n  try {\n    len += str.length();\n  }\n  catch (NullPointerException e) {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n```\nCompliant solution\n```java\npublic int lengthPlus(String str) {\n  int len = 2;\n\n  if (str != null) {\n    len += str.length();\n  }\n  else {\n    log.info(\"argument was null\");\n  }\n  return len;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1695": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"NullPointerException\" should not be explicitly thrown\nDescription: Why is this an issue?\nA\nNullPointerException\nshould indicate that a\nnull\nvalue was unexpectedly encountered. Good programming practice dictates\nthat code is structured to avoid NPE\u2019s.\nExplicitly throwing\nNullPointerException\nforces a method\u2019s callers to explicitly catch it, rather than coding to avoid it. Further, it\nmakes it difficult to distinguish between the unexpectedly-encountered\nnull\nvalue and the condition which causes the method to purposely\nthrow an NPE.\nIf an NPE is being thrown to indicate that a parameter to the method should not have been null, use the\n@NotNull\nannotation\ninstead.\nNoncompliant code example\n```java\npublic void doSomething (String aString) throws NullPointerException {\n     throw new NullPointerException();\n}\n```\nCompliant solution\n```java\npublic void doSomething (@NotNull String aString) {\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1694": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An abstract class should have both abstract and concrete methods\nDescription: Why is this an issue?\nThe purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be implemented by sub-classes.\nA class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a concrete class (i.e. remove the\nabstract\nkeyword) with a private constructor.\nA class with only abstract methods and no inheritable behavior should be converted to an interface.\nNoncompliant code example\n```java\npublic abstract class Animal {  // Noncompliant; should be an interface\n  abstract void move();\n  abstract void feed();\n}\n\npublic abstract class Color {  // Noncompliant; should be concrete with a private constructor\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  public int getRed() {\n    return red;\n  }\n}\n```\nCompliant solution\n```java\npublic interface Animal {\n  void move();\n  void feed();\n}\n\npublic class Color {\n  private int red = 0;\n  private int green = 0;\n  private int blue = 0;\n\n  private Color () {}\n\n  public int getRed() {\n    return red;\n  }\n}\n\npublic abstract class Lamp {\n\n  private boolean switchLamp=false;\n\n  public abstract void glow();\n\n  public void flipSwitch() {\n    switchLamp = !switchLamp;\n    if (switchLamp) {\n      glow();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1659": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Multiple variables should not be declared on the same line\nDescription: Why is this an issue?\nDeclaring multiple variables on one line is difficult to read.\nNoncompliant code example\n```java\nclass MyClass {\n\n  private int a, b;\n\n  public void method(){\n    int c; int d;\n  }\n}\n```\nCompliant solution\n```java\nclass MyClass {\n\n  private int a;\n  private int b;\n\n  public void method(){\n    int c;\n    int d;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1643": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Strings should not be concatenated using '+' in a loop\nDescription: Why is this an issue?\nStrings are immutable objects, so concatenation doesn\u2019t simply add the new String to the end of the existing string. Instead, in each loop\niteration, the first String is converted to an intermediate object type, the second string is appended, and then the intermediate object is converted\nback to a String. Further, performance of these intermediate operations degrades as the String gets longer. Therefore, the use of StringBuilder is\npreferred.\nNoncompliant code example\n```java\nString str = \"\";\nfor (int i = 0; i < arrayOfStrings.length ; ++i) {\n  str = str + arrayOfStrings[i];\n}\n```\nCompliant solution\n```java\nStringBuilder bld = new StringBuilder();\n  for (int i = 0; i < arrayOfStrings.length; ++i) {\n    bld.append(arrayOfStrings[i]);\n  }\n  String str = bld.toString();\n```\nBenchmarks\nMethod\nsize\nRuntime\nAverage time\nError margin\nplus\n100\nTemurin 21\n4.19 \u00b5s/op\n\u00b10.34 \u00b5s/op\nplus\n1000\nTemurin 21\n377.08 \u00b5s/op\n\u00b117.36 \u00b5s/op\nplus\n10000\nTemurin 21\n40221.49 \u00b5s/op\n\u00b11342.76 \u00b5s/op\nplus\n100000\nTemurin 21\n5286840.53 \u00b5s/op\n\u00b1185796.75 \u00b5s/op\nstringBuilder\n100\nTemurin 21\n0.97 \u00b5s/op\n\u00b10.03 \u00b5s/op\nstringBuilder\n1000\nTemurin 21\n10.25 \u00b5s/op\n\u00b11.64 \u00b5s/op\nstringBuilder\n10000\nTemurin 21\n93.27 \u00b5s/op\n\u00b116.05 \u00b5s/op\nstringBuilder\n100000\nTemurin 21\n1019.91 \u00b5s/op\n\u00b169.58 \u00b5s/op\nBenchmarking code\nThe results were generated by running the following snippet with\nJMH\n.\n```java\n@Param({\"100\", \"1000\", \"10000\", \"100000\"})\nint size;\nprivate String word = \"append\";\n\n@Benchmark\npublic String plus() {\n  String str = \"\";\n  for (int i = 0; i < size; i++) {\n    str = str + word;\n  }\n  return str;\n}\n\n@Benchmark\npublic String stringBuilder() {\n  StringBuilder builder = new StringBuilder();\n  for (int i = 0; i < size; i++) {\n    builder.append(word);\n  }\n  return builder.toString();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1641": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Sets with elements that are enum values should be replaced with EnumSet\nDescription: Why is this an issue?\nWhen all the elements in a Set are values from the same enum, the Set can be replaced with an EnumSet, which can be much more efficient than other\nsets because the underlying data structure is a simple bitmap.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set<COLOR> warm = new HashSet<COLOR>();\n    warm.add(COLOR.RED);\n    warm.add(COLOR.ORANGE);\n  }\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  public enum COLOR {\n    RED, GREEN, BLUE, ORANGE;\n  }\n\n  public void doSomething() {\n    Set<COLOR> warm = EnumSet.of(COLOR.RED, COLOR.ORANGE);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1640": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Maps with keys that are enum values should use the EnumMap implementation\nDescription: Why is this an issue?\nIf all the keys in a\nMap\nare values from a single enum, it is recommended to use an\nEnumMap\nas the specific\nimplementation. An\nEnumMap\n, which has the advantage of knowing all possible keys in advance, is more efficient compared to other\nimplementations, as it can use a simple array as its underlying data structure.\nNoncompliant code example\n```java\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap<Color, String> colorMap = new HashMap<>(); // Noncompliant\n```\nCompliant solution\n```java\npublic enum Color {\n  RED, GREEN, BLUE, ORANGE;\n}\n\nMap<Color, String> colorMap = new EnumMap<>(Color.class); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1612": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas should be replaced with method references\nDescription: Why is this an issue?\nMethod or constructor references are more readable than lambda expressions in many situations, and may therefore be preferred.\nHowever, method references are sometimes less concise than lambdas. In such cases, it might be preferrable to keep the lambda expression for better\nreadability. Therefore, this rule only raises issues on lambda expressions where the replacement method reference is shorter.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n, as lambda expressions were\nintroduced in Java 8.\nHow to fix it\nRefer to the called method by its reference instead of wrapping it in a lambda expression.\nFor instance:\n1. nullchecks can be replaced with references toObjects::isNullandObjects::nonNull\n2. Casts can be replaced withSomeClass.class::cast\n3. instanceofcan be replaced withSomeClass.class::isInstance\nCode examples\nNoncompliant code example\n```java\nclass A {\n  void process(List<A> list) {\n    list.stream()\n      .filter(myListValue -> myListValue instanceof B)     // Noncompliant\n      .map(listValueToMap -> (B) listValueToMap)           // Noncompliant\n      .map(bValueToMap -> bValueToMap.<String>getObject()) // Noncompliant\n      .forEach(o -> System.out.println(o));                // Noncompliant\n  }\n}\n\nclass B extends A {\n  <T> T getObject() {\n    return null;\n  }\n}\n```\nCompliant solution\n```java\nclass A {\n  void process(List<A> list) {\n    list.stream()\n      .filter(B.class::isInstance)   // Compliant\n      .map(B.class::cast)            // Compliant\n      .map(B::<String>getObject)     // Compliant\n      .forEach(System.out::println); // Compliant\n  }\n}\n\nclass B extends A {\n  <T> T getObject() {\n    return null;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1611": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Parentheses should be removed from a single lambda parameter when its type is inferred\nDescription: Why is this an issue?\nLambda expressions with only one argument with an inferred type (i.e., no explicit type declaration) can be written without parentheses around that\nsingle parameter. This syntax is simpler, more compact and readable than using parentheses and is therefore preferred.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n, as lambda expressions were\nintroduced in Java 8.\nNoncompliant code example\n```java\n(x) -> x * 2\n```\nCompliant solution\n```java\nx -> x * 2\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1610": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract classes without fields should be converted to interfaces\nDescription: This rule is deprecated, and will eventually be removed.\nWhy is this an issue?\nWith Java 8\u2019s \"default method\" feature, any abstract class without direct or inherited field should be converted into an interface. However, this\nchange may not be appropriate in libraries or other applications where the class is intended to be used as an API.\nNote\nthat this rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n.\nNoncompliant code example\n```java\npublic abstract class Car {\n  public abstract void start(Environment c);\n\n  public void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n```\nCompliant solution\n```java\npublic interface Car {\n  public void start(Environment c);\n\n  public default void stop(Environment c) {\n    c.freeze(this);\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1607": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: JUnit4 @Ignored and JUnit5 @Disabled annotations should be used to disable tests and should provide a rationale\nDescription: Why is this an issue?\nWhen a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why\nthe test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up\npolluting their projects.\nThis rule raises an issue for each ignored test that does not have any comment about why it is being skipped.\n1. For Junit4, this rule targets the @Ignore annotation.\n2. For Junit5, this rule targets the @Disabled annotation.\n3. Cases where assumeTrue(false) or assumeFalse(true) are used to skip tests are targeted as well.\nNoncompliant code example\n```java\n@Ignore  // Noncompliant\n@Test\npublic void testDoTheThing() {\n  // ...\n```\nor\n```java\n@Test\npublic void testDoTheThing() {\n  Assume.assumeFalse(true); // Noncompliant\n  // ...\n```\nCompliant solution\n```java\n@Test\n@Ignore(\"See Ticket #1234\")\npublic void testDoTheThing() {\n  // ...\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1604": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Anonymous inner classes containing only one method should become lambdas\nDescription: Why is this an issue?\nBefore Java 8, the only way to partially support closures in Java was by using anonymous inner classes. Java 8 introduced lambdas, which are\nsignificantly more readable and should be used instead.\nThis rule is automatically disabled when the project\u2019s\nsonar.java.source\nis lower than\n8\n, as lambda expressions were\nintroduced in Java 8.\nCode examples\nNoncompliant code example\n```java\nmyCollection.stream().map(new Function<String,String>() { // Noncompliant, use a lambda expression instead\n  @Override\n  public String apply(String input) {\n    return new StringBuilder(input).reverse().toString();\n  }\n})\n  ...\n```\nCompliant solution\n```java\nmyCollection.stream()\n  .map(input -> new StringBuilder(input).reverse().toString()) // Compliant\n    ...\n```\nNoncompliant code example\n```java\nPredicate<String> isEmpty = new Predicate<String>() { // Noncompliant, use a lambda expression instead\n  @Override\n  public boolean test(String myString) {\n    return myString.isEmpty();\n  }\n};\n```\nCompliant solution\n```java\nPredicate<String> isEmpty = myString -> myString.isEmpty(); // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1602": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lambdas containing only one statement should not nest this statement in a block\nDescription: This rule raises an issue when a lambda expression uses block notation while expression notation could be used.\nWhy is this an issue?\nThe right-hand side of a lambda expression can be written in two ways:\nExpression notation: the right-hand side is as an expression, such as in\n(a, b) \u2192 a + b\nBlock notation: the right-hand side is a conventional function body with a code block and an optional return statement, such as in\n(a, b)\n  \u2192 {return a + b;}\nBy convention, expression notation is preferred over block notation. Block notation must be used when the function implementation requires more\nthan one statement. However, when the code block consists of only one statement (which may or may not be a\nreturn\nstatement), it can be\nrewritten using expression notation.\nThis convention exists because expression notation has a cleaner, more concise, functional programming style and is regarded as more readable.\nHow to fix it\n1. If the code block consists only of areturnstatement, replace the code block with the argument expression from thereturnstatement.\n2. If the code block consists of a single statement that is not areturnstatement, replace the code block with that statement.\nCode examples\nNoncompliant code example\n```java\n(a, b) -> { return a + b; } // Noncompliant, replace code block with expression\n```\nCompliant solution\n```java\n(a, b) -> a + b             // Compliant\n```\nNoncompliant code example\n```java\nx -> {System.out.println(x+1);} // Noncompliant, replace code block with statement\n```\nCompliant solution\n```java\nx -> System.out.println(x+1)    // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1598": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Package declaration should match source file directory\nDescription: Why is this an issue?\nThe purpose of Java packages is to give structure to your project. A structure helps to mentally break down a project into smaller parts,\nsimplifying readers' understanding of how components are connected and how they interact.\nBy convention, the source files' directory structure should replicate the project\u2019s package structure. This is for the following reasons:\nThe mapping between the package name and the location of the source file of a class is straightforward. That is, the path to the source file is\n  easier to find for a given fully qualified class name.\nIf two different structures are applied to the same project - one to the packages but another to the source file directories - this confuses\n  developers while not providing any benefit.\nThe directory structure of the class files generated by the compiler will match the package structure, no matter the source file\u2019s directory.\n  It would not make sense to have one directory structure for the generated class files but a different one for the associated source files.\nSimilarly, a source directory should not have the character\n.\nin its name, as this would make it impossible to match the directory to\nthe package structure.\nHow to fix it\nEither move the source file so that the relative file path within the source directory matches the package name, or change the package name so that\nit matches the relative file path.\nCode examples\nNoncompliant code example\n```java\n// file: src/main/foo/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n```\nCompliant solution\n```java\n// file: src/main/com/foo/bar/Fubar.java\npackage com.foo.bar;\n\nclass Fubar {\n}\n```\n```java\n// file: src/main/foo/Fubar.java\npackage foo;\n\nclass Fubar {\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1596": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Collections.EMPTY_LIST\", \"EMPTY_MAP\", and \"EMPTY_SET\" should not be used\nDescription: This rule raises an issue when the\nCollections.EMPTY_*\nfields are used instead of the\nCollections.empty*()\nmethods.\nWhy is this an issue?\nGeneric types (types with type parameters) have been introduced into Java with language version 1.5. If type parameters are specified for a class\nor method, it is still possible to ignore them to keep backward compatibility with older code, which is called the\nraw type\nof the class or\ninterface.\nUsing raw type expressions is highly discouraged because the compiler cannot perform static type checking on them. This means that the compiler\nwill not report typing errors about them at compile time, but a\nClassCastException\nwill be thrown during runtime.\nIn Java 1.5, generics were also added to the Java collections API, and the data structures in\njava.util\n, such as\nList\n,\nSet\n, or\nMap\n, now feature type parameters.\nCollections.EMPTY_LIST\n,\nCollections.EMPTY_SET\n, and\nCollections.EMPTY_MAP\nare relics from before generics, and they return raw lists, sets, or maps, with the limitations mentioned\nabove.\nHow to fix it\nUse:\n1. Collections.emptyList()instead ofCollections.EMPTY_LIST\n2. Collections.emptySet()instead ofCollections.EMPTY_SET\n3. Collections.emptyMap()instead ofCollections.EMPTY_MAP\nIn addition, there are variants of\nCollections.empty*()\navailable also for other collection interfaces, such as\nCollections.emptyIterator()\n,\nCollections.emptyNavigableMap()\n,\nCollections.emptySortedSet()\n.\nCode examples\nNoncompliant code example\n```java\nList<String> collection1 = Collections.EMPTY_LIST;     // Noncompliant, raw List\nSet<Float> collection2 = Collections.EMPTY_SET;        // Noncompliant, raw Set\nMap<Int, String> collection3 = Collections.EMPTY_MAP;  // Noncompliant, raw Map\n```\nCompliant solution\n```java\nList<String> collection1 = Collections.emptyList();    // Compliant, List<String>\nSet<Float> collection2 = Collections.emptySet();       // Compliant, Set<Float>\nMap<Int, String> collection3 = Collections.emptyMap(); // Compliant, Map<Int, String>\n```\nDocumentation\n1. Oracle - Java\u2122 Platform, Standard Edition 8 API Specification,\n  Class Collections\n2. Oracle - The Java\u2122 Tutorials - Raw Types\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1541": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not be too complex\nDescription: Why is this an issue?\nThe cyclomatic complexity of methods should not exceed a defined threshold.\nComplex code can perform poorly and will in any case be difficult to understand and therefore to maintain.\nExceptions\nWhile having a large number of fields in a class may indicate that it should be split, this rule nonetheless ignores high complexity in\nequals\nand\nhashCode\nmethods.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1488": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local variables should not be declared and then immediately returned or thrown\nDescription: Why is this an issue?\nDeclaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. This\npractice can make the code harder to read and understand, as it introduces an extra step that doesn\u2019t add any value. Instead of declaring a variable\nand then immediately returning or throwing it, it is generally better to return or throw the value directly. This makes the code cleaner, simpler, and\neasier to understand.\nHow to fix it\nDeclaring a variable only to immediately return or throw it is considered a bad practice because it adds unnecessary complexity to the code. To fix\nthe issue, return or throw the value directly.\nCode examples\nNoncompliant code example\n```java\npublic long computeDurationInMilliseconds() {\n  long duration = (((hours * 60) + minutes) * 60 + seconds) * 1000;\n  return duration;\n}\n```\nCompliant solution\n```java\npublic long computeDurationInMilliseconds() {\n  return (((hours * 60) + minutes) * 60 + seconds) * 1000;\n}\n```\nNoncompliant code example\n```java\npublic void doSomething() {\n  RuntimeException myException = new RuntimeException();\n  throw myException;\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  throw new RuntimeException();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1481": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused local variables should be removed\nDescription: Why is this an issue?\nAn unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code,\ncontributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain\nclarity and efficiency.\nWhat is the potential impact?\nHaving unused local variables in your code can lead to several issues:\n1. Decreased Readability: Unused variables can make your code more difficult to read. They add extra lines and complexity, which\n  can distract from the main logic of the code.\n2. Misunderstanding: When other developers read your code, they may wonder why a variable is declared but not used. This can lead\n  to confusion and misinterpretation of the code\u2019s intent.\n3. Potential for Bugs: If a variable is declared but not used, it might indicate a bug or incomplete code. For example, if you\n  declared a variable intending to use it in a calculation, but then forgot to do so, your program might not work as expected.\n4. Maintenance Issues: Unused variables can make code maintenance more difficult. If a programmer sees an unused variable, they\n  might think it is a mistake and try to 'fix' the code, potentially introducing new bugs.\n5. Memory Usage: Although modern compilers are smart enough to ignore unused variables, not all compilers do this. In such cases,\n  unused variables take up memory space, leading to inefficient use of resources.\nIn summary, unused local variables can make your code less readable, more confusing, and harder to maintain, and they can potentially lead to bugs\nor inefficient memory use. Therefore, it is best to remove them.\nHow to fix it\nThe fix for this issue is straightforward. Once you ensure the unused variable is not part of an incomplete implementation, you just need to remove\nit.\nJava 22 introduces the unnamed variable pattern\n_\n. When a variable declared within a pattern match, an enhanced for loop, or a try\nwith resource is unused, you should replace its name with the unnamed variable pattern to clearly indicate the intent not to use the variable.\nCode examples\nNoncompliant code example\n```java\npublic int numberOfMinutes(int hours) {\n  int seconds = 0;   // Noncompliant: \"seconds\" is unused\n  return hours * 60;\n}\n```\n```java\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, int age) -> name; // Noncompliant: \"age\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic String type(Person p) {\n  return switch (p) {\n    case User user -> \"user\"; // Noncompliant:  \"user\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic int age(Person p) {\n  if (p instanceof User(String name, int age)) { // Noncompliant:  \"name\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    return age;\n  }\n}\n```\n```java\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var el : elements) { // Noncompliant:  \"el\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    count++;\n  }\n  return count;\n}\n```\n```java\npublic void foo() {\n  try (var file = Files.createTempFile(directory, \"temp\", \".txt\")) { // Noncompliant:  \"file\" is unused replace it with the unnamed variable pattern (starting from Java 22)\n    System.out.println(\"file created\");\n  }\n}\n```\nCompliant solution\n```java\npublic int numberOfMinutes(int hours) {\n  return hours * 60;\n}\n```\n```java\npublic String name(Person p) {\n  return switch (p) {\n    case User(String name, _) -> name; // Compliant\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic String type(Person p) {\n  return switch (p) {\n    case User _ -> \"user\"; // Compliant\n    default -> throw new IllegalArgumentException();\n  };\n}\n```\n```java\npublic int age(Person p) {\n  if (p instanceof User(String _, int age)) { // Compliant\n    return age;\n  }\n}\n```\n```java\npublic static int count(int[] elements) {\n  int count = 0;\n  for (var _ : elements) { // Compliant\n    count++;\n  }\n  return count;\n}\n```\n```java\npublic void foo() {\n  try (var _ = Files.createTempFile(directory, \"temp\", \".txt\")) { // Compliant\n    System.out.println(\"file created\");\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1479": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements should not have too many \"case\" clauses\nDescription: Why is this an issue?\nWhen\nswitch\nstatements have large sets of\ncase\nclauses, it is usually an attempt to map two sets of data. A real map\nstructure would be more readable and maintainable, and should be used instead.\nExceptions\nThis rule ignores\nswitch\nes over\nEnum\ns and empty, fall-through cases.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1452": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Generic wildcard types should not be used in return types\nDescription: Why is this an issue?\nA return type containing wildcards cannot be narrowed down in any context. This indicates that the developer\u2019s intention was likely something\nelse.\nThe core problem lies in type variance. Expressions at an input position, such as arguments passed to a method, can have a more specific type than\nthe type expected by the method, which is called\ncovariance\n. Expressions at an output position, such as a variable that receives the return\nresult from a method, can have a more general type than the method\u2019s return type, which is called\ncontravariance\n. This can be traced back to\nthe Liskov substitution principle.\nIn Java, type parameters of a generic type are invariant by default due to their potential occurrence in both input and output positions at the\nsame time. A classic example of this is the methods\nT get()\n(output position) and\nadd(T element)\n(input position) in\ninterface\njava.util.List\n. We could construct cases with invalid typing in\nList\nif\nT\nwere not invariant.\nWildcards can be employed to achieve covariance or contravariance in situations where the type parameter appears in one position only:\n1. <? extends Foo>for covariance (input positions)\n2. <? super Foo>for contravariance (output positions)\nHowever, covariance is ineffective for the return type of a method since it is not an input position. Making it contravariant also has no effect\nsince it is the receiver of the return value which must be contravariant (use-site variance in Java). Consequently, a return type containing wildcards\nis generally a mistake.\nHow to fix it\nThe solution to this problem depends on the original intention of the developer. Given the examples:\n```java\nList<? extends Animal> getAnimals() { ... } // Noncompliant, wildcard with no use\nList<? super Plant> getLifeforms() { ... }  // Noncompliant, wildcard with no use\n```\nYou can remove the wildcards to make the types invariant:\n```java\nList<Animal> getAnimals() { ... }           // Compliant, using invariant type instead\nList<Plant> getLifeforms() { ... }          // Compliant, using invariant type instead\n```\nOr replace them with a super- or subtypes (still invariant):\n```java\nList<Dog> getAnimals() { ... }              // Compliant, using subtype instead\nList<Lifeform> getLifeforms() { ... }       // Compliant, using supertype instead\n```\nDocumentation\n1. The Java\u2122 Tutorials - Wildcards\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1451": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track lack of copyright and license headers\nDescription: Why is this an issue?\nEach source file should start with a header stating file ownership and the license which must be used to distribute the application.\nThis rule must be fed with the header text that is expected at the beginning of every file.\nCompliant solution\n```java\n/*\n * SonarQube, open source software quality management tool.\n * Copyright (C) 2008-2013 SonarSource\n * mailto:contact AT sonarsource DOT com\n *\n * SonarQube is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * SonarQube is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this program; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n */\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1450": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Private fields only used as local variables in methods should become local variables\nDescription: Why is this an issue?\nWhen the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class\ninformation. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.\nNoncompliant code example\n```java\npublic class Foo {\n  private int a;\n  private int b;\n\n  public void doSomething(int y) {\n    a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n    ...\n  }\n\n  public void doSomethingElse(int y) {\n    b = y + 3;\n    ...\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo {\n\n  public void doSomething(int y) {\n    int a = y + 5;\n    ...\n    if(a == 0) {\n      ...\n    }\n  }\n\n  public void doSomethingElse(int y) {\n    int b = y + 3;\n    ...\n  }\n}\n```\nExceptions\nThis rule doesn\u2019t raise any issue on annotated field.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1449": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: String operations should not rely on the default system locale\nDescription: Why is this an issue?\nFailure to specify a locale when calling the methods\ntoLowerCase()\n,\ntoUpperCase()\nor\nformat()\non\nString\nobjects means the system default encoding will be used, possibly creating problems with international characters or number\nrepresentations. For instance with the Turkish language, when converting the small letter 'i' to upper case, the result is capital letter 'I' with a\ndot over it.\nCase conversion without a locale may work fine in its \"home\" environment, but break in ways that are extremely difficult to diagnose for customers\nwho use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it\u2019s time to fix them. For locale-sensitive\nstrings, the correct locale should always be used, but\nLocale.ROOT\ncan be used for case-insensitive ones.\nNoncompliant code example\n```java\nmyString.toLowerCase()\n```\nCompliant solution\n```java\nmyString.toLowerCase(Locale.TR)\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1448": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not have too many methods\nDescription: Why is this an issue?\nA class that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\nAbove a specific threshold, it is strongly advised to refactor the class into smaller ones which focus on well defined topics.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1444": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"public static\" fields should be constant\nDescription: Why is this an issue?\nThere is no good reason to declare a field \"public\" and \"static\" without also declaring it \"final\". Most of the time this is a kludge to share a\nstate among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to\nnull\n.\nNoncompliant code example\n```java\npublic class Greeter {\n  public static Foo foo = new Foo();\n  ...\n}\n```\nCompliant solution\n```java\npublic class Greeter {\n  public static final Foo FOO = new Foo();\n  ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-139": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Comments should not be located at the end of lines of code\nDescription: Why is this an issue?\nThis rule verifies that single-line comments are not located at the ends of lines of code. The main idea behind this rule is that in order to be\nreally readable, trailing comments would have to be properly written and formatted (correct alignment, no interference with the visual structure of\nthe code, not too long to be visible) but most often, automatic code formatters would not handle this correctly: the code would end up less readable.\nComments are far better placed on the previous empty line of code, where they will always be visible and properly formatted.\nNoncompliant code example\n```java\nint a1 = b + c; // This is a trailing comment that can be very very long\n```\nCompliant solution\n```java\n// This very long comment is better placed before the line of code\nint a2 = b + c;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-138": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not have too many lines\nDescription: Why is this an issue?\nA method that grows too large tends to aggregate too many responsibilities. Such method inevitably become harder to understand and therefore harder\nto maintain.\nAbove a specific threshold, it is strongly advised to refactor into smaller methods which focus on well-defined tasks. Those smaller methods will\nnot only be easier to understand, but also probably easier to test.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-135": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loops should not contain more than a single \"break\" or \"continue\" statement\nDescription: Why is this an issue?\nThe use of\nbreak\nand\ncontinue\nstatements increases the complexity of the control flow and makes it harder to understand\nthe program logic. In order to keep a good program structure, they should not be applied more than once per loop.\nThis rule reports an issue when there is more than one\nbreak\nor\ncontinue\nstatement in a loop. The code should be\nrefactored to increase readability if there is more than one.\nNoncompliant code example\n```java\nfor (int i = 1; i <= 10; i++) {     // Noncompliant; two \"continue\" statements\n  if (i % 2 == 0) {\n    continue;\n  }\n\n  if (i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n```\nCompliant solution\n```java\nfor (int i = 1; i <= 10; i++) {\n  if (i % 2 == 0 || i % 3 == 0) {\n    continue;\n  }\n  // ...\n}\n```\nDocumentation\n1. Oracle - Labeled Statements\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-134": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Control flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply\nDescription: Why is this an issue?\nNested control flow statements such as\nif\n,\nfor\n,\nwhile\n,\nswitch\n, and\ntry\nare often\nkey ingredients in creating what\u2019s known as \"Spaghetti code\". This code smell can make your program difficult to understand and maintain.\nWhen numerous control structures are placed inside one another, the code becomes a tangled, complex web. This significantly reduces the code\u2019s\nreadability and maintainability, and it also complicates the testing process.\nHow to fix it\nCode examples\nThe following example demonstrates the behavior of the rule with the default threshold of 3 levels of nesting and one of the potential ways to fix\nthe code smell by introducing guard clauses:\nNoncompliant code example\n```java\nif (condition1) {                  // Compliant - depth = 1\n  /* ... */\n  if (condition2) {                // Compliant - depth = 2\n    /* ... */\n    for (int i = 0; i < 10; i++) {  // Compliant - depth = 3\n      /* ... */\n      if (condition4) {            // Noncompliant - depth = 4, which exceeds the limit\n        if (condition5) {          // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\n          /* ... */\n        }\n        return;\n      }\n    }\n  }\n}\n```\nCompliant solution\n```java\nif (!condition1) {\n  return;\n}\n/* ... */\nif (!condition2) {\n  return;\n}\nfor (int i = 0; i < 10; i++) {\n  /* ... */\n  if (condition4) {\n    if (condition5) {\n      /* ... */\n    }\n    return;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1319": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Declarations should use Java collection interfaces such as \"List\" rather than specific implementation classes such as \"LinkedList\"\nDescription: This rule raises an issue when a collection implementation class from\njava.util.*\nis used:\n1. as a return type of apublicmethod.\n2. as an argument type of apublicmethod.\n3. as the type of apublicfield.\nWhy is this an issue?\nThe Java Collections API offers a well-structured hierarchy of interfaces designed to hide collection implementation details. For the various\ncollection data structures like lists, sets, and maps, specific interfaces (\njava.util.List\n,\njava.util.Set\n,\njava.util.Map\n) cover the essential features.\nWhen passing collections as method parameters, return values, or when exposing fields, it is generally recommended to use these interfaces instead\nof the implementing classes. The implementing classes, such as\njava.util.LinkedList\n,\njava.util.ArrayList\n, and\njava.util.HasMap\n, should only be used for collection instantiation. They provide finer control over the performance characteristics of\nthose structures, and developers choose them depending on their use case.\nFor example, if fast random element access is essential,\njava.util.ArrayList\nshould be instantiated. If inserting elements at a random\nposition into a list is crucial, a\njava.util.LinkedList\nshould be preferred. However, this is an implementation detail your API should\nnot expose.\nCode examples\nNoncompliant code example\n```java\npublic class Employees {\n  public final HashSet<Employee> employees   // Noncompliant, field type should be \"Set\"\n    = new HashSet<Employee>();\n\n  public HashSet<Employee> getEmployees() {  // Noncompliant, return type should be \"Set\"\n    return employees;\n  }\n}\n```\nCompliant solution\n```java\npublic class Employees {\n  public final Set<Employee> employees       // Compliant\n    = new HashSet<Employee>();\n\n  public Set<Employee> getEmployees() {      // Compliant\n    return employees;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1315": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"CHECKSTYLE:OFF\" suppression comments\nDescription: Why is this an issue?\nThis rule allows you to track the use of the Checkstyle suppression comment mechanism.\nNoncompliant code example\n```java\n// CHECKSTYLE:OFF\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1314": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Octal values should not be used\nDescription: Why is this an issue?\nInteger literals starting with a zero are octal rather than decimal values. While using octal values is fully supported, most developers do not\nhave experience with them. They may not recognize octal values as such, mistaking them instead for decimal values.\nNoncompliant code example\n```java\nint myNumber = 010; // Noncompliant. myNumber will hold 8, not 10 - was this really expected?\n```\nCompliant solution\n```java\nint myNumber = 8;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1312": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Loggers should be \"private static final\" and should share a naming convention\nDescription: Why is this an issue?\nRegardless of the logging framework in use (logback, log4j, commons-logging, java.util.logging, \u2026\u200b), loggers should be:\n1. private: never be accessible outside of its parent class. If another class needs to log something, it should instantiate its own\n  logger.\n2. static: not be dependent on an instance of a class (an object). When logging something, contextual information can of course be\n  provided in the messages but the logger should be created at class level to prevent creating a logger along with each object.\n3. final: be created once and only once per class.\nNoncompliant code example\nWith a default regular expression of\nLOG(?:GER)?\n:\n```java\npublic Logger logger = LoggerFactory.getLogger(Foo.class);  // Noncompliant\n```\nCompliant solution\n```java\nprivate static final Logger LOGGER = LoggerFactory.getLogger(Foo.class);\n```\nExceptions\nVariables of type\norg.apache.maven.plugin.logging.Log\nare ignored.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1310": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"NOPMD\" suppression comments \nDescription: Why is this an issue?\nThis rule allows you to track the use of the PMD suppression comment mechanism.\nNoncompliant code example\n```java\n// NOPMD\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-131": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements should have \"default\" clauses\nDescription: Why is this an issue?\nThe requirement for a final\ndefault\nclause is defensive programming. The clause should either take appropriate action, or contain a\nsuitable comment as to why no action is taken.\nNoncompliant code example\n```java\nswitch (param) {  //missing default clause\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n\nswitch (param) {\n  default: // default clause should be the last one\n    error();\n    break;\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n}\n```\nCompliant solution\n```java\nswitch (param) {\n  case 0:\n    doSomething();\n    break;\n  case 1:\n    doSomethingElse();\n    break;\n  default:\n    error();\n    break;\n}\n```\nExceptions\nIf the\nswitch\nparameter is an\nEnum\nand if all the constants of this enum are used in the\ncase\nstatements,\nthen no\ndefault\nclause is expected.\nExample:\n```java\npublic enum Day {\n    SUNDAY, MONDAY\n}\n...\nswitch(day) {\n  case SUNDAY:\n    doSomething();\n    break;\n  case MONDAY:\n    doSomethingElse();\n    break;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1309": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"@SuppressWarnings\" annotations\nDescription: Why is this an issue?\nThis rule allows you to track the usage of the\n@SuppressWarnings\nmechanism.\nNoncompliant code example\nWith a parameter value of \"unused\" :\n```java\n@SuppressWarnings(\"unused\")\n@SuppressWarnings(\"unchecked\")  // Noncompliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1301": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements should have at least 3 \"case\" clauses\nDescription: Why is this an issue?\nswitch\nstatements are useful when there are many different cases depending on the value of the same expression.\nFor just one or two cases, however, the code will be more readable with\nif\nstatements.\nNoncompliant code example\n```java\nswitch (variable) {\n  case 0:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n```\nCompliant solution\n```java\nif (variable == 0) {\n  doSomething();\n} else {\n  doSomethingElse();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1291": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"NOSONAR\" comments\nDescription: Why is this an issue?\nAny issue to quality rule can be deactivated with the\nNOSONAR\nmarker. This marker is pretty useful to exclude false-positive results\nbut it can also be used abusively to hide real quality flaws.\nThis rule raises an issue when\nNOSONAR\nis used.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-128": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Switch cases should end with an unconditional \"break\" statement\nDescription: Why is this an issue?\nWhen the execution is not explicitly terminated at the end of a switch case, it continues to execute the statements of the following case. While\nthis is sometimes intentional, it often is a mistake which leads to unexpected behavior.\nNoncompliant code example\n```java\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:  // Both 'doSomething()' and 'doSomethingElse()' will be executed. Is it on purpose ?\n    doSomething();\n  default:\n    doSomethingElse();\n    break;\n}\n```\nCompliant solution\n```java\nswitch (myVariable) {\n  case 1:\n    foo();\n    break;\n  case 2:\n    doSomething();\n    break;\n  default:\n    doSomethingElse();\n    break;\n}\n```\nExceptions\nThis rule is relaxed in the following cases:\n```java\nswitch (myVariable) {\n  case 0:                                // Empty case used to specify the same behavior for a group of cases.\n  case 1:\n    doSomething();\n    break;\n  case 2:                                // Use of a fallthrough comment\n    // fallthrough\n  case 3:                                // Use of return statement\n    return;\n  case 4:                                // Use of throw statement\n    throw new IllegalStateException();\n  case 5:                                // Use of continue statement\n    continue;\n  default:                               // For the last case, use of break statement is optional\n    doSomethingElse();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-127": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"for\" loop stop conditions should be invariant\nDescription: Why is this an issue?\nA\nfor\nloop termination condition should test the loop counter against an invariant value that does not change during the execution of\nthe loop. Invariant termination conditions make the program logic easier to understand and maintain.\nThis rule tracks three types of non-invariant termination conditions:\n1. When the loop counters are updated in the body of theforloop\n2. When the termination condition depends on a method call\n3. When the termination condition depends on an object property since such properties could change during the execution of the loop.\nHow to fix it\nCode examples\nNoncompliant code example\nMake the termination condition invariant by using a constant or a local variable instead of an expression that could change during the execution of\nthe loop.\n```java\nfor (int i = 0; i < foo(); i++) { // Noncompliant, \"foo()\" is not an invariant\n  // ...\n}\n```\nCompliant solution\n```java\nint end = foo();\nfor (int i = 0; i < end; i++) { // Compliant, \"end\" does not change during loop execution\n  // ...\n}\n```\nNoncompliant code example\nIf this is impossible and the counter variable must be updated in the loop\u2019s body, use a\nwhile\nor\ndo\nwhile\nloop instead of a\nfor\nloop.\n```java\nfor (int i = 0; i < 10; i++) {\n  // ...\n  if (condition) i++; // Noncompliant, i is updated from within body\n  // ...\n}\n```\nCompliant solution\n```java\nint i = 0;\nwhile (i++ < 10) { // Compliant\n  // ...\n  if (condition) sum++;\n  // ...\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1264": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A \"while\" loop should be used instead of a \"for\" loop\nDescription: Why is this an issue?\nA\nfor\nloop is a type of loop construct that allows a block of code to be executed repeatedly for a fixed number of times. The\nfor\nloop is typically used when the number of iterations is known in advance and consists of three parts:\n1. The initialization statement is executed once at the beginning of the loop. It is used to initialize the loop counter or any other variables\n  that may be used in the loop.\n2. The loop condition is evaluated at the beginning of each iteration, and if it istrue, the code inside the loop is executed.\n3. The update statement is executed at the end of each iteration and is used to update the loop counter or any other variables that may be used in\n  the loop.\n```java\nfor (initialization; termination; increment) { /*...*/ }\n```\nAll three statements are optional. However, when the initialization and update statements are not used, it can be unclear to the reader what the\nloop counter is and how it is being updated. This can make the code harder to understand and maintain.\nHow to fix it\nCode examples\nNoncompliant code example\n```java\nfor (;condition;) { /*...*/ } // Noncompliant; only the condition is specified\n```\nWhen only the condition expression is defined in a\nfor\nloop, a\nwhile\nloop should be used instead to increase readability.\nA\nwhile\nloop consists of a single loop condition and allows a block of code to be executed repeatedly as long as the specified condition\nis true.\nCompliant solution\n```java\nwhile (condition) { /*...*/ }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-126": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"if ... else if\" constructs should end with \"else\" clauses\nDescription: Why is this an issue?\nThis rule applies whenever an\nif\nstatement is followed by one or more\nelse if\nstatements; the final\nelse if\nshould be followed by an\nelse\nstatement.\nThe requirement for a final\nelse\nstatement is defensive programming.\nThe\nelse\nstatement should either take appropriate action or contain a suitable comment as to why no action is taken. This is\nconsistent with the requirement to have a final\ndefault\nclause in a\nswitch\nstatement.\nNoncompliant code example\n```java\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n}\n```\nCompliant solution\n```java\nif (x == 0) {\n  doSomething();\n} else if (x == 1) {\n  doSomethingElse();\n} else {\n  throw new IllegalStateException();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1258": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes and enums with private members should have a constructor\nDescription: Why is this an issue?\nNon-abstract classes and enums with non-\nstatic\n,\nprivate\nmembers should explicitly initialize those members, either in a\nconstructor or with a default value.\nNoncompliant code example\n```java\nclass A { // Noncompliant\n  private int field;\n}\n```\nCompliant solution\n```java\nclass A {\n  private int field;\n\n  A(int field) {\n    this.field = field;\n  }\n}\n```\nExceptions\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-125": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Sections of code should not be commented out\nDescription: Why is this an issue?\nCommented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never\nexecuted, it quickly becomes out of date and invalid.\nCommented-out code should be deleted and can be retrieved from source control history if required.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-124": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track comments matching a regular expression\nDescription: Why is this an issue?\nThis rule template can be used to create rules which will be triggered when the full content of a comment matches a given regular expression. Note\nthat the regular expression should be expressed using the dotall format (where the\n.\ncharacter matches any character).\nFor example, one can create a rule with the regular expression\n.*REVIEW.*\nto match all comment containing \"REVIEW\".\nNote that, in order to match REVIEW regardless of the case, the\n(?i)\nmodifier should be prepended to the expression, as in\n(?i).*REVIEW.*\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1228": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Packages should have a javadoc file 'package-info.java'\nDescription: Why is this an issue?\nEach package in a Java project should include a\npackage-info.java\nfile. The purpose of this file is to document the Java package using\njavadoc and declare package annotations.\nCompliant solution\n```java\n/**\n* This package has non null parameters and is documented.\n**/\n@ParametersAreNonnullByDefault\npackage org.foo.bar;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1223": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Non-constructor methods should not have the same name as the enclosing class\nDescription: Why is this an issue?\nHaving a class and some of its methods sharing the same name is misleading, and leaves others to wonder whether it was done that way on purpose, or\nwas the methods supposed to be a constructor.\nNoncompliant code example\n```java\npublic class Foo {\n   public Foo() {...}\n   public void Foo(String label) {...}  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class Foo {\n   public Foo() {...}\n   public void foo(String label) {...}  // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1220": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The default unnamed package should not be used\nDescription: Why is this an issue?\nJava packages serve two purposes:\nStructure\u2009\u2014\u2009Packages give a structure to the set of classes of your project. It is a bad practice to put all classes flat into the source\n  directory of a project without a package structure. A structure helps to mentally break down a project into smaller parts, simplifying readers'\n  understanding of how components are connected and how they interact.\nAvoiding name clashes\u2009\u2014\u2009a class part of the\ndefault package\nif no explicit package name is specified. This can easily cause name\n  collisions when other projects define a class of the same name.\nWhen no package is explicitly specified for the classes in your project, this makes the project harder to understand and may cause name collisions\nwith other projects. Also, classes located in the default package not be accessed from classes within named packages since Java 1.4.\nHow to fix it\nMove your class to a package directory and explicitly state the package\u2019s name at the top of the class. If your project does not have a package\nstructure, think of a structure that fits your needs. The package names should be unique to your project. You can find some best practices when\nchoosing package names in the Ressources section below.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass { /* ... */ } // Noncompliant, no package spacified\n```\nCompliant solution\n```java\npackage org.example; // Compliant\n\npublic class MyClass{ /* ... */ }\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-122": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Statements should be on separate lines\nDescription: Why is this an issue?\nPutting multiple statements on a single line lowers the code readability and makes debugging the code more complex.\n```java\nif (someCondition) doSomething(); // Noncompliant\n```\nWrite one statement per line to improve readability.\n```java\nif (someCondition) {\n  doSomething();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1219": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch\" statements should not contain non-case labels\nDescription: Why is this an issue?\nEven if it is legal, mixing case and non-case labels in the body of a switch statement is very confusing and can even be the result of a typing\nerror.\nNoncompliant code example\n```java\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  WEDNESDAY:   // Noncompliant; syntactically correct, but behavior is not what's expected\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    foo:for(int i = 0 ; i < X ; i++) {  // Noncompliant; the code is correct and behaves as expected but is barely readable\n         /* ... */\n        break foo;  // this break statement doesn't relate to the nesting case TUESDAY\n         /* ... */\n    }\n    break;\n    /* ... */\n}\n```\nCompliant solution\n```java\nswitch (day) {\n  case MONDAY:\n  case TUESDAY:\n  case WEDNESDAY:\n    doSomething();\n    break;\n  ...\n}\n\nswitch (day) {\n  case MONDAY:\n    break;\n  case TUESDAY:\n    compute(args); // put the content of the labelled \"for\" statement in a dedicated method\n    break;\n\n    /* ... */\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1215": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Execution of the Garbage Collector should be triggered only by the JVM\nDescription: Why is this an issue?\nCalling\nSystem.gc()\nor\nRuntime.getRuntime().gc()\nis a bad idea for a simple reason: there is no way to know exactly what\nwill be done under the hood by the JVM because the behavior will depend on its vendor, version and options:\n1. Will the whole application be frozen during the call?\n2. Is the-XX:DisableExplicitGCoption activated?\n3. Will the JVM simply ignore the call?\n4. \u2026\u200b\nLike for\nSystem.gc()\n, there is no reason to manually call\nrunFinalization()\nto force the call of finalization methods of\nany objects pending finalization.\nAn application relying on these unpredictable methods is also unpredictable and therefore broken. The task of running the garbage collector and\ncalling\nfinalize()\nmethods should be left exclusively to the JVM.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1214": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Interfaces should not solely consist of constants\nDescription: This rule raises an issue when an interface consists only of constant definitions without other members.\nWhy is this an issue?\nAn interface that consists solely of constant definitions is a bad practice. The purpose of interfaces is to provide an API, not implementation\ndetails. That is, they should provide functions in the first place and constants only to assist these functions, for example, as possible\narguments.\nIf an interface contains constants only, move them either to somewhere else, or replace the interface with an\nEnum\nor a final class with a\nprivate constructor.\nHow to fix it\nIf the concrete value of the constants is not essential, and they serve as mere identifiers, replace the interface with an\nenum\nlike\nin the following example:\n```java\npublic interface Status { // Noncompliant, enum should be used\n  int OPEN = 1;\n  int CLOSED = 2;\n}\n```\n```java\npublic enum Status {      // Compliant\n  OPEN,\n  CLOSED\n}\n```\nIn some cases, enums are not a suitable option because the concrete constant value is important. Then you should check whether it is appropriate to\nmove them to a specific existing class, for example, if that class is the primary user of the constants:\n```java\ninterface AuxiliaryConstants { // Noncompliant, implementation detail of WordPacker\n  int BITS_PER_WORD = 16;\n  int WORD_MASK = (1 << BITS_PER_WORD) - 1;\n  int HI_WORD_BK_MASK = ~(WORD_MASK << BITS_PER_WORD);\n}\n\nclass WordPacker {\n  public static int getHiWord(int value) {\n    return (value >>> AuxiliaryConstants.BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value & AuxiliaryConstants.HI_WORD_BK_MASK) |\n      (wordValue << AuxiliaryConstants.BITS_PER_WORD);\n  }\n}\n```\n```java\nclass WordPacker { // Compliant\n  private static final int BITS_PER_WORD = 16;\n  private static final int WORD_MASK = (1 << BITS_PER_WORD) - 1;\n  private static final int HI_WORD_BK_MASK = ~(WORD_MASK << BITS_PER_WORD);\n\n  public static int getHiWord(int value) {\n      return (value >>> BITS_PER_WORD);\n  }\n\n  public static int setHiWord(int value, int wordValue) {\n    return (value & HI_WORD_BK_MASK) | (wordValue << BITS_PER_WORD);\n  }\n}\n```\nIf this is not the case and several classes are using the constants equally, you should use a final class with a private constructor. Unlike\ninterfaces, they can neither be inherited from nor instantiated.\n```java\npublic interface ColorTheme { // Noncomplient, final class should be used\n  int COLOR_ERROR = 0xff0000;   // red\n  int COLOR_WARNING = 0xffff00; // yellow\n  int COLOR_OK = 0x00cf00;      // green\n}\n```\n```java\npublic final class ColorTheme { // Compliant\n  public static final int COLOR_ERROR = 0xff0000;   // red\n  public static final int COLOR_WARNING = 0xffff00; // yellow\n  public static final int COLOR_OK = 0x00cf00;      // green\n\n  private ColorTheme() {}\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1213": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The members of an interface or class declaration should appear in a pre-defined order\nDescription: Why is this an issue?\nAccording to the Java Code Conventions as defined by Oracle, the members of a class or interface declaration should appear in the following order\nin the source files:\n1. Class variables\n2. Instance variables\n3. Constructors\n4. Methods\nNoncompliant code example\n```java\npublic class Foo{\n   private int field = 0;\n   public boolean isTrue() {...}\n   public Foo() {...}                         // Noncompliant, constructor defined after methods\n   public static final int OPEN = 4;  //Noncompliant, variable defined after constructors and methods\n}\n```\nCompliant solution\n```java\npublic class Foo{\n   public static final int OPEN = 4;\n   private int field = 0;\n   public Foo() {...}\n   public boolean isTrue() {...}\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1210": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"equals(Object obj)\" should be overridden along with the \"compareTo(T obj)\" method\nDescription: Why is this an issue?\nAccording to the Java\nComparable.compareTo(T o)\ndocumentation:\nIt is strongly recommended, but not strictly required that\n(x.compareTo(y)==0) == (x.equals(y))\n.\nGenerally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact.\nThe recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"\nIf this rule is violated, weird and unpredictable failures can occur.\nFor example, in Java 5 the\nPriorityQueue.remove()\nmethod relied on\ncompareTo()\n, but since Java 6 it has relied on\nequals()\n.\nNoncompliant code example\n```java\npublic class Foo implements Comparable<Foo> {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Noncompliant as the equals(Object obj) method is not overridden\n}\n```\nCompliant solution\n```java\npublic class Foo implements Comparable<Foo> {\n  @Override\n  public int compareTo(Foo foo) { /* ... */ }      // Compliant\n\n  @Override\n  public boolean equals(Object obj) { /* ... */ }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-121": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Control structures should use curly braces\nDescription: Control structures are code statements that impact the program\u2019s control flow (e.g., if statements, for loops, etc.)\nWhy is this an issue?\nWhile not technically incorrect, the omission of curly braces can be misleading and may lead to the introduction of errors during maintenance.\nIn the following example, the two calls seem to be attached to the\nif\nstatement, but only the first one is, and\ncheckSomething\nwill always be executed:\n```java\nif (condition)  // Noncompliant\n  executeSomething();\n  checkSomething();\n```\nAdding curly braces improves the code readability and its robustness:\n```java\nif (condition) {\n  executeSomething();\n  checkSomething();\n}\n```\nThe rule raises an issue when a control structure has no curly braces.\nExceptions\nThe rule doesn\u2019t raise an issue when the body of an\nif\nstatement is a single\nreturn\n,\nbreak\n, or\ncontinue\nand is on the same line.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1200": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes should not be coupled to too many other classes\nDescription: Why is this an issue?\nAccording to the Single Responsibility Principle, introduced by Robert C. Martin in his book \"Principles of Object Oriented Design\", a class should\nhave only one responsibility:\nIf a class has more than one responsibility, then the responsibilities become coupled.\nChanges to one responsibility may impair or inhibit the class' ability to meet the others.\nThis kind of coupling leads to fragile designs that break in unexpected ways when changed.\nClasses which rely on many other classes tend to aggregate too many responsibilities and should be split into several smaller ones.\nNested classes dependencies are not counted as dependencies of the outer class.\nNoncompliant code example\nWith a threshold of 5:\n```java\nclass Foo {                        // Noncompliant - Foo depends on too many classes: T1, T2, T3, T4, T5, T6 and T7\n  T1 a1;                           // Foo is coupled to T1\n  T2 a2;                           // Foo is coupled to T2\n  T3 a3;                           // Foo is coupled to T3\n\n  public T4 compute(T5 a, T6 b) {  // Foo is coupled to T4, T5 and T6\n    T7 result = a.getResult(b);    // Foo is coupled to T7\n    return result;\n  }\n\n  public static class Bar {        // Compliant - Bar depends on 2 classes: T8 and T9\n    T8 a8;\n    T9 a9;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-120": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Package names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions improve readability and allow teams to collaborate efficiently. This rule checks that all package names match a provided\nregular expression.\nHow to fix it\nRename packages with the expected naming convention\nCode examples\nNoncompliant code example\nWith the default regular expression\n^[a-z_]+(\\.[a-z_][a-z0-9_]*)*$\n:\n```java\npackage org.exAmple; // Noncompliant\n```\nCompliant solution\n```java\npackage org.example;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1199": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nested code blocks should not be used\nDescription: Why is this an issue?\nNested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.\nAlthough this may appear beneficial, their usage within a function often suggests that the function is overloaded. Thus, it may violate the Single\nResponsibility Principle, and the function needs to be broken down into smaller functions.\nThe presence of nested blocks that don\u2019t affect the control flow might suggest possible mistakes in the code.\nExceptions\nThe usage of a code block after a\ncase\nis allowed.\nHow to fix it\nThe nested code blocks should be extracted into separate methods.\nCode examples\nNoncompliant code example\n```java\nclass Example {\n\n    private final Deque<Integer> stack = new LinkedList<>();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          { // Noncompliant - Extract this nested code block into a method\n            int a = stack.pop();\n            int b = stack.pop();\n            int result = a + b;\n            stack.push(result);\n          }\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n}\n```\nCompliant solution\n```java\nclass Example {\n\n    private final Deque<Integer> stack = new LinkedList<>();\n\n    public void evaluate(int operator) {\n      switch (operator) {\n        case ADD: {\n          /* ... */\n          evaluateAdd();\n          /* ... */\n          break;\n        }\n        /* ... */\n      }\n    }\n\n    private void evaluateAdd() {\n      int a = stack.pop();\n      int b = stack.pop();\n      int result = a + b;\n      stack.push(result);\n    }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1197": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Array designators \"[]\" should be on the type, not the variable\nDescription: Why is this an issue?\nArray designators should always be located on the type for better code readability. Otherwise, developers must look both at the type and the\nvariable name to know whether or not a variable is an array.\nNoncompliant code example\n```java\nint matrix[][];   // Noncompliant\nint[] matrix[];   // Noncompliant\n```\nCompliant solution\n```java\nint[][] matrix;   // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1195": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Array designators \"[]\" should be located after the type in method signatures\nDescription: Why is this an issue?\nPlacing the array designators\n[]\nafter the type helps maintain backward compatibility with older versions of the Java SE platform.\nThis syntax contributes to better readability as it becomes easier to distinguish between array types and non-array types. It helps convey the\nintention of the method to both the developer implementing it and the developer using it.\nNoncompliant code example\n```java\npublic class Cube {\n    private int magicNumbers[] = { 42 };      // Noncompliant\n    public int getVector()[] { /* ... */ }    // Noncompliant\n    public int[] getMatrix()[] { /* ... */ }  // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class Cube {\n    private int[] magicNumbers = { 42 };      // Compliant\n    public int[] getVector() { /* ... */ }    // Compliant\n    public int[][] getMatrix() { /* ... */ }  // Compliant\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1194": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"java.lang.Error\" should not be extended\nDescription: Why is this an issue?\njava.lang.Error\nand its subclasses represent abnormal conditions, such as\nOutOfMemoryError\n, which should only be\nencountered by the Java Virtual Machine.\nNoncompliant code example\n```java\npublic class MyException extends Error { /* ... */ }       // Noncompliant\n```\nCompliant solution\n```java\npublic class MyException extends Exception { /* ... */ }   // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1193": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception types should not be tested using \"instanceof\" in catch blocks\nDescription: Why is this an issue?\nA\ntry-catch\nblock is used to handle exceptions or errors that may occur during the execution of a block of code. It allows you to\ncatch and handle exceptions gracefully, preventing your program from terminating abruptly.\nThe code that may throw an exception is enclosed within the\ntry\nblock, while each\ncatch\nblock specifies the type of\nexception it can handle. The corresponding catch block is executed if the exception matches the type specified in any catch block. It is unnecessary\nto manually check the types using\ninstanceof\nbecause Java automatically matches the exception type to the appropriate catch block based\non the declared exception type in the catch clauses.\nHow to fix it\nReplace\nif\nstatements that check the exception type using\ninstanceof\nwith corresponding\ncatch\nblocks.\nCode examples\nNoncompliant code example\n```java\ntry {\n  /* ... */\n} catch (Exception e) {\n  if(e instanceof IOException) { /* ... */ }         // Noncompliant\n  if(e instanceof NullPointerException{ /* ... */ }  // Noncompliant\n}\n```\nCompliant solution\n```java\ntry {\n  /* ... */\n} catch (IOException e) { /* ... */ }                // Compliant\n} catch (NullPointerException e) { /* ... */ }       // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1192": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: String literals should not be duplicated\nDescription: Why is this an issue?\nDuplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all\noccurrences.\nExceptions\nTo prevent generating some false-positives, literals having less than 5 characters are excluded.\nHow to fix it\nUse constants to replace the duplicated string literals. Constants can be referenced from many places, but only need to be updated in a single\nplace.\nCode examples\nNoncompliant code example\nWith the default threshold of 3:\n```java\npublic void run() {\n  prepare(\"action1\");                              // Noncompliant - \"action1\" is duplicated 3 times\n  execute(\"action1\");\n  release(\"action1\");\n}\n\n@SuppressWarning(\"all\")                            // Compliant - annotations are excluded\nprivate void method1() { /* ... */ }\n@SuppressWarning(\"all\")\nprivate void method2() { /* ... */ }\n\npublic String printInQuotes(String a, String b) {\n  return \"'\" + a + \"'\" + b + \"'\";               // Compliant - literal \"'\" has less than 5 characters and is excluded\n}\n```\nCompliant solution\n```java\nprivate static final String ACTION_1 = \"action1\";  // Compliant\n\npublic void run() {\n  prepare(ACTION_1);                               // Compliant\n  execute(ACTION_1);\n  release(ACTION_1);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1191": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes from \"sun.*\" packages should not be used\nDescription: Why is this an issue?\nThe classes in the\nsun.*\npackages are not part of the official Java API and are not intended for public use. They are internal\nimplementation details specific to the Oracle JDK (Java Development Kit). Therefore, their availability, behavior, or compatibility is not guaranteed\nacross different Java implementations or versions.\nSince these classes are not part of the official Java API, they usually lack proper documentation and support. Finding comprehensive and up-to-date\ninformation about their usage, functionality, and potential limitations can be challenging. This lack of documentation can make it difficult to\nunderstand how to use these classes correctly.\nClasses in the\nsun.*\npackages are often platform-dependent and can vary between different operating systems or Java Virtual Machine\n(JVM) implementations. Relying on these classes may lead to code that works on one platform but fails on others, limiting your code\u2019s portability and\ncross-platform compatibility.\nNoncompliant code example\n```java\nimport sun.misc.BASE64Encoder; // Noncompliant\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1190": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Future keywords should not be used as names\nDescription: Why is this an issue?\nProgramming languages evolve over time, and new versions of Java introduce additional keywords. If future keywords are used in the current code, it\ncan create compatibility issues when transitioning to newer versions of Java. The code may fail to compile or behave unexpectedly due to conflicts\nwith newly introduced keywords.\nThe\n_\nkeyword was deprecated in Java 9 and disallowed since Java 11. Starting from Java 22 the\n_\nwas introduced as\nunnamed variable\n.\nThis rule reports an issue when\n_\nis used in versions prior to Java 22.\nHow to fix it\nRename the\n_\nidentifiers.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass {\n    String _ = \"\";            // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n    String s = \"\";            // Compliant\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-119": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Type parameter names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions make it possible for a team to collaborate efficiently. Following the established convention of single-letter type\nparameter names helps users and maintainers of your code quickly see the difference between a type parameter and a poorly named class.\nThis rule check that all type parameter names match a provided regular expression. The following code snippets use the default regular\nexpression.\nNoncompliant code example\n```java\npublic class MyClass<TYPE> { // Noncompliant\n  <TYPE> void method(TYPE t) { // Noncompliant\n  }\n}\n```\nCompliant solution\n```java\npublic class MyClass<T> {\n  <T> void method(T t) {\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1188": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Anonymous classes should not have too many lines\nDescription: Why is this an issue?\nAnonymous classes are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner\nclasses should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become\nunreadable.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1186": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not be empty\nDescription: Why is this an issue?\nAn empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no\nfunctionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.\nThere are several reasons for a method not to have a body:\n1. It is an unintentional omission, and should be fixed to prevent an unexpected behavior in production.\n2. It is not yet, or never will be, supported. In this case an exception should be thrown.\n3. The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.\nExceptions\nThis does not raise an issue in the following cases:\n1. Methods with a comment to explain why they are empty\n2. Non-public default (no-argument) constructors\n3. Public default (no-argument) constructors when there are other constructors in the class\n4. Empty methods in abstract classes\n5. Methods annotated with@org.aspectj.lang.annotation.Pointcut()\n```java\npublic abstract class Animal {\n  void speak() {  // default implementation ignored\n  }\n}\n```\nHow to fix it\nTo fix this issue, either make the method do something, throw an exception, or add a comment to explain why it is empty.\nCode examples\nNoncompliant code example\n```java\npublic void shouldNotBeEmpty() {  // Noncompliant - method is empty\n}\n\npublic void notImplemented() {  // Noncompliant - method is empty\n}\n\n@Override\npublic void emptyOnPurpose() {  // Noncompliant - method is empty\n}\n```\nCompliant solution\n```java\npublic void doSomething() {\n  doSomething();\n}\n\npublic void notImplemented() {\n  throw new UnsupportedOperationException(\"notImplemented() cannot be performed because ...\");\n}\n\n@Override\npublic void emptyOnPurpose() {\n  // comment explaining why the method is empty\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1185": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Overriding methods should do more than simply call the same method in the super class \nDescription: Why is this an issue?\nOverriding a method just to call the same method from the super class without performing any other actions is useless and misleading. The only time\nthis is justified is in\nfinal\noverriding methods, where the effect is to lock in the parent class behavior. This rule ignores such\noverrides of\nequals\n,\nhashCode\nand\ntoString\n.\nNoncompliant code example\n```java\npublic void doSomething() {\n  super.doSomething();\n}\n\n@Override\npublic boolean isLegal(Action action) {\n  return super.isLegal(action);\n}\n```\nCompliant solution\n```java\n@Override\npublic boolean isLegal(Action action) {         // Compliant - not simply forwarding the call\n  return super.isLegal(new Action(/* ... */));\n}\n\n@Id\n@Override\npublic int getId() {                            // Compliant - there is annotation different from @Override\n  return super.getId();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1182": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Classes that override \"clone\" should be \"Cloneable\" and call \"super.clone()\"\nDescription: Why is this an issue?\nCloneable\nis the marker\nInterface\nthat indicates that\nclone()\nmay be called on an object. Overriding\nclone()\nwithout implementing\nCloneable\ncan be helpful if you want to control how subclasses clone themselves, but otherwise,\nit\u2019s probably a mistake.\nThe usual convention for\nObject.clone()\naccording to Oracle\u2019s Javadoc is:\nx.clone() != x\nx.clone().getClass() == x.getClass()\nx.clone().equals(x)\nObtaining the object that will be returned by calling\nsuper.clone()\nhelps to satisfy those invariants:\nsuper.clone()\nreturns a new object instance\nsuper.clone()\nreturns an object of the same type as the one\nclone()\nwas called on\nObject.clone()\nperforms a shallow copy of the object\u2019s state.\nHow to fix it\nEnsure that the\nclone()\nmethod calls\nsuper.clone()\nand implement\nCloneable\nin the class or remove the clone\nmethod.\nCode examples\nNoncompliant code example\n```java\nclass BaseClass {  // Noncompliant - should implement Cloneable\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Noncompliant - should return the super.clone() instance\n    return new BaseClass();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Throws a ClassCastException because invariant #2 is violated\n  }\n}\n```\nCompliant solution\n```java\nclass BaseClass implements Cloneable {\n  @Override\n  public Object clone() throws CloneNotSupportedException {    // Compliant\n    return super.clone();\n  }\n}\n\nclass DerivedClass extends BaseClass implements Cloneable {\n  /* Does not override clone() */\n\n  public void sayHello() {\n    System.out.println(\"Hello, world!\");\n  }\n}\n\nclass Application {\n  public static void main(String[] args) throws Exception {\n    DerivedClass instance = new DerivedClass();\n    ((DerivedClass) instance.clone()).sayHello();              // Displays \"Hello, world!\" as expected. Invariant #2 is satisfied\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1181": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Throwable and Error should not be caught\nDescription: Why is this an issue?\nThrowable\nis the superclass of all errors and exceptions in Java.\nError\nis the superclass of all errors, which are not\nmeant to be caught by applications.\nCatching either\nThrowable\nor\nError\nwill also catch\nOutOfMemoryError\nand\nInternalError\n, from\nwhich an application should not attempt to recover.\nNoncompliant code example\n```java\ntry { /* ... */ } catch (Throwable t) { /* ... */ }\ntry { /* ... */ } catch (Error e) { /* ... */ }\n```\nCompliant solution\n```java\ntry { /* ... */ } catch (RuntimeException e) { /* ... */ }\ntry { /* ... */ } catch (MyException e) { /* ... */ }\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-118": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Abstract class names should comply with a naming convention\nDescription: Why is this an issue?\nSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\nabstract\nclass names match a provided regular expression. If a non-abstract class match the regular expression, an issue is raised to\nsuggest to either make it abstract or to rename it.\nNoncompliant code example\nWith the default regular expression:\n^Abstract[A-Z][a-zA-Z0-9]*$\n:\n```java\nabstract class MyClass { // Noncompliant\n}\n\nclass AbstractLikeClass { // Noncompliant\n}\n```\nCompliant solution\n```java\nabstract class AbstractClass {\n}\n\nclass LikeClass {\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1176": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Public types, methods and fields (API) should be documented with Javadoc\nDescription: A good API documentation is a key factor in the usability and success of a software API. It ensures that developers can effectively use, maintain,\nand collaborate on the API.\nWhy is this an issue?\nUndocumented APIs pose significant challenges in software development for several reasons:\n1. Lack of Clarity:developers struggling to understand how to use the API correctly. This can lead to misuse and unexpected\n  results.\n2. Increased Development Time:developers spending extra time reading and understanding the source code, which slows down the\n  development process.\n3. Error Prone:developers are more likely to make mistakes that lead to bugs or system crashes when the intent or the error\n  handling of an API is not clear.\n4. Difficult Maintenance and Updates:developers may not understand the existing functionality well enough to add new features\n  without breaking the existing ones.\n5. Poor Collaboration:collaboration, when there is lack of documentation, leads to confusion and inconsistencies.\nIt is recommended to document the API using\nJavaDoc\nto clarify what is the contract of the API. This is especially important for\npublic APIs, as they are used by other developers.\nExceptions\nThe following public methods and constructors are not taken into account by this rule:\n1. Getters and setters.\n2. Methods overriding another method (usually annotated with@Override).\n3. Empty constructors.\n4. Static constants.\nHow to fix it\nOn top of a main description for each member of a public API, the following\nJavadoc\nelements are required to be described:\n1. Parameters, using@param parameterName.\n2. Thrown exceptions, using@throws exceptionName.\n3. Method return values, using@return.\n4. Generic types, using@param <T>.\nFurthermore, the following guidelines should be followed:\n1. At least 1 line of description.\n2. All parameters documented with@param, and names should match.\n3. All checked exceptions should be documented with@throws\n4. @returnpresent and documented when method return type is notvoid.\n5. Placeholders like\"TODO\",\"FIXME\",\"\u2026\u200b\"should be avoided.\nFor the parameters of the rule, the following rules are applied:\n1. ?matches a single character\n2. *matches zero or more characters\n3. **matches zero or more packages\nExamples:\n1. java.internal.InternalClasswill match onlyInternalClassclass.\n2. java.internal.*will match any member ofjava.internalpackage.\n3. java.internal.**same as above, but including sub-packages.\nCode examples\nNoncompliant code example\n```java\n/**\n  * This is a Javadoc comment\n  */\npublic class MyClass<T> implements Runnable {   // Noncompliant - missing '@param <T>'\n\n  public static final int DEFAULT_STATUS = 0;   // Compliant - static constant\n  private int status;                           // Compliant - not public\n\n  public String message;                        // Noncompliant\n\n  public MyClass() {                            // Noncompliant - missing documentation\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {           // Compliant - setter\n    this.status = status;\n  }\n\n  @Override\n  public void run() {                           // Compliant - has @Override annotation\n  }\n\n  protected void doSomething() {                // Compliant - not public\n  }\n\n  public void doSomething2(int value) {         // Noncompliant\n  }\n\n  public int doSomething3(int value) {          // Noncompliant\n    return value;\n  }\n}\n```\nCompliant solution\n```java\n/**\n  * This is a Javadoc comment\n  * @param <T> the parameter of the class\n  */\npublic class MyClass<T> implements Runnable {\n\n  public static final int DEFAULT_STATUS = 0;\n  private int status;\n\n  /**\n    * This is a Javadoc comment\n    */\n  public String message;\n\n  /**\n   * Class comment...\n   */\n  public MyClass() {\n    this.status = DEFAULT_STATUS;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n  @Override\n  public void run() {\n  }\n\n  protected void doSomething() {\n  }\n\n  /**\n    * Will do something.\n    * @param value the value to be used\n    */\n  public void doSomething(int value) {\n  }\n\n  /**\n    *  {@inheritDoc}\n    */\n  public int doSomething(int value) {\n    return value;\n  }\n}\n```\nDocumentation\n1. Oracle -JavaDoc\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1174": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Object.finalize()\" should remain protected (versus public) when overriding\nDescription: Why is this an issue?\nThe contract of the\nObject.finalize()\nmethod is clear: only the Garbage Collector is supposed to call this method.\nMaking this method public is misleading, because it implies that any caller can use it.\nNoncompliant code example\n```java\npublic class MyClass {\n\n  @Override\n  public void finalize() {    // Noncompliant\n    /* ... */\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1172": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused method parameters should be removed\nDescription: Why is this an issue?\nA typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function\u2019s\nbody. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to\nsuch parameters, the function\u2019s behavior will be the same, but the programmer\u2019s intention won\u2019t be clearly expressed anymore. Therefore, removing\nfunction parameters that are not being utilized is considered best practice.\nExceptions\nThe rule will not raise issues for unused parameters:\n1. that are annotated with@javax.enterprise.event.Observes\n2. in overrides and implementation methods\n3. in interfacedefaultmethods\n4. in non-private methods that onlythrowor that have empty bodies\n5. in annotated methods, unless the annotation is@SuppressWarning(\"unchecked\")or@SuppressWarning(\"rawtypes\"), in\n  which case the annotation will be ignored\n6. in overridable methods (non-final, or not member of a final class, non-static, non-private), if the parameter is documented with a proper\n  javadoc.\nHow to fix it\nHaving unused function parameters in your code can lead to confusion and misunderstanding of a developer\u2019s intention. They reduce code readability\nand introduce the potential for errors. To avoid these problems, developers should remove unused parameters from function declarations.\nCode examples\nNoncompliant code example\n```java\nvoid doSomething(int a, int b) { // Noncompliant, \"b\" is unused\n  compute(a);\n}\n```\nCompliant solution\n```java\nvoid doSomething(int a) {\n  compute(a);\n}\n```\nExamples of exceptions:\n```java\n@Override\nvoid doSomething(int a, int b) {     // no issue reported on b\n  compute(a);\n}\n\npublic void foo(String s) {\n  // designed to be extended but noop in standard case\n}\n\nprotected void bar(String s) {\n  //open-closed principle\n}\n\npublic void qix(String s) {\n  throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n}\n\n/**\n * @param s This string may be used for further computation in overriding classes\n */\nprotected void foobar(int a, String s) { // no issue, method is overridable and unused parameter has proper javadoc\n  compute(a);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1171": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Only static class initializers should be used\nDescription: Why is this an issue?\nNon-static initializers, also known as instance initializers, are blocks of code within a class that are executed when an instance of the class is\ncreated. They are executed when an object of the class is created just before the constructor is called. Non-static initializers are useful when you\nwant to perform some common initialization logic for all objects of a class. They allow you to initialize instance variables in a concise and\ncentralized manner, without having to repeat the same initialization code in each constructor.\nWhile non-static initializers may have some limited use cases, they are rarely used and can be confusing for most developers because they only run\nwhen new class instances are created.\nHow to fix it\nNon-static initializers should be refactored into standard constructors or field initializers when possible.\nIn most cases, the use of constructors, overloaded constructors, or factory methods is preferable for initializing instance variables. These\napproaches provide more explicit and controlled initialization, separate concerns, allow for better error handling, and make the code easier to\nunderstand and maintain.\nCode examples\nNoncompliant code example\n```java\nclass MyClass {\n  private static final Map<String, String> MY_MAP = new HashMap<String, String>() {\n    {\n      put(\"a\", \"b\");\n    }\n  }; // Noncompliant - HashMap should be extended only to add behavior, not for initialization\n}\n```\nCompliant solution\nUsing static initialization block:\n```java\nclass MyClass {\n  private static final Map<String, String> MY_MAP = new HashMap<>();\n\n  static {\n    MY_MAP.put(\"a\", \"b\");  // Compliant\n  }\n}\n```\nor using constructor:\n```java\nclass MyClass {\n  private static final Map<String, String> MY_MAP = new HashMap<>();\n\n  public MyClass() {\n    MY_MAP.put(\"a\", \"b\");  // Compliant\n  }\n}\n```\nor using Java 9\nMap.of\n:\n```java\nclass MyClass {\n  private static final Map<String, String> MY_MAP = java.util.Map.of(\"a\", \"b\");   // Compliant\n}\n```\nor using Guava\nImmutableMap.of\n:\n```java\nclass MyClass {\n  private static final Map<String, String> MY_MAP = com.google.common.collect.ImmutableMap.of(\"a\", \"b\");   // Compliant\n}\n```\nArticles & blog posts\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1170": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Public constants and fields initialized at declaration should be \"static final\" rather than merely \"final\"\nDescription: Why is this an issue?\nMaking a\npublic\nconstant just\nfinal\nas opposed to\nstatic final\nleads to duplicating its value for every\ninstance of the class, uselessly increasing the amount of memory required to execute the application.\nFurther, when a non-\npublic\n,\nfinal\nfield isn\u2019t also\nstatic\n, it implies that different instances can have\ndifferent values. However, initializing a non-\nstatic final\nfield in its declaration forces every instance to have the same value. So such\nfields should either be made\nstatic\nor initialized in the constructor.\nNoncompliant code example\n```java\npublic class Myclass {\n  public final int THRESHOLD = 3;\n}\n```\nCompliant solution\n```java\npublic class Myclass {\n  public static final int THRESHOLD = 3;    // Compliant\n}\n```\nExceptions\nNo issues are reported on final fields of inner classes whose type is not a primitive or a String. Indeed according to the Java specification:\nAn inner class is a nested class that is not explicitly or implicitly declared static. Inner classes may not declare static initializers (\u00a78.7)\n  or member interfaces. Inner classes may not declare static members, unless they are compile-time constant fields (\u00a715.28).\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-117": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local variable and method parameter names should comply with a naming convention\nDescription: Local variables and method parameters should be named consistently to communicate intent and improve maintainability. Rename your local variable or\nmethod parameter to follow your project\u2019s naming convention to address this issue.\nWhy is this an issue?\nA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\nLocal\nvariables and method parameters hold the meaning of the written code. Their names should be meaningful and follow a consistent and easily recognizable\npattern.\nAdhering to a consistent naming convention helps to make the code more readable and understandable, which makes it easier to maintain and\ndebug. It also ensures consistency in the code, especially when multiple developers are working on the same project.\nThis rule checks that local variable and method parameter names match a provided regular expression.\nWhat is the potential impact?\nInconsistent naming of local variables and method parameters can lead to several issues in your code:\n1. Reduced Readability: Inconsistent local variable and method parameter names make the code harder to read and understand;\n  consequently, it is more difficult to identify the purpose of each variable, spot errors, or comprehend the logic.\n2. Difficulty in Identifying Variables: The local variables and method parameters that don\u2019t adhere to a standard naming\n  convention are challenging to identify; thus, the coding process slows down, especially when dealing with a large codebase.\n3. Increased Risk of Errors: Inconsistent or unclear local variable and method parameter names lead to misunderstandings about\n  what the variable represents. This ambiguity leads to incorrect assumptions and, consequently, bugs in the code.\n4. Collaboration Difficulties: In a team setting, inconsistent naming conventions lead to confusion and miscommunication among\n  team members.\n5. Difficulty in Code Maintenance: Inconsistent naming leads to an inconsistent codebase. The code is difficult to understand,\n  and making changes feels like refactoring constantly, as you face different naming methods. Ultimately, it makes the codebase harder to maintain.\nIn summary, not adhering to a naming convention for local variables and method parameters can lead to confusion, errors, and inefficiencies, making\nthe code harder to read, understand, and maintain.\nExceptions\nLoop counters are ignored by this rule.\n```java\nfor (int i_1 = 0; i_1 < limit; i_1++) {  // Compliant\n  // ...\n}\n```\nas well as one-character\ncatch\nvariables:\n```java\ntry {\n//...\n} catch (Exception e) { // Compliant\n}\n```\nHow to fix it\nFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name to match the convention, as\nwell as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages at once.\nCode examples\nNoncompliant code example\nWith the default regular expression\n^[a-z][a-zA-Z0-9]*$\n:\n```java\npublic class MyClass {\n    public void doSomething(int myParam) {\n      int LOCAL;    // Noncompliant\n      // ...\n    }\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n    public void doSomething(int my_param) {\n      int local;\n      // ...\n    }\n}\n```\nDocumentation\n1. Oracle -Java SE Naming Conventions\n2. Geeksforgeeks -Java Naming Conventions\n3. Wikipedia -Naming Convention (programming)\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1168": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Empty arrays and collections should be returned instead of null\nDescription: Why is this an issue?\nReturning\nnull\ninstead of an actual array, collection or map forces callers of the method to explicitly test for nullity, making them\nmore complex and less readable.\nMoreover, in many cases,\nnull\nis used as a synonym for empty.\nNoncompliant code example\n```java\npublic static List<Result> getAllResults() {\n  return null;                             // Noncompliant\n}\n\npublic static Result[] getResults() {\n  return null;                             // Noncompliant\n}\n\npublic static Map<String, Object> getValues() {\n  return null;                             // Noncompliant\n}\n\npublic static void main(String[] args) {\n  Result[] results = getResults();\n  if (results != null) {                   // Nullity test required to prevent NPE\n    for (Result result: results) {\n      /* ... */\n    }\n  }\n\n  List<Result> allResults = getAllResults();\n  if (allResults != null) {                // Nullity test required to prevent NPE\n    for (Result result: allResults) {\n      /* ... */\n    }\n  }\n\n  Map<String, Object> values = getValues();\n  if (values != null) {                   // Nullity test required to prevent NPE\n    values.forEach((k, v) -> doSomething(k, v));\n  }\n}\n```\nCompliant solution\n```java\npublic static List<Result> getAllResults() {\n  return Collections.emptyList();          // Compliant\n}\n\npublic static Result[] getResults() {\n  return new Result[0];                    // Compliant\n}\n\npublic static Map<String, Object> getValues() {\n  return Collections.emptyMap();           // Compliant\n}\n\npublic static void main(String[] args) {\n  for (Result result: getAllResults()) {\n    /* ... */\n  }\n\n  for (Result result: getResults()) {\n    /* ... */\n  }\n\n  getValues().forEach((k, v) -> doSomething(k, v));\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1166": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception handlers should preserve the original exceptions\nDescription: Why is this an issue?\nWhen handling a caught exception, the original exception\u2019s message and stack trace should be logged or passed forward.\nNoncompliant code example\n```java\ntry {\n  /* ... */\n} catch (Exception e) {   // Noncompliant - exception is lost\n  LOGGER.info(\"context\");\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // Noncompliant - exception is lost (only message is preserved)\n  LOGGER.info(e.getMessage());\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {  // Noncompliant - original exception is lost\n  throw new RuntimeException(\"context\");\n}\n```\nCompliant solution\n```java\ntry {\n  /* ... */\n} catch (Exception e) {\n  LOGGER.info(e);  // exception is logged\n}\n\ntry {\n  /* ... */\n} catch (Exception e) {\n  throw new RuntimeException(e);   // exception stack trace is propagated\n}\n\ntry {\n  /* ... */\n} catch (RuntimeException e) {\n  doSomething();\n  throw e;  // original exception passed forward\n} catch (Exception e) {\n  throw new RuntimeException(e);  // Conversion into unchecked exception is also allowed\n}\n```\nExceptions\nInterruptedException\n,\nNumberFormatException\n,\nDateTimeParseException\n,\nParseException\nand\nMalformedURLException\nexceptions are arguably used to indicate nonexceptional outcomes. Similarly, handling\nNoSuchMethodException\nis often required when dealing with the Java reflection API.\nBecause they are part of Java, developers have no choice but to deal with them. This rule does not verify that those particular exceptions are\ncorrectly handled.\n```java\nint myInteger;\ntry {\n  myInteger = Integer.parseInt(myString);\n} catch (NumberFormatException e) {\n  // It is perfectly acceptable to not handle \"e\" here\n  myInteger = 0;\n}\n```\nFurthermore, no issue will be raised if the exception message is logged with additional information, as it shows that the developer added some\ncontext to the error message.\n```java\ntry {\n  /* ... */\n} catch (Exception e) {\n  String message = \"Exception raised while authenticating user: \" + e.getMessage();\n  LOGGER.warn(message); // Compliant - exception message logged with some contextual information\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1165": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exception classes should have final fields\nDescription: Why is this an issue?\nWhen a class has all\nfinal\nfields, the compiler ensures that the object\u2019s state remains constant. It also enforces a clear design\nintent of immutability, making the class easier to reason about and use correctly.\nExceptions are meant to represent the application\u2019s state at the point at which an error occurred. Making all fields in an\nException\nclass\nfinal\nensures that these class fields do not change after initialization.\nNoncompliant code example\n```java\npublic class MyException extends Exception {\n\n  private int status;                        // Noncompliant\n\n  public MyException(String message) {\n    super(message);\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n  public void setStatus(int status) {\n    this.status = status;\n  }\n\n}\n```\nCompliant solution\n```java\npublic class MyException extends Exception {\n\n  private final int status;                  // Compliant\n\n  public MyException(String message, int status) {\n    super(message);\n    this.status = status;\n  }\n\n  public int getStatus() {\n    return status;\n  }\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1163": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exceptions should not be thrown in finally blocks\nDescription: Why is this an issue?\nIf an exception is already being thrown within the\ntry\nblock or caught in a\ncatch\nblock, throwing another exception in\nthe\nfinally\nblock will override the original exception. This means that the original exception\u2019s message and stack trace will be lost,\npotentially making it challenging to diagnose and troubleshoot the root cause of the problem.\n```java\ntry {\n  /* some work which end up throwing an exception */\n  throw new IllegalArgumentException();\n} finally {\n  /* clean up */\n  throw new RuntimeException();       // Noncompliant; masks the IllegalArgumentException\n}\n```\n```java\ntry {\n  /* some work which end up throwing an exception */\n  throw new IllegalArgumentException();\n} finally {\n  /* clean up */\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1162": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Checked exceptions should not be thrown\nDescription: Why is this an issue?\nThe purpose of checked exceptions is to ensure that errors will be dealt with, either by propagating them or by handling them, but some believe\nthat checked exceptions negatively impact the readability of source code, by spreading this error handling/propagation logic everywhere.\nThis rule verifies that no method throws a new checked exception.\nNoncompliant code example\n```java\npublic void myMethod1() throws CheckedException {\n  ...\n  throw new CheckedException(message);   // Noncompliant\n  ...\n  throw new IllegalArgumentException(message); // Compliant; IllegalArgumentException is unchecked\n}\n\npublic void myMethod2() throws CheckedException {  // Compliant; propagation allowed\n  myMethod1();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1161": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"@Override\" should be used on overriding and implementing methods\nDescription: Why is this an issue?\nWhile not mandatory, using the\n@Override\nannotation on compliant methods improves readability by making it explicit that methods are\noverridden.\nA compliant method either overrides a parent method or implements an interface or abstract method.\nNoncompliant code example\n```java\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  public boolean doSomething(){/*...*/}  // Noncompliant\n}\n```\nCompliant solution\n```java\nclass ParentClass {\n  public boolean doSomething(){/*...*/}\n}\nclass FirstChildClass extends ParentClass {\n  @Override\n  public boolean doSomething(){/*...*/}  // Compliant\n}\n```\nExceptions\nThis rule does not raise issues when overriding methods from\nObject\n(eg:\nequals()\n,\nhashCode()\n,\ntoString()\n, \u2026\u200b).\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1160": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Public methods should throw at most one checked exception\nDescription: Why is this an issue?\nUsing checked exceptions forces method callers to deal with errors, either by propagating them or by handling them. Throwing exceptions makes them\nfully part of the API of the method.\nBut to keep the complexity for callers reasonable, methods should not throw more than one kind of checked exception.\nNoncompliant code example\n```java\npublic void delete() throws IOException, SQLException {      // Noncompliant\n  /* ... */\n}\n```\nCompliant solution\n```java\npublic void delete() throws SomeApplicationLevelException {\n  /* ... */\n}\n```\nExceptions\nOverriding methods are not checked by this rule and are allowed to throw several checked exceptions.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-116": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Field names should comply with a naming convention\nDescription: Why is this an issue?\nA naming convention in software development is a set of guidelines for naming code elements like variables, functions, and classes.\nThe goal of a naming convention is to make the code more readable and understandable, which makes it easier to maintain and debug. It also ensures\nconsistency in the code, especially when multiple developers are working on the same project.\nThis rule checks that field names match a provided regular expression.\nUsing the regular expression\n^[a-z][a-zA-Z0-9]*$\n, the noncompliant code below:\n```java\nclass MyClass {\n   private int my_field;\n}\n```\nShould be replaced with:\n```java\nclass MyClass {\n   private int myField;\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1158": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Primitive wrappers should not be instantiated only for \"toString\" or \"compareTo\" calls\nDescription: Why is this an issue?\nCreating temporary primitive wrapper objects only for\nString\nconversion or the use of the\ncompareTo()\nmethod is\ninefficient.\nInstead, the static\ntoString()\nor\ncompare()\nmethod of the primitive wrapper class should be used.\nNoncompliant code example\n```java\nprivate int isZero(int value){\n    return Integer.valueOf(value).compareTo(0); // Noncompliant\n}\nprivate String convert(int value){\n    return Integer.valueOf(value).toString(); // Noncompliant\n}\n```\nCompliant solution\n```java\nprivate int isZero(int value){\n    return Integer.compare(value, 0); // Compliant\n}\nprivate String convert(int value){\n    return Integer.toString(value); // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1157": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Case insensitive string comparisons should be made without intermediate upper or lower casing\nDescription: Why is this an issue?\nUsing\ntoLowerCase()\nor\ntoUpperCase()\nto make case insensitive comparisons is inefficient because it requires the creation\nof temporary, intermediate\nString\nobjects.\nNoncompliant code example\n```java\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.toUpperCase().equals(bar);               // Noncompliant\n    boolean result2 = foo.equals(bar.toUpperCase());               // Noncompliant\n    boolean result3 = foo.toLowerCase().equals(bar.toLowerCase()); // Noncompliant\n}\n```\nCompliant solution\n```java\nprivate void compareStrings(String foo, String bar){\n    boolean result1 = foo.equalsIgnoreCase(bar);                    // Compliant\n}\n```\nExceptions\nNo issue will be raised when a locale is specified because the result could be different from\nequalsIgnoreCase()\n. (e.g.: using the\nTurkish locale)\n```java\nprivate void compareStrings(String foo, String bar, java.util.Locale locale){\n    boolean result1 = foo.toUpperCase(locale).equals(bar);         // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1155": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Collection.isEmpty()\" should be used to test for emptiness\nDescription: Why is this an issue?\nWhen you call\nisEmpty()\n, it clearly communicates the code\u2019s intention, which is to check if the collection is empty. Using\nsize() == 0\nfor this purpose is less direct and makes the code slightly more complex.\nMoreover, depending on the implementation, the\nsize()\nmethod can have a time complexity of\nO(n)\nwhere\nn\nis\nthe number of elements in the collection. On the other hand,\nisEmpty()\nsimply checks if there is at least one element in the collection,\nwhich is a constant time operation,\nO(1)\n.\n```java\npublic class MyClass {\n  public void doSomething(Collection<String> myCollection) {\n    if (myCollection.size() == 0) { // Noncompliant\n      doSomethingElse();\n    }\n  }\n}\n```\nPrefer using\nisEmpty()\nto test for emptiness over\nsize()\n.\n```java\npublic class MyClass {\n  public void doSomething(Collection<String> myCollection) {\n    if (myCollection.isEmpty()) {\n      doSomethingElse();\n    }\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1153": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"String.valueOf()\" should not be appended to a \"String\"\nDescription: Why is this an issue?\nAppending\nString.valueOf()\nto a\nString\ndecreases the code readability.\nThe argument passed to\nString.valueOf()\nshould be directly appended instead.\nNoncompliant code example\n```java\nString message = \"Output is \" + String.valueOf(12);\n```\nCompliant solution\n```java\nString message = \"Output is \" + 12;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1151": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"switch case\" clauses should not have too many lines of code\nDescription: Why is this an issue?\nThe\nswitch\nstatement should be used only to clearly define some new branches in the control flow. As soon as a\ncase\nclause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the\ncase\nclause should be extracted into a dedicated method.\nNoncompliant code example\nWith the default threshold of 5:\n```java\nswitch (myVariable) {\n  case 0: // Noncompliant: 6 lines till next case\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n    break;\n  case 1:\n  ...\n}\n```\nCompliant solution\n```java\nswitch (myVariable) {\n  case 0:\n    doSomething()\n    break;\n  case 1:\n  ...\n}\n...\nprivate void doSomething(){\n    methodCall1(\"\");\n    methodCall2(\"\");\n    methodCall3(\"\");\n    methodCall4(\"\");\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1150": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: \"Enumeration\" should not be implemented\nDescription: Why is this an issue?\nAs documented in\nEnumeration\n's Javadoc, you should favor the\nIterator\ninterface over\nEnumeration\n.\nIterator\noffers a similar contract to\nEnumeration\nwith the addition of a method for removal and shorter method names.\nNoncompliant code example\n```java\npublic class MyClass implements Enumeration {  // Noncompliant\n  /* ... */\n}\n```\nCompliant solution\n```java\npublic class MyClass implements Iterator {     // Compliant\n  /* ... */\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-115": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Constant names should comply with a naming convention\nDescription: Constants should be named consistently to communicate intent and improve maintainability. Rename your constants to follow your project\u2019s naming\nconvention to address this issue.\nWhy is this an issue?\nConstants are variables whose value does not change during the runtime of a program after initialization. Oftentimes, constants are used in\nmultiple locations across different subroutines.\nIt is important that the names of constants follow a consistent and easily recognizable pattern. This way, readers immediately understand that the\nreferenced value does not change, which simplifies debugging.\nOr, in the case of primitive constants, that accessing the constant is thread-safe.\nThis rule checks that all constant names match a given regular expression.\nWhat is the potential impact?\nIgnoring the naming convention for constants makes the code less readable since constants and variables are harder to tell apart. Code that is hard\nto understand is also difficult to maintain between different team members.\nHow to fix it\nFirst, familiarize yourself with the particular naming convention of the project in question. Then, update the name of the constant to match the\nconvention, as well as all usages of the name. For many IDEs, you can use built-in renaming and refactoring features to update all usages of a\nconstant at once.\nCode examples\nNoncompliant code example\nThe following example assumes that constant names should match the default regular expression\n^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$\n:\n```java\npublic class MyClass {\n  public static final float pi = 3.14159f; // Noncompliant: Constant is not capitalized\n\n  void myMethod() {\n    System.out.println(pi);\n  }\n}\n\npublic enum MyEnum {\n  optionOne, // Noncompliant\n  optionTwo; // Noncompliant\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n  public static final float PI = 3.14159f;\n\n  void myMethod() {\n    System.out.println(PI);\n  }\n}\n\npublic enum MyEnum {\n  OPTION_ONE,\n  OPTION_TWO;\n}\n```\nExceptions\nThe rule applies to fields of primitive types (for example,\nfloat\n), boxed primitives (\nFloat\n), and Strings. We do not\napply it to other types, which can be mutated, or have methods with side effects.\n```java\npublic static final Logger log = getLogger(MyClass.class);\npublic static final List<Integer> myList = new ArrayList<>();\n\n// call with side-effects\nlog.info(\"message\")\n\n// mutating an object\nmyList.add(28);\n```\nExternal coding guidelines\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1149": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Synchronized classes \"Vector\", \"Hashtable\", \"Stack\" and \"StringBuffer\" should not be used\nDescription: Why is this an issue?\nEarly classes of the Java API, such as\nVector\n,\nHashtable\nand\nStringBuffer\n, were synchronized to make them\nthread-safe. However, synchronization has a significant negative impact on performance, even when using these collections from a single thread.\nIt is often best to use their non-synchronized counterparts:\n1. ArrayListorLinkedListinstead ofVector\n2. Dequeinstead ofStack\n3. HashMapinstead ofHashtable\n4. StringBuilderinstead ofStringBuffer\nEven when used in synchronized contexts, you should think twice before using their synchronized counterparts, since their usage can be costly. If\nyou are confident the usage is legitimate, you can safely ignore this warning.\nNoncompliant code example\n```java\nVector<Cat> cats = new Vector<>();\n```\nCompliant solution\n```java\nArrayList<Cat> cats = new ArrayList<>();\n```\nExceptions\nUsage of these synchronized classes is ignored in the signatures of overriding methods.\n```java\n@Override\npublic Vector getCats() {...} // Compliant\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1147": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exit methods should not be called\nDescription: Why is this an issue?\nCalling\nSystem.exit(int status)\nor\nRutime.getRuntime().exit(int status)\ncalls the shutdown hooks and shuts downs the\nentire Java virtual machine. Calling\nRuntime.getRuntime().halt(int)\ndoes an immediate shutdown, without calling the shutdown hooks, and\nskipping finalization.\nEach of these methods should be used with extreme care, and only when the intent is to stop the whole Java process. For instance, none of them\nshould be called from applications running in a J2EE container.\nNoncompliant code example\n```java\nSystem.exit(0);\nRuntime.getRuntime().exit(0);\nRuntime.getRuntime().halt(0);\n```\nExceptions\nThese methods are ignored inside\nmain\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1144": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused \"private\" methods should be removed\nDescription: This rule raises an issue when a private method is never referenced in the code.\nWhy is this an issue?\nA method that is never called is dead code, and should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it\neasier to understand the program and preventing bugs from being introduced.\nThis rule detects methods that are never referenced from inside a translation unit, and cannot be referenced from the outside.\nCode examples\nNoncompliant code example\n```java\npublic class Foo implements Serializable\n{\n  public static void doSomething() {\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void unusedPrivateMethod() {...}\n  private void writeObject(ObjectOutputStream s) {...}  //Compliant, relates to the java serialization mechanism\n  private void readObject(ObjectInputStream in) {...}  //Compliant, relates to the java serialization mechanism\n}\n```\nCompliant solution\n```java\npublic class Foo implements Serializable\n{\n  public static void doSomething(){\n    Foo foo = new Foo();\n    ...\n  }\n\n  private void writeObject(ObjectOutputStream s) {...}  //Compliant, relates to the java serialization mechanism\n  private void readObject(ObjectInputStream in) {...}  //Compliant, relates to the java serialization mechanism\n}\n```\nExceptions\nThis rule doesn\u2019t raise issues for:\n1. annotated methods\n2. methods with parameters that are annotated with@javax.enterprise.event.Observes\nThe rule does not take reflection into account, which means that issues will be raised on\nprivate\nmethods that are only accessed using\nthe reflection API.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1142": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not have too many return statements\nDescription: Why is this an issue?\nHaving too many return statements in a method increases the method\u2019s essential complexity because the flow of execution is broken each time a\nreturn statement is encountered. This makes it harder to read and understand the logic of the method.\nNoncompliant code example\nWith the default threshold of 3:\n```java\npublic boolean myMethod() { // Noncompliant; there are 4 return statements\n  if (condition1) {\n    return true;\n  } else {\n    if (condition2) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1141": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Try-catch blocks should not be nested\nDescription: Why is this an issue?\nNesting\ntry\n/\ncatch\nblocks severely impacts the readability of source code because it makes it too difficult to understand\nwhich block will catch which exception.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-114": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Interface names should comply with a naming convention\nDescription: Why is this an issue?\nSharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule allows to check that all\ninterface names match a provided regular expression.\nNoncompliant code example\nWith the default regular expression\n^[A-Z][a-zA-Z0-9]*$\n:\n```java\npublic interface myInterface {...} // Noncompliant\n```\nCompliant solution\n```java\npublic interface MyInterface {...}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1135": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"TODO\" tags\nDescription: Why is this an issue?\nDevelopers often use\nTODO\ntags to mark areas in the code where additional work or improvements are needed but are not implemented\nimmediately. However, these\nTODO\ntags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to\nidentify and address unattended\nTODO\ntags to ensure a clean and maintainable codebase. This description explores why this is a problem\nand how it can be fixed to improve the overall code quality.\nWhat is the potential impact?\nUnattended\nTODO\ntags in code can have significant implications for the development process and the overall codebase.\nIncomplete Functionality: When developers leave\nTODO\ntags without implementing the corresponding code, it results in incomplete\nfunctionality within the software. This can lead to unexpected behavior or missing features, adversely affecting the end-user experience.\nMissed Bug Fixes: If developers do not promptly address\nTODO\ntags, they might overlook critical bug fixes and security updates.\nDelayed bug fixes can result in more severe issues and increase the effort required to resolve them later.\nImpact on Collaboration: In team-based development environments, unattended\nTODO\ntags can hinder collaboration. Other team members\nmight not be aware of the intended changes, leading to conflicts or redundant efforts in the codebase.\nCodebase Bloat: The accumulation of unattended\nTODO\ntags over time can clutter the codebase and make it difficult to distinguish\nbetween work in progress and completed code. This bloat can make it challenging to maintain an organized and efficient codebase.\nAddressing this code smell is essential to ensure a maintainable, readable, reliable codebase and promote effective collaboration among\ndevelopers.\nNoncompliant code example\n```java\nvoid doSomething() {\n  // TODO\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1134": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Track uses of \"FIXME\" tags\nDescription: Why is this an issue?\nFIXME\ntags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.\nSometimes the developer will not have the time or will simply forget to get back to that tag.\nThis rule is meant to track those tags and to ensure that they do not go unnoticed.\n```java\nint divide(int numerator, int denominator) {\n  return numerator / denominator;              // FIXME denominator value might be  0\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1133": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Deprecated code should be removed\nDescription: Why is this an issue?\nThis rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.\nNoncompliant code example\n```java\nclass Foo {\n  /**\n   * @deprecated\n   */\n  public void foo() {    // Noncompliant\n  }\n\n  @Deprecated            // Noncompliant\n  public void bar() {\n  }\n\n  public void baz() {    // Compliant\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1132": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Strings literals should be placed on the left side when checking for equality\nDescription: Why is this an issue?\nIt is preferable to place string literals on the left-hand side of an\nequals()\nor\nequalsIgnoreCase()\nmethod call.\nThis prevents null pointer exceptions from being raised, as a string literal can never be null by definition.\nNoncompliant code example\n```java\nString myString = null;\n\nSystem.out.println(\"Equal? \" + myString.equals(\"foo\"));                        // Noncompliant; will raise a NPE\nSystem.out.println(\"Equal? \" + (myString != null && myString.equals(\"foo\")));  // Noncompliant; null check could be removed\n```\nCompliant solution\n```java\nSystem.out.println(\"Equal?\" + \"foo\".equals(myString));                         // properly deals with the null case\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1130": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Exceptions in \"throws\" clauses should not be superfluous\nDescription: Why is this an issue?\nSuperfluous exceptions within\nthrows\nclauses have negative effects on the readability and maintainability of the code. An exception in\na\nthrows\nclause is superfluous if it is:\n1. listed multiple times\n2. a subclass of another listed exception\n3. not actually thrown by any execution path of the method\nNoncompliant code example\n```java\nvoid foo() throws MyException, MyException {}  // Noncompliant; should be listed once\nvoid bar() throws Throwable, Exception {}  // Noncompliant; Exception is a subclass of Throwable\nvoid boo() throws IOException { // Noncompliant; IOException cannot be thrown\n  System.out.println(\"Hi!\");\n}\n```\nCompliant solution\n```java\nvoid foo() throws MyException {}\nvoid bar() throws Throwable {}\nvoid boo() {\n  System.out.println(\"Hi!\");\n}\n```\nExceptions\nThe rule will not raise any issue for exceptions that cannot be thrown from the method body:\n1. in interfacedefaultmethods\n2. in overriding and implementating methods\n3. in non-private methods that onlythrow, have empty bodies, or a single return statement.\n4. in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper\n  JavaDoc\n```java\ninterface MyInterface {\n  default void defaultMethod() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n  void doSomething() throws IOException;\n}\n\nclass A implements MyInterface {\n  @Override\n  void doSomething() throws IOException {\n    System.out.println(\"Hi!\");\n  }\n\n  public void emptyBody() throws IOException {}\n\n  protected void singleThrowStatement() throws IOException {\n    throw new UnsupportedOperationException(\"This method should be implemented in subclasses\");\n  }\n\n  Object singleReturnStatement() throws IOException {\n    return null;\n  }\n\n  /**\n   * @throws IOException Overriding classes may throw this exception if they print values into a file\n   */\n  protected void overridable() throws IOException { // no issue, method is overridable and the exception has proper javadoc\n    System.out.println(\"foo\");\n  }\n}\n```\nAlso, the rule will not raise issues on\nRuntimeException\n, or one of its sub-classes, because documenting runtime exceptions which\ncould be thrown can ultimately help users of the method understand its behavior.\n```java\nclass B {\n  int possibleDivisionByZero(int a, int b) throws ArithmeticException {\n      return a / b;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-113": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should end with a newline\nDescription: Why is this an issue?\nSome tools work better when files end with a newline.\nThis rule simply generates an issue if it is missing.\nFor example, a Git diff looks like this if the empty line is missing at the end of the file:\n```java\n+class Test {\n+}\n\\ No newline at end of file\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1128": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unnecessary imports should be removed\nDescription: Why is this an issue?\nUnnecessary imports refer to importing types that are not used or referenced anywhere in the code.\nAlthough they don\u2019t affect the runtime behavior of the application after compilation, removing them will:\n1. Improve the readability and maintainability of the code.\n2. Help avoid potential naming conflicts.\n3. Improve the build time, as the compiler has fewer lines to read and fewer types to resolve.\n4. Reduce the number of items the code editor will show for auto-completion, thereby showing fewer irrelevant suggestions.\nExceptions\nImports for types mentioned in Javadocs are ignored.\nHow to fix it\nWhile it\u2019s not difficult to remove these unneeded lines manually, modern code editors support the removal of every unnecessary import with a single\nclick from every file of the project.\nCode examples\nNoncompliant code example\n```java\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\nimport java.nio.file.*;     // Noncompliant - package is imported twice\nimport java.lang.Runnable;  // Noncompliant - java.lang is imported by default\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n```\nCompliant solution\n```java\npackage myapp.helpers;\n\nimport java.io.IOException;\nimport java.nio.file.*;\n\npublic class FileHelper {\n    public static String readFirstLine(String filePath) throws IOException {\n        return Files.readAllLines(Paths.get(filePath)).get(0);\n    }\n}\n```\nDocumentation\n1. Java packages\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1126": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Return of boolean expressions should not be wrapped into an \"if-then-else\" statement\nDescription: Why is this an issue?\nReturn of boolean literal statements wrapped into\nif-then-else\nones should be simplified.\nSimilarly, method invocations wrapped into\nif-then-else\ndiffering only from boolean literals should be simplified into a single\ninvocation.\nNoncompliant code example\n```java\nboolean foo(Object param) {\n  if (expression) { // Noncompliant\n    bar(param, true, \"qix\");\n  } else {\n    bar(param, false, \"qix\");\n  }\n\n  if (expression) {  // Noncompliant\n    return true;\n  } else {\n    return false;\n  }\n}\n```\nCompliant solution\n```java\nboolean foo(Object param) {\n  bar(param, expression, \"qix\");\n\n  return expression;\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1125": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Boolean literals should not be redundant\nDescription: Why is this an issue?\nA boolean literal can be represented in two different ways:\ntrue\nor\nfalse\n. They can be combined with logical operators\n(\n!, &&, ||, ==, !=\n) to produce logical expressions that represent truth values. However, comparing a boolean literal to a\nvariable or expression that evaluates to a boolean value is unnecessary and can make the code harder to read and understand. The more complex a\nboolean expression is, the harder it will be for developers to understand its meaning and expected behavior, and it will favour the introduction of\nnew bugs.\nHow to fix it\nRemove redundant boolean literals from expressions to improve readability and make the code more maintainable.\nCode examples\nNoncompliant code example\n```java\nif (booleanMethod() == true) { /* ... */ }\nif (booleanMethod() == false) { /* ... */ }\nif (booleanMethod() || false) { /* ... */ }\ndoSomething(!false);\ndoSomething(booleanMethod() == true);\n\nbooleanVariable = booleanMethod() ? true : false;\nbooleanVariable = booleanMethod() ? true : exp;\nbooleanVariable = booleanMethod() ? false : exp;\nbooleanVariable = booleanMethod() ? exp : true;\nbooleanVariable = booleanMethod() ? exp : false;\n```\nCompliant solution\n```java\nif (booleanMethod()) { /* ... */ }\nif (!booleanMethod()) { /* ... */ }\nif (booleanMethod()) { /* ... */ }\ndoSomething(true);\ndoSomething(booleanMethod());\n\nbooleanVariable = booleanMethod();\nbooleanVariable = booleanMethod() || exp;\nbooleanVariable = !booleanMethod() && exp;\nbooleanVariable = !booleanMethod() || exp;\nbooleanVariable = booleanMethod() && exp;\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1124": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Modifiers should be declared in the correct order\nDescription: Why is this an issue?\nThe Java Language Specification recommends listing modifiers in the following order:\nAnnotations\npublic\nprotected\nprivate\nabstract\nstatic\nfinal\ntransient\nvolatile\nsynchronized\nnative\ndefault\nstrictfp\nNot following this convention has no technical impact, but will reduce the code\u2019s readability because most developers are used to the standard\norder.\nNoncompliant code example\n```java\nstatic public void main(String[] args) {   // Noncompliant\n}\n```\nCompliant solution\n```java\npublic static void main(String[] args) {   // Compliant\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1123": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Deprecated elements should have both the annotation and the Javadoc tag\nDescription: Why is this an issue?\nDeprecation should be marked with both the\n@Deprecated\nannotation and @deprecated Javadoc tag. The annotation enables tools such as\nIDEs to warn about referencing deprecated elements, and the tag can be used to explain when it was deprecated, why, and how references should be\nrefactored.\nNoncompliant code example\n```java\nclass MyClass {\n\n  @Deprecated\n  public void foo1() {    // Noncompliant: Add the missing @deprecated Javadoc tag.\n  }\n\n  /**\n    * @deprecated\n    */\n  public void foo2() {    // Noncompliant: Add the missing @Deprecated annotation.\n  }\n\n}\n```\nCompliant solution\n```java\nclass MyClass {\n\n  /**\n    * @deprecated (when, why, refactoring advice...)\n    */\n  @Deprecated\n  public void foo1() {\n  }\n\n}\n```\nExceptions\nThe members and methods of a deprecated class or interface are ignored by this rule. The classes and interfaces themselves are still subject to\nit.\n```java\n/**\n * @deprecated (when, why, etc...)\n */\n@Deprecated\nclass Qix  {\n\n  public void foo() {} // Compliant; class is deprecated\n\n}\n\n/**\n * @deprecated (when, why, etc...)\n */\n@Deprecated\ninterface Plop {\n\n  void bar();\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1121": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Assignments should not be made from within sub-expressions\nDescription: Why is this an issue?\nA common code smell that can hinder the clarity of source code is making assignments within sub-expressions. This practice involves assigning a\nvalue to a variable inside a larger expression, such as within a loop or a conditional statement.\nThis practice essentially gives a side-effect to a larger expression, thus making it less readable. This often leads to confusion and potential\nerrors.\nExceptions\nThis rule ignores assignments in conditions of\nwhile\nstatements and assignments enclosed in relational expressions.\n```java\nvoid processInput(BufferedReader br) {\n  String line;\n  while ((line = br.readLine()) != null) {\n    processLine(line);\n  }\n}\n\nObject foo;\nif ((foo = bar()) != null) {\n  // do something with \"foo\"\n}\n```\nThis rule also ignores chained assignments, including compound assignments.\n```java\nint j, i = j = 0;\nint k = (j += 1);\nbyte[] result, bresult;\nresult = (bresult = new byte[len]);\n```\nHow to fix it\nMaking assignments within sub-expressions can hinder the clarity of source code.\nThis practice essentially gives a side-effect to a larger expression, thus making it less readable. This often leads to confusion and potential\nerrors.\nExtracting assignments into separate statements is encouraged to keep the code clear and straightforward.\nCode examples\nNoncompliant code example\n```java\nString str;\nif (!(str = cont.substring(pos1, pos2)).isEmpty()) {  // Noncompliant\n  // do something with \"str\"\n}\n```\nCompliant solution\n```java\nString str = cont.substring(pos1, pos2);\nif (!str.isEmpty()) {\n  // do something with \"str\"\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1120": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Source code should be indented consistently\nDescription: Indentation should be consistent to make the code easy to read, review and modify. To fix this issue, change the indentation so that the text\nstarts at the expected column.\nWhy is this an issue?\nConsistent indentation is a simple and effective way to improve the code\u2019s readability. It reduces the differences that are committed to source\ncontrol systems, making code reviews easier.\nThis rule raises an issue when the indentation does not match the configured value. Only the first line of a badly indented section is\nreported.\nThe rule behaves consistently when the indentation settings of the IDE use\nspaces\ninstead of\ntabs\n. Using\ntabs\ncan lead\nto inconsistent indentation because the width of a\ntab\ncan be configured differently in different environments.\nWhat is the potential impact?\nThe readability is decreased. It becomes more tedious to review and modify the code.\nHow to fix it\nChange the indentation so that the text starts at the expected column. The expected column should be the configured indent size multiplied by the\nlevel at which the code block is nested.\nCode examples\nNoncompliant code example\nWith an indent size of 2:\n```java\nclass Foo {\n  public int a;\n   public int b;   // Noncompliant, expected to start at column 4\n\n...\n\n  public void doSomething() {\n    if(something) {\n          doSomethingElse();  // Noncompliant, expected to start at column 6\n  }   // Noncompliant, expected to start at column 4\n  }\n}\n```\nCompliant solution\n```java\nclass Foo {\n  public int a;\n  public int b;\n\n...\n\n  public void doSomething() {\n    if(something) {\n      doSomethingElse();\n    }\n  }\n}\n```\nGoing the extra mile\nYou can adopt a tool or configure your IDE to take care of code formatting automatically.\nExternal coding guidelines\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-112": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Generic exceptions should never be thrown\nDescription: This rule raises an issue when a generic exception (such as\nError\n,\nRuntimeException\n,\nThrowable\n, or\nException\n) is thrown.\nWhy is this an issue?\nThrowing generic exceptions such as\nError\n,\nRuntimeException\n,\nThrowable\n, and\nException\nwill have\na negative impact on any code trying to catch these exceptions.\nFrom a consumer perspective, it is generally a best practice to only catch exceptions you intend to handle. Other exceptions should ideally be let\nto propagate up the stack trace so that they can be dealt with appropriately. When a generic exception is thrown, it forces consumers to catch\nexceptions they do not intend to handle, which they then have to re-throw.\nBesides, when working with a generic type of exception, the only way to distinguish between multiple exceptions is to check their message, which is\nerror-prone and difficult to maintain. Legitimate exceptions may be unintentionally silenced and errors may be hidden.\nFor instance, when a\nThrowable\nis caught and not re-thrown, it may mask errors such as\nOutOfMemoryError\nand prevent the\nprogram from terminating gracefully.\nWhen throwing an exception, it is therefore recommended to throw the most specific exception possible so that it can be handled intentionally by\nconsumers.\nExceptions\nGeneric exceptions in the signatures of overriding methods are ignored, because an overriding method has to follow the signature of the throw\ndeclaration in the superclass. The issue will be raised on superclass declaration of the method (or won\u2019t be raised at all if superclass is not part\nof the analysis).\n```java\n@Override\npublic void myMethod() throws Exception {...}\n```\nGeneric exceptions are also ignored in the signatures of methods that make calls to methods that throw generic exceptions.\n```java\npublic void myOtherMethod() throws Exception {\n  doTheThing();  // this method throws Exception\n}\n```\nHow to fix it\nTo fix this issue, make sure to throw specific exceptions that are relevant to the context in which they arise. It is recommended to either:\n1. Raise a specific exception from the Java standard library when one matches. For example anIllegalArgumentExceptionshould be\n  thrown when a method receives an invalid argument.\n2. Create a custom exception class deriving fromExceptionor one of its subclasses.\nCode examples\nNoncompliant code example\n```java\nvoid checkValue(int value) throws Throwable { // Noncompliant: signature is too broad\n    if (value == 42) {\n        throw new RuntimeException(\"Value is 42\"); // Noncompliant: This will be difficult for consumers to handle\n    }\n}\n```\nCompliant solution\n```java\nvoid checkValue(int value) {\n    if (value == 42) {\n        throw new IllegalArgumentException(\"Value is 42\"); // Compliant\n    }\n}\n```\nStandards\n1. CWE -CWE-397 Declaration of Throws for Generic Exception\n2. CERT -ERR07-J. Do not throw RuntimeException, Exception, or Throwable\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1119": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Labels should not be used\nDescription: Why is this an issue?\nLabels are not commonly used in Java, and many developers do not understand how they work. Moreover, their usage makes the control flow harder to\nfollow, which reduces the code\u2019s readability.\nNoncompliant code example\n```java\nint matrix[][] = {\n  {1, 2, 3},\n  {4, 5, 6},\n  {7, 8, 9}\n};\n\nouter: for (int row = 0; row < matrix.length; row++) {   // Non-Compliant\n  for (int col = 0; col < matrix[row].length; col++) {\n    if (col == row) {\n      continue outer;\n    }\n    System.out.println(matrix[row][col]);                // Prints the elements under the diagonal, i.e. 4, 7 and 8\n  }\n}\n```\nCompliant solution\n```java\nfor (int row = 1; row < matrix.length; row++) {          // Compliant\n  for (int col = 0; col < row; col++) {\n    System.out.println(matrix[row][col]);                // Also prints 4, 7 and 8\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1118": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Utility classes should not have public constructors\nDescription: Why is this an issue?\nWhenever there are portions of code that are duplicated and do not depend on the state of their container class, they can be centralized inside a\n\"utility class\". A utility class is a class that only has static members, hence it should not be instantiated.\nExceptions\nWhen a class contains\npublic static void main(String[] args)\nmethod it is not considered as a utility class and will be ignored by\nthis rule.\nHow to fix it\nTo prevent the class from being instantiated, you should define a non-public constructor. This will prevent the compiler from implicitly generating\na public parameterless constructor.\nCode examples\nNoncompliant code example\n```java\nclass StringUtils { // Noncompliant\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n```\nCompliant solution\n```java\nclass StringUtils { // Compliant\n\n  private StringUtils() {\n    throw new IllegalStateException(\"Utility class\");\n  }\n\n  public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n  }\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1117": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Local variables should not shadow class fields\nDescription: Why is this an issue?\nShadowing occurs when a local variable has the same name as a variable or a field in an outer scope.\nThis can lead to three main problems:\n1. Confusion: The same name can refer to different variables in different parts of the scope, making the code hard to read and understand.\n2. Unintended Behavior: You might accidentally use the wrong variable, leading to hard-to-detect bugs.\n3. Maintenance Issues: If the inner variable is removed or renamed, the code\u2019s behavior might change unexpectedly because the outer variable is\n  now being used.\nTo avoid these problems, rename the shadowing, shadowed, or both identifiers to accurately represent their purpose with unique and meaningful\nnames.\nThis rule focuses on variables in methods that shadow a field.\nNoncompliant code example\n```java\nclass Foo {\n  public int myField;\n\n  public void doSomething() {\n    int myField = 0; // Noncompliant\n    // ...\n  }\n}\n```\nDocumentation\n1. CERT -DCL51-J. Do not\n  shadow or obscure identifiers in subscopes\nRelated rules\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1116": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Empty statements should be removed\nDescription: Why is this an issue?\nEmpty statements represented by a semicolon\n;\nare statements that do not perform any operation. They are often the result of a typo or\na misunderstanding of the language syntax. It is a good practice to remove empty statements since they don\u2019t add value and lead to confusion and\nerrors.\nCode examples\nNoncompliant code example\n```java\nvoid doSomething() {\n  ; // Noncompliant - was used as a kind of TODO marker\n}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");; // Noncompliant - double ;\n  // ...\n}\n```\nCompliant solution\n```java\nvoid doSomething() {}\n\nvoid doSomethingElse() {\n  System.out.println(\"Hello, world!\");\n  // ...\n  for (int i = 0; i < 3; i++) ; // Compliant if unique statement of a loop\n  // ...\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1113": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: The \"Object.finalize()\" method should not be overridden\nDescription: Why is this an issue?\nBefore it reclaims storage from an object that is no longer referenced, the garbage collector calls\nfinalize()\non the object.\nBut there is no guarantee that this method will be called as soon as the last references to the object are removed.\nIt can be few microseconds to few minutes later.\nFor this reason relying on overriding the\nfinalize()\nmethod to release resources or to update the state of the program is highly\ndiscouraged.\nWhat is the potential impact?\nMore unexpected issues can be caused by relying on the\nfinalize()\nmethod to perform important operations on the application state:\n1. The JVM might terminate without ever calling this method on a particular object, leaving an unexpected or incomplete state of the program\n2. Uncaught exceptions will be ignored inside this method, making it harder to detect issues that could have been logged otherwise\n3. Finalizer methods can also be invoked concurrently, even on single-threaded applications, making it hard to maintain desired program invariants\nNoncompliant code example\n```java\npublic class MyClass {\n\n  @Override\n  protected void finalize() { // Noncompliant\n    releaseSomeResources();\n  }\n\n}\n```\nExceptions\nIt is allowed to override the\nfinalize()\nmethod as\nfinal\nmethod with an empty body, to prevent the\nfinalizer\nattack\nas described in\nMET12-J-EX1\n.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1110": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Redundant pairs of parentheses should be removed\nDescription: Why is this an issue?\nParentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.\n```java\na = (b * c) + (d * e); // Compliant: the intent is clear.\n```\nRedundant parentheses are parenthesis that do not change the behavior of the code, and do not clarify the intent. They can mislead and complexify\nthe code. They should be removed.\nNoncompliant code example\n```java\nint x = ((y / 2 + 1)); // Noncompliant\n\nif (a && ((x + y > 0))) { // Noncompliant\n  return ((x + 1)); // Noncompliant\n}\n```\nCompliant solution\n```java\nint x = (y / 2 + 1);\n\nif (a && (x + y > 0)) {\n  return (x + 1);\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1109": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: A close curly brace should be located at the beginning of a line\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the\nbeginning of a line.\nNoncompliant code example\n```java\nif(condition) {\n  doSomething();}\n```\nCompliant solution\n```java\nif(condition) {\n  doSomething();\n}\n```\nExceptions\nWhen blocks are inlined (open and close curly braces on the same line), no issue is triggered.\n```java\nif(condition) {doSomething();}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1108": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be on two different lines\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to collaborate efficiently.\nThis rule makes it mandatory to place a closing curly brace and the next\nelse\n,\ncatch\nor\nfinally\nkeyword on\ntwo different lines.\nNoncompliant code example\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {          // Noncompliant\n    doSomethingElse();\n  }\n  else {                               // Compliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  }\n  else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  }\n  catch (Exception e) {\n    log(e);\n  }\n  finally {\n    closeConnection();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1107": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Close curly brace and the next \"else\", \"catch\" and \"finally\" keywords should be located on the same line\nDescription: Why is this an issue?\nShared coding conventions make it possible for a team to collaborate efficiently.\nThis rule makes it mandatory to place closing curly braces on the same line as the next\nelse\n,\ncatch\nor\nfinally\nkeywords.\nNoncompliant code example\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  }\n  else {                               // Noncompliant\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  }\n  finally {                            // Noncompliant\n    closeConnection();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod() {\n  if(something) {\n    executeTask();\n  } else if (somethingElse) {\n    doSomethingElse();\n  } else {\n     generateError();\n  }\n\n  try {\n    generateOrder();\n  } catch (Exception e) {\n    log(e);\n  } finally {\n    closeConnection();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1106": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An open curly brace should be located at the beginning of a line\nDescription: Why is this an issue?\nShared coding conventions make it possible to collaborate efficiently. This rule makes it mandatory to place the open curly brace at the beginning\nof a line.\nNoncompliant code example\n```java\npublic void myMethod {  // Noncompliant\n  if(something) {  // Noncompliant\n    executeTask();\n  } else {  // Noncompliant\n    doSomethingElse();\n  }\n}\n```\nCompliant solution\n```java\npublic void myMethod\n{\n  if(something)\n  {\n    executeTask();\n  } else\n  {\n    doSomethingElse();\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1105": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: An open curly brace should be located at the end of a line\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate effectively. This rule raises an issue when an open curly brace is not placed at the end of a\nline of code.\nNoncompliant code example\n```java\nif(condition)\n{\n  doSomething();\n}\n```\nCompliant solution\n```java\nif(condition) {\n  doSomething();\n}\n```\nExceptions\nWhen blocks are inlined (left and right curly braces on the same line), no issue is triggered.\n```java\nif(condition) {doSomething();}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1104": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class variable fields should not have public accessibility\nDescription: Why is this an issue?\nPublic fields in public classes do not respect the encapsulation principle and have three main disadvantages:\n1. Additional behavior such as validation cannot be added.\n2. The internal representation is exposed, and cannot be changed afterwards.\n3. Member values are subject to change from anywhere in the code and may not meet the programmer\u2019s assumptions.\nTo prevent unauthorized modifications, private attributes and accessor methods (set and get) should be used.\nWhat is the potential impact?\nPublic fields can be modified by any part of the code and this can lead to unexpected changes and hard-to-trace bugs.\nPublic fields don\u2019t hide the implementation details. As a consequence, it is no longer possible to change how the data is stored internally without\nimpacting the client code of the class.\nThe code is harder to maintain.\nExceptions\nThis rule ignores\npublic final\nfields because they are not modifiable. Also, annotated fields, whatever the annotation(s) will be\nignored, as annotations are often used by injection frameworks, which in exchange require having public fields.\nHow to fix it\nDepending on your need there are multiple options:\n1. Encapsulate the fieldMake the field private.Define methods to get and set the value of the field.These methods are commonly known as getter and setter methods and are prefixed bygetandsetfollowed by the name of the field.Note:as a bonus it is now possible to monitor value changes\n      using breakpoints.\n2. Make the field private.\n3. Define methods to get and set the value of the field.These methods are commonly known as getter and setter methods and are prefixed bygetandsetfollowed by the name of the field.Note:as a bonus it is now possible to monitor value changes\n      using breakpoints.\n4. Mark the field aspublic finalif it is not supposed to change.\nCode examples\nNoncompliant code example\n```java\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  public String firstName;                       // Noncompliant\n\n}\n```\nCompliant solution\n```java\npublic class MyClass {\n\n  public static final int SOME_CONSTANT = 0;     // Compliant - constants are not checked\n\n  private String firstName;\n\n  public String getFirstName() {\n    return firstName;\n  }\n\n  public void setFirstName(String firstName) {\n    this.firstName = firstName;\n  }\n\n}\n```\nHow does this work?\nBy having a setter and a getter the code can control how the field is accessed and modified. For example, adding validation in the setter method\nwill ensure that only valid values are set.\nThe access modifiers on the setter can also be changed to\nprivate\nor\nprotected\nto restrain which code can modify the\nvalue.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-110": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Inheritance tree of classes should not be too deep\nDescription: Why is this an issue?\nInheritance is one of the most valuable concepts in object-oriented programming. It\u2019s a way to categorize and reuse code by creating collections of\nattributes and behaviors called classes, which can be based on previously created classes.\nBut abusing this concept by creating a deep inheritance tree can lead to complex and unmaintainable source code. Often, an inheritance tree\nbecoming too deep is the symptom of systematic use of \"inheritance\" when other approaches like \"composition\" would be better suited.\nThis rule raises an issue when the inheritance tree, starting from\nObject\n, has a greater depth than is allowed.\nThe rule has one parameter to filter out classes of the count of inheritance. The following rules apply to define this parameter:\n1. ?matches a single character\n2. *matches zero or more characters\n3. **matches zero or more packages\nExamples:\n1. java.fwk.AbstractFwkClass: the count stops when AbstractFwkClass class is reached.\n2. java.fwk.*: any member of java.fwkPackage package is reached.\n3. java.fwk.**: same as above, but including sub-packages.\nExceptions:\nThe rule stops counting when it encounters a class from one of the following packages (or sub-packages):\n1. android.**\n2. com.intellij.**\n3. com.persistit.**\n4. javax.swing.**\n5. org.eclipse.**\n6. org.springframework.**\nDocumentation\nComposition over inheritance: difference between composition and inheritance\nin object-oriented programming\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-109": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Magic numbers should not be used\nDescription: A magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less\nreadable and maintainable.\nWhy is this an issue?\nMagic numbers make the code more complex to understand as it requires the reader to have knowledge about the global context to understand the\nnumber itself. Their usage may seem obvious when writing the code, but it may not be the case for another developer or later once the context faded\naway. -1, 0, and 1 are not considered magic numbers.\nExceptions\nThis rule ignores\nhashCode\nmethods.\nHow to fix it\nReplacing them with a constant allows us to provide a meaningful name associated with the value. Instead of adding complexity to the code, it\nbrings clarity and helps to understand the context and the global meaning.\nCode examples\nNoncompliant code example\n```java\npublic static void doSomething() {\n  for (int i = 0; i < 4; i++) {  // Noncompliant, 4 is a magic number\n    ...\n  }\n}\n```\nCompliant solution\n```java\npublic static final int NUMBER_OF_CYCLES = 4;\npublic static void doSomething() {\n  for (int i = 0; i < NUMBER_OF_CYCLES ; i++) { // Compliant\n    ...\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-108": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Nested blocks of code should not be left empty\nDescription: Why is this an issue?\nAn empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is\nincomplete.\n```java\nfor (int i = 0; i < 42; i++){}  // Noncompliant: is the block empty on purpose, or is code missing?\n```\nRemoving or filling the empty code blocks takes away ambiguity and generally results in a more straightforward and less surprising code.\nExceptions\nThe rule ignores code blocks that contain comments unless they are\nsynchronized\nblocks because these can affect program flow.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1075": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: URIs should not be hardcoded\nDescription: Why is this an issue?\nHard-coding a URI makes it difficult to test a program for a variety of reasons:\n1. path literals are not always portable across operating systems\n2. a given absolute path may not exist in a specific test environment\n3. a specified Internet URL may not be available when executing the tests\n4. production environment filesystems usually differ from the development environment\nIn addition, hard-coded URIs can contain sensitive information, like IP addresses, and they should not be stored in the code.\nFor all those reasons, a URI should never be hard coded. Instead, it should be replaced by a customizable parameter.\nFurther, even if the elements of a URI are obtained dynamically, portability can still be limited if the path delimiters are hard-coded.\nThis rule raises an issue when URIs or path delimiters are hard-coded.\nExceptions\nThis rule does not raise an issue when:\n1. A constant path is relative and contains at most two parts.\n2. A constant path is used in an annotation\n3. A path is annotated\nHow to fix it\nCode examples\nNoncompliant code example\n```java\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public Collection<User> listUsers() {\n    File userList = new File(\"/home/mylogin/Dev/users.txt\"); // Noncompliant\n    Collection<User> users = parse(userList);\n    return users;\n  }\n}\n```\nCompliant solution\n```java\npublic class Foo {\n  // Configuration is a class that returns customizable properties: it can be mocked to be injected during tests.\n  private Configuration config;\n  public Foo(Configuration myConfig) {\n    this.config = myConfig;\n  }\n  public Collection<User> listUsers() {\n    // Find here the way to get the correct folder, in this case using the Configuration object\n    String listingFolder = config.getProperty(\"myApplication.listingFolder\");\n    // and use this parameter instead of the hard coded path\n    File userList = new File(listingFolder, \"users.txt\"); // Compliant\n    Collection<User> users = parse(userList);\n    return users;\n  }\n}\n```\nExceptions examples:\n```java\npublic class Foo {\n  public static final String FRIENDS_ENDPOINT = \"/user/friends\"; // Compliant path is relative and has only two parts\n\n  public static final String ACCOUNT = \"/account/group/list.html\"; // Compliant path is used in an annotation\n\n  @Value(\"${base.url}\" + ACCOUNT)\n  private String groupUrl;\n\n  @MyAnnotation()\n  String path = \"/default/url/for/site\"; // Compliant path is annotated\n\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-107": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Methods should not have too many parameters\nDescription: Why is this an issue?\nMethods with a long parameter list are difficult to use because maintainers must figure out the role of each parameter and keep track of their\nposition.\n```java\nvoid setCoordinates(int x1, int y1, int z1, int x2, int y2, int z2) { // Noncompliant\n    // ...\n}\n```\nThe solution can be to:\n1. Split the method into smaller ones\n```java\n// Each function does a part of what the original setCoordinates function was doing, so confusion risks are lower\nvoid setOrigin(int x, int y, int z) {\n   // ...\n}\n\nvoid setSize(int width, int height, int depth) {\n   // ...\n}\n```\n1. Find a better data structure for the parameters that group data in a way that makes sense for the specific application domain\n```java\nclass Point // In geometry, Point is a logical structure to group data\n{\n    public int x;\n    public int y;\n    public int z;\n };\n\nvoid setCoordinates(Point p1, Point p2) {\n    // ...\n}\n```\nThis rule raises an issue when a method has more parameters than the provided threshold.\nExceptions\nMethods annotated with :\n1. Spring\u2019s@RequestMapping(and related shortcut annotations, like@GetRequest)\n2. JAX-RS API annotations (like@javax.ws.rs.GET)\n3. Bean constructor injection with@org.springframework.beans.factory.annotation.Autowired\n4. CDI constructor injection with@javax.inject.Inject\n5. @com.fasterxml.jackson.annotation.JsonCreator\n6. Micronaut\u2019s annotations (like@io.micronaut.http.annotation.Get)\nmay have a lot of parameters, encapsulation being possible. Therefore the rule ignores such methods.\nAlso, if a class annotated as a Spring component (like\n@org.springframework.stereotype.Component\n) has a single constructor, that\nconstructor will be considered\n@Autowired\nand ignored by the rule.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1068": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused \"private\" fields should be removed\nDescription: Why is this an issue?\nIf a\nprivate\nfield is declared but not used locally, its limited visibility makes it dead code.\nThis is either a sign that some logic is missing or that the code should be cleaned.\nCleaning out dead code decreases the size of the maintained codebase, making it easier to understand and preventing bugs from being introduced.\n```java\npublic class MyClass {\n  private int foo = 42; // Noncompliant: foo is unused and should be removed\n\n  public int compute(int a) {\n    return a * 42;\n  }\n\n}\n```\nNote that this rule does not take reflection into account, which means that issues will be raised on\nprivate\nfields that are only\naccessed using the reflection API.\nExceptions\nThe rule admits 3 exceptions:\n1. Serialization ID fields\nThe Java serialization runtime associates with each serializable class a version number called\nserialVersionUID\n, which is used during\ndeserialization to verify that the sender and receiver of a serialized object have loaded classes for that object that are compatible for\nserialization.\nA serializable class can declare its own\nserialVersionUID\nexplicitly by declaring a field named\nserialVersionUID\nthat\nmust be static, final, and of type long. By definition, those\nserialVersionUID\nfields should not be reported by this rule:\n```java\npublic class MyClass implements java.io.Serializable {\n  private static final long serialVersionUID = 42L;  // Compliant by exception\n}\n```\n1. Annotated fields and classes annotated with Lombok annotations\nThe unused field in this class will not be reported by the rule as it is annotated, except if annotation class\nSomeAnnotation\nis\nlisted in the\nignoreAnnotations\nparameter (see Parameters).\n```java\npublic class MyClass {\n  @SomeAnnotation\n  private int unused;  // Compliant by exception\n}\n```\n1. Fields from classes with native methods\nThe unused field in this class will not be reported by the rule as it might be used by native code.\n```java\npublic class MyClass {\n  private int unused = 42;  // Compliant by exception\n  private native static void doSomethingNative();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1067": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Expressions should not be too complex\nDescription: Why is this an issue?\nThe complexity of an expression is defined by the number of\n&&\n,\n||\nand\ncondition ? ifTrue : ifFalse\noperators it contains.\nA single expression\u2019s complexity should not become too high to keep the code readable.\nNoncompliant code example\nWith the default threshold value of 3:\n```java\nif (((condition1 && condition2) || (condition3 && condition4)) && condition5) { ... }\n```\nCompliant solution\n```java\nif ( (myFirstCondition() || mySecondCondition()) && myLastCondition()) { ... }\n```\nExceptions\nNo issue is reported inside\nequals\nmethods, because it is common to compare all the fields of a class for equality inside this kind of\nmethod.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1066": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Mergeable \"if\" statements should be combined\nDescription: Why is this an issue?\nNested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as\npossible, by avoiding unnecessary nesting, is considered a good practice.\nMerging\nif\nstatements when possible will decrease the nesting of the code and improve its readability.\nCode like\n```java\nif (condition1) {\n  if (condition2) {             // Noncompliant\n    /* ... */\n  }\n}\n```\nWill be more readable as\n```java\nif (condition1 && condition2) { // Compliant\n  /* ... */\n}\n```\nHow to fix it\nIf merging the conditions seems to result in a more complex code, extracting the condition or part of it in a named function or variable is a\nbetter approach to fix readability.\nCode examples\nNoncompliant code example\n```java\nif (file != null) {\n  if (file.isFile() || file.isDirectory()) {  // Noncompliant\n    /* ... */\n  }\n}\n```\nCompliant solution\n```java\nif (file != null && isFileOrDirectory(file)) { // Compliant\n  /* ... */\n}\n\nprivate static boolean isFileOrDirectory(File file) {\n  return file.isFile() || file.isDirectory();\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-1065": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Unused labels should be removed\nDescription: Why is this an issue?\nIf a label is declared but not used in the program, it can be considered as dead code and should therefore be removed.\nThis will improve maintainability as developers will not wonder what this label is used for.\nNoncompliant code example\n```java\nvoid foo() {\n  outer: //label is not used.\n  for(int i = 0; i<10; i++) {\n    break;\n  }\n}\n```\nCompliant solution\n```java\nvoid foo() {\n  for(int i = 0; i<10; i++) {\n    break;\n  }\n}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-106": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Standard outputs should not be used directly to log anything\nDescription: Why is this an issue?\nIn software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is\nessential to ensure that the logs are:\n1. easily accessible\n2. uniformly formatted for readability\n3. properly recorded\n4. securely logged when dealing with sensitive data\nThose requirements are not met if a program directly writes to the standard outputs (e.g., System.out, System.err). That is why defining and using\na dedicated logger is highly recommended.\nCode examples\nThe following noncompliant code:\n```java\nclass MyClass {\n  public void doSomething() {\n    System.out.println(\"My Message\");  // Noncompliant, output directly to System.out without a logger\n  }\n}\n```\nCould be replaced by:\n```java\nimport java.util.logging.Logger;\n\nclass MyClass {\n\n  Logger logger = Logger.getLogger(getClass().getName());\n\n  public void doSomething() {\n    // ...\n    logger.info(\"My Message\");  // Compliant, output via logger\n    // ...\n  }\n}\n```\nDocumentation\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-105": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Tabulation characters should not be used\nDescription: Why is this an issue?\nThe tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text\neditor, preferences, etc.) to read source code.\nThat is why using spaces is preferable.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-104": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Files should not have too many lines of code\nDescription: Why is this an issue?\nWhen a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.\nAbove a specific threshold, refactor the file into smaller files whose code focuses on well-defined tasks. Those smaller files will be easier to\nunderstand and test.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-103": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Lines should not be too long\nDescription: Why is this an issue?\nScrolling horizontally to see a full line of code lowers the code readability.\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-101": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Class names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently.\nThis rule raises an issue when a class name does not match a provided regular expression.\nFor example, with the default provided regular expression\n^[A-Z][a-zA-Z0-9]*$\n, the class:\n```java\nclass my_class {...} // Noncompliant\n```\nshould be renamed to\n```java\nclass MyClass {...}\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n",
    "RSPEC-100": "You are a senior Java engineer performing a surgical refactor to satisfy a specific Sonar rule.\n\nInput:\nRule Summary: Method names should comply with a naming convention\nDescription: Why is this an issue?\nShared naming conventions allow teams to collaborate efficiently.\nThis rule raises an issue when a method name does not match a provided regular expression.\nFor example, with the default provided regular expression\n^[a-z][a-zA-Z0-9]*$\n, the method:\n```java\npublic int DoSomething(){...} // Noncompliant\n```\nshould be renamed to\n```java\npublic int doSomething(){...}\n```\nExceptions\nOverriding methods are excluded.\n```java\n@Override\npublic int Do_Something(){...} // Compliant by exception\n```\n\nTask:\nAnalyze the provided noncompliant code file and refactor the code to align with sonar rule summary, description.\nPerform a surgical refactor preserving the original behavior to make the code compliant, keeping the refactor minimal.\n\nCode lines to refactor::\n```java\n{{replace_code_smell_lines_here}}\n```\n\nComplete Code file::\n```java\n{{replace_full_code_here}}\n```\n\nDo not modify existing logic of the code.\nFormat your output as only refactored java Code file\n"
}